// File automatically generated by ast/asdl_rs.py.

#[pyclass(module="rustpython_ast.ranged", name="_mod", extends=super::Ast, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Mod;

impl From<&'static ast::Mod<TextRange>> for Mod {
    fn from(_node: &'static ast::Mod<TextRange>) -> Self {
        Mod
    }
}

#[pymethods]
impl Mod {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(Ast).add_subclass(Self)
    }
}
impl ToPyObject for Mod {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::Mod<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::Module(cons) => cons.to_py_wrapper(py),
            Self::Interactive(cons) => cons.to_py_wrapper(py),
            Self::Expression(cons) => cons.to_py_wrapper(py),
            Self::FunctionType(cons) => cons.to_py_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Module", extends=Mod, frozen)]
#[derive(Clone, Debug)]
pub struct ModModule(pub &'static ast::ModModule<TextRange>);

impl From<&'static ast::ModModule<TextRange>> for ModModule {
    fn from(node: &'static ast::ModModule<TextRange>) -> Self {
        ModModule(node)
    }
}

impl ToPyObject for ModModule {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Mod)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ModModule<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ModModule(self).to_object(py))
    }
}

#[pymethods]
impl ModModule {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_ignores(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_ignores.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Interactive", extends=Mod, frozen)]
#[derive(Clone, Debug)]
pub struct ModInteractive(pub &'static ast::ModInteractive<TextRange>);

impl From<&'static ast::ModInteractive<TextRange>> for ModInteractive {
    fn from(node: &'static ast::ModInteractive<TextRange>) -> Self {
        ModInteractive(node)
    }
}

impl ToPyObject for ModInteractive {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Mod)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ModInteractive<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ModInteractive(self).to_object(py))
    }
}

#[pymethods]
impl ModInteractive {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Expression", extends=Mod, frozen)]
#[derive(Clone, Debug)]
pub struct ModExpression(pub &'static ast::ModExpression<TextRange>);

impl From<&'static ast::ModExpression<TextRange>> for ModExpression {
    fn from(node: &'static ast::ModExpression<TextRange>) -> Self {
        ModExpression(node)
    }
}

impl ToPyObject for ModExpression {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Mod)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ModExpression<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ModExpression(self).to_object(py))
    }
}

#[pymethods]
impl ModExpression {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_FunctionType", extends=Mod, frozen)]
#[derive(Clone, Debug)]
pub struct ModFunctionType(pub &'static ast::ModFunctionType<TextRange>);

impl From<&'static ast::ModFunctionType<TextRange>> for ModFunctionType {
    fn from(node: &'static ast::ModFunctionType<TextRange>) -> Self {
        ModFunctionType(node)
    }
}

impl ToPyObject for ModFunctionType {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Mod)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ModFunctionType<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ModFunctionType(self).to_object(py))
    }
}

#[pymethods]
impl ModFunctionType {
    #[getter]
    #[inline]
    fn get_argtypes(&self, py: Python) -> PyResult<PyObject> {
        self.0.argtypes.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_returns(&self, py: Python) -> PyResult<PyObject> {
        self.0.returns.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_stmt", extends=super::Ast, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Stmt;

impl From<&'static ast::Stmt<TextRange>> for Stmt {
    fn from(_node: &'static ast::Stmt<TextRange>) -> Self {
        Stmt
    }
}

#[pymethods]
impl Stmt {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(Ast).add_subclass(Self)
    }
}
impl ToPyObject for Stmt {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::Stmt<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::FunctionDef(cons) => cons.to_py_wrapper(py),
            Self::AsyncFunctionDef(cons) => cons.to_py_wrapper(py),
            Self::ClassDef(cons) => cons.to_py_wrapper(py),
            Self::Return(cons) => cons.to_py_wrapper(py),
            Self::Delete(cons) => cons.to_py_wrapper(py),
            Self::Assign(cons) => cons.to_py_wrapper(py),
            Self::AugAssign(cons) => cons.to_py_wrapper(py),
            Self::AnnAssign(cons) => cons.to_py_wrapper(py),
            Self::For(cons) => cons.to_py_wrapper(py),
            Self::AsyncFor(cons) => cons.to_py_wrapper(py),
            Self::While(cons) => cons.to_py_wrapper(py),
            Self::If(cons) => cons.to_py_wrapper(py),
            Self::With(cons) => cons.to_py_wrapper(py),
            Self::AsyncWith(cons) => cons.to_py_wrapper(py),
            Self::Match(cons) => cons.to_py_wrapper(py),
            Self::Raise(cons) => cons.to_py_wrapper(py),
            Self::Try(cons) => cons.to_py_wrapper(py),
            Self::TryStar(cons) => cons.to_py_wrapper(py),
            Self::Assert(cons) => cons.to_py_wrapper(py),
            Self::Import(cons) => cons.to_py_wrapper(py),
            Self::ImportFrom(cons) => cons.to_py_wrapper(py),
            Self::Global(cons) => cons.to_py_wrapper(py),
            Self::Nonlocal(cons) => cons.to_py_wrapper(py),
            Self::Expr(cons) => cons.to_py_wrapper(py),
            Self::Pass(cons) => cons.to_py_wrapper(py),
            Self::Break(cons) => cons.to_py_wrapper(py),
            Self::Continue(cons) => cons.to_py_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_FunctionDef", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtFunctionDef(pub &'static ast::StmtFunctionDef<TextRange>);

impl From<&'static ast::StmtFunctionDef<TextRange>> for StmtFunctionDef {
    fn from(node: &'static ast::StmtFunctionDef<TextRange>) -> Self {
        StmtFunctionDef(node)
    }
}

impl ToPyObject for StmtFunctionDef {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtFunctionDef<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtFunctionDef(self).to_object(py))
    }
}

#[pymethods]
impl StmtFunctionDef {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_decorator_list(&self, py: Python) -> PyResult<PyObject> {
        self.0.decorator_list.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_returns(&self, py: Python) -> PyResult<PyObject> {
        self.0.returns.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_AsyncFunctionDef", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAsyncFunctionDef(pub &'static ast::StmtAsyncFunctionDef<TextRange>);

impl From<&'static ast::StmtAsyncFunctionDef<TextRange>> for StmtAsyncFunctionDef {
    fn from(node: &'static ast::StmtAsyncFunctionDef<TextRange>) -> Self {
        StmtAsyncFunctionDef(node)
    }
}

impl ToPyObject for StmtAsyncFunctionDef {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtAsyncFunctionDef<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAsyncFunctionDef(self).to_object(py))
    }
}

#[pymethods]
impl StmtAsyncFunctionDef {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_decorator_list(&self, py: Python) -> PyResult<PyObject> {
        self.0.decorator_list.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_returns(&self, py: Python) -> PyResult<PyObject> {
        self.0.returns.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_ClassDef", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtClassDef(pub &'static ast::StmtClassDef<TextRange>);

impl From<&'static ast::StmtClassDef<TextRange>> for StmtClassDef {
    fn from(node: &'static ast::StmtClassDef<TextRange>) -> Self {
        StmtClassDef(node)
    }
}

impl ToPyObject for StmtClassDef {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtClassDef<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtClassDef(self).to_object(py))
    }
}

#[pymethods]
impl StmtClassDef {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_bases(&self, py: Python) -> PyResult<PyObject> {
        self.0.bases.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_keywords(&self, py: Python) -> PyResult<PyObject> {
        self.0.keywords.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_decorator_list(&self, py: Python) -> PyResult<PyObject> {
        self.0.decorator_list.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Return", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtReturn(pub &'static ast::StmtReturn<TextRange>);

impl From<&'static ast::StmtReturn<TextRange>> for StmtReturn {
    fn from(node: &'static ast::StmtReturn<TextRange>) -> Self {
        StmtReturn(node)
    }
}

impl ToPyObject for StmtReturn {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtReturn<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtReturn(self).to_object(py))
    }
}

#[pymethods]
impl StmtReturn {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Delete", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtDelete(pub &'static ast::StmtDelete<TextRange>);

impl From<&'static ast::StmtDelete<TextRange>> for StmtDelete {
    fn from(node: &'static ast::StmtDelete<TextRange>) -> Self {
        StmtDelete(node)
    }
}

impl ToPyObject for StmtDelete {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtDelete<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtDelete(self).to_object(py))
    }
}

#[pymethods]
impl StmtDelete {
    #[getter]
    #[inline]
    fn get_targets(&self, py: Python) -> PyResult<PyObject> {
        self.0.targets.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Assign", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAssign(pub &'static ast::StmtAssign<TextRange>);

impl From<&'static ast::StmtAssign<TextRange>> for StmtAssign {
    fn from(node: &'static ast::StmtAssign<TextRange>) -> Self {
        StmtAssign(node)
    }
}

impl ToPyObject for StmtAssign {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtAssign<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAssign(self).to_object(py))
    }
}

#[pymethods]
impl StmtAssign {
    #[getter]
    #[inline]
    fn get_targets(&self, py: Python) -> PyResult<PyObject> {
        self.0.targets.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_AugAssign", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAugAssign(pub &'static ast::StmtAugAssign<TextRange>);

impl From<&'static ast::StmtAugAssign<TextRange>> for StmtAugAssign {
    fn from(node: &'static ast::StmtAugAssign<TextRange>) -> Self {
        StmtAugAssign(node)
    }
}

impl ToPyObject for StmtAugAssign {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtAugAssign<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAugAssign(self).to_object(py))
    }
}

#[pymethods]
impl StmtAugAssign {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_op(&self, py: Python) -> PyResult<PyObject> {
        self.0.op.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_AnnAssign", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAnnAssign(pub &'static ast::StmtAnnAssign<TextRange>);

impl From<&'static ast::StmtAnnAssign<TextRange>> for StmtAnnAssign {
    fn from(node: &'static ast::StmtAnnAssign<TextRange>) -> Self {
        StmtAnnAssign(node)
    }
}

impl ToPyObject for StmtAnnAssign {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtAnnAssign<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAnnAssign(self).to_object(py))
    }
}

#[pymethods]
impl StmtAnnAssign {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_annotation(&self, py: Python) -> PyResult<PyObject> {
        self.0.annotation.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_simple(&self, py: Python) -> PyResult<PyObject> {
        self.0.simple.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_For", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtFor(pub &'static ast::StmtFor<TextRange>);

impl From<&'static ast::StmtFor<TextRange>> for StmtFor {
    fn from(node: &'static ast::StmtFor<TextRange>) -> Self {
        StmtFor(node)
    }
}

impl ToPyObject for StmtFor {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtFor<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtFor(self).to_object(py))
    }
}

#[pymethods]
impl StmtFor {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_iter(&self, py: Python) -> PyResult<PyObject> {
        self.0.iter.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_AsyncFor", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAsyncFor(pub &'static ast::StmtAsyncFor<TextRange>);

impl From<&'static ast::StmtAsyncFor<TextRange>> for StmtAsyncFor {
    fn from(node: &'static ast::StmtAsyncFor<TextRange>) -> Self {
        StmtAsyncFor(node)
    }
}

impl ToPyObject for StmtAsyncFor {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtAsyncFor<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAsyncFor(self).to_object(py))
    }
}

#[pymethods]
impl StmtAsyncFor {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_iter(&self, py: Python) -> PyResult<PyObject> {
        self.0.iter.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_While", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtWhile(pub &'static ast::StmtWhile<TextRange>);

impl From<&'static ast::StmtWhile<TextRange>> for StmtWhile {
    fn from(node: &'static ast::StmtWhile<TextRange>) -> Self {
        StmtWhile(node)
    }
}

impl ToPyObject for StmtWhile {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtWhile<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtWhile(self).to_object(py))
    }
}

#[pymethods]
impl StmtWhile {
    #[getter]
    #[inline]
    fn get_test(&self, py: Python) -> PyResult<PyObject> {
        self.0.test.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_If", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtIf(pub &'static ast::StmtIf<TextRange>);

impl From<&'static ast::StmtIf<TextRange>> for StmtIf {
    fn from(node: &'static ast::StmtIf<TextRange>) -> Self {
        StmtIf(node)
    }
}

impl ToPyObject for StmtIf {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtIf<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtIf(self).to_object(py))
    }
}

#[pymethods]
impl StmtIf {
    #[getter]
    #[inline]
    fn get_test(&self, py: Python) -> PyResult<PyObject> {
        self.0.test.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_With", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtWith(pub &'static ast::StmtWith<TextRange>);

impl From<&'static ast::StmtWith<TextRange>> for StmtWith {
    fn from(node: &'static ast::StmtWith<TextRange>) -> Self {
        StmtWith(node)
    }
}

impl ToPyObject for StmtWith {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtWith<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtWith(self).to_object(py))
    }
}

#[pymethods]
impl StmtWith {
    #[getter]
    #[inline]
    fn get_items(&self, py: Python) -> PyResult<PyObject> {
        self.0.items.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_AsyncWith", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAsyncWith(pub &'static ast::StmtAsyncWith<TextRange>);

impl From<&'static ast::StmtAsyncWith<TextRange>> for StmtAsyncWith {
    fn from(node: &'static ast::StmtAsyncWith<TextRange>) -> Self {
        StmtAsyncWith(node)
    }
}

impl ToPyObject for StmtAsyncWith {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtAsyncWith<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAsyncWith(self).to_object(py))
    }
}

#[pymethods]
impl StmtAsyncWith {
    #[getter]
    #[inline]
    fn get_items(&self, py: Python) -> PyResult<PyObject> {
        self.0.items.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Match", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtMatch(pub &'static ast::StmtMatch<TextRange>);

impl From<&'static ast::StmtMatch<TextRange>> for StmtMatch {
    fn from(node: &'static ast::StmtMatch<TextRange>) -> Self {
        StmtMatch(node)
    }
}

impl ToPyObject for StmtMatch {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtMatch<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtMatch(self).to_object(py))
    }
}

#[pymethods]
impl StmtMatch {
    #[getter]
    #[inline]
    fn get_subject(&self, py: Python) -> PyResult<PyObject> {
        self.0.subject.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_cases(&self, py: Python) -> PyResult<PyObject> {
        self.0.cases.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Raise", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtRaise(pub &'static ast::StmtRaise<TextRange>);

impl From<&'static ast::StmtRaise<TextRange>> for StmtRaise {
    fn from(node: &'static ast::StmtRaise<TextRange>) -> Self {
        StmtRaise(node)
    }
}

impl ToPyObject for StmtRaise {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtRaise<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtRaise(self).to_object(py))
    }
}

#[pymethods]
impl StmtRaise {
    #[getter]
    #[inline]
    fn get_exc(&self, py: Python) -> PyResult<PyObject> {
        self.0.exc.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_cause(&self, py: Python) -> PyResult<PyObject> {
        self.0.cause.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Try", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtTry(pub &'static ast::StmtTry<TextRange>);

impl From<&'static ast::StmtTry<TextRange>> for StmtTry {
    fn from(node: &'static ast::StmtTry<TextRange>) -> Self {
        StmtTry(node)
    }
}

impl ToPyObject for StmtTry {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtTry<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtTry(self).to_object(py))
    }
}

#[pymethods]
impl StmtTry {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_handlers(&self, py: Python) -> PyResult<PyObject> {
        self.0.handlers.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_finalbody(&self, py: Python) -> PyResult<PyObject> {
        self.0.finalbody.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_TryStar", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtTryStar(pub &'static ast::StmtTryStar<TextRange>);

impl From<&'static ast::StmtTryStar<TextRange>> for StmtTryStar {
    fn from(node: &'static ast::StmtTryStar<TextRange>) -> Self {
        StmtTryStar(node)
    }
}

impl ToPyObject for StmtTryStar {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtTryStar<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtTryStar(self).to_object(py))
    }
}

#[pymethods]
impl StmtTryStar {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_handlers(&self, py: Python) -> PyResult<PyObject> {
        self.0.handlers.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_finalbody(&self, py: Python) -> PyResult<PyObject> {
        self.0.finalbody.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Assert", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAssert(pub &'static ast::StmtAssert<TextRange>);

impl From<&'static ast::StmtAssert<TextRange>> for StmtAssert {
    fn from(node: &'static ast::StmtAssert<TextRange>) -> Self {
        StmtAssert(node)
    }
}

impl ToPyObject for StmtAssert {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtAssert<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAssert(self).to_object(py))
    }
}

#[pymethods]
impl StmtAssert {
    #[getter]
    #[inline]
    fn get_test(&self, py: Python) -> PyResult<PyObject> {
        self.0.test.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_msg(&self, py: Python) -> PyResult<PyObject> {
        self.0.msg.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Import", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtImport(pub &'static ast::StmtImport<TextRange>);

impl From<&'static ast::StmtImport<TextRange>> for StmtImport {
    fn from(node: &'static ast::StmtImport<TextRange>) -> Self {
        StmtImport(node)
    }
}

impl ToPyObject for StmtImport {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtImport<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtImport(self).to_object(py))
    }
}

#[pymethods]
impl StmtImport {
    #[getter]
    #[inline]
    fn get_names(&self, py: Python) -> PyResult<PyObject> {
        self.0.names.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_ImportFrom", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtImportFrom(pub &'static ast::StmtImportFrom<TextRange>);

impl From<&'static ast::StmtImportFrom<TextRange>> for StmtImportFrom {
    fn from(node: &'static ast::StmtImportFrom<TextRange>) -> Self {
        StmtImportFrom(node)
    }
}

impl ToPyObject for StmtImportFrom {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtImportFrom<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtImportFrom(self).to_object(py))
    }
}

#[pymethods]
impl StmtImportFrom {
    #[getter]
    #[inline]
    fn get_module(&self, py: Python) -> PyResult<PyObject> {
        self.0.module.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_names(&self, py: Python) -> PyResult<PyObject> {
        self.0.names.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_level(&self, py: Python) -> PyResult<PyObject> {
        self.0.level.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Global", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtGlobal(pub &'static ast::StmtGlobal<TextRange>);

impl From<&'static ast::StmtGlobal<TextRange>> for StmtGlobal {
    fn from(node: &'static ast::StmtGlobal<TextRange>) -> Self {
        StmtGlobal(node)
    }
}

impl ToPyObject for StmtGlobal {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtGlobal<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtGlobal(self).to_object(py))
    }
}

#[pymethods]
impl StmtGlobal {
    #[getter]
    #[inline]
    fn get_names(&self, py: Python) -> PyResult<PyObject> {
        self.0.names.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Nonlocal", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtNonlocal(pub &'static ast::StmtNonlocal<TextRange>);

impl From<&'static ast::StmtNonlocal<TextRange>> for StmtNonlocal {
    fn from(node: &'static ast::StmtNonlocal<TextRange>) -> Self {
        StmtNonlocal(node)
    }
}

impl ToPyObject for StmtNonlocal {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtNonlocal<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtNonlocal(self).to_object(py))
    }
}

#[pymethods]
impl StmtNonlocal {
    #[getter]
    #[inline]
    fn get_names(&self, py: Python) -> PyResult<PyObject> {
        self.0.names.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Expr", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtExpr(pub &'static ast::StmtExpr<TextRange>);

impl From<&'static ast::StmtExpr<TextRange>> for StmtExpr {
    fn from(node: &'static ast::StmtExpr<TextRange>) -> Self {
        StmtExpr(node)
    }
}

impl ToPyObject for StmtExpr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtExpr<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtExpr(self).to_object(py))
    }
}

#[pymethods]
impl StmtExpr {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Pass", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtPass(pub &'static ast::StmtPass<TextRange>);

impl From<&'static ast::StmtPass<TextRange>> for StmtPass {
    fn from(node: &'static ast::StmtPass<TextRange>) -> Self {
        StmtPass(node)
    }
}

impl ToPyObject for StmtPass {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtPass<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtPass(self).to_object(py))
    }
}

#[pymethods]
impl StmtPass {}

#[pyclass(module="rustpython_ast.ranged", name="_Break", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtBreak(pub &'static ast::StmtBreak<TextRange>);

impl From<&'static ast::StmtBreak<TextRange>> for StmtBreak {
    fn from(node: &'static ast::StmtBreak<TextRange>) -> Self {
        StmtBreak(node)
    }
}

impl ToPyObject for StmtBreak {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtBreak<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtBreak(self).to_object(py))
    }
}

#[pymethods]
impl StmtBreak {}

#[pyclass(module="rustpython_ast.ranged", name="_Continue", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtContinue(pub &'static ast::StmtContinue<TextRange>);

impl From<&'static ast::StmtContinue<TextRange>> for StmtContinue {
    fn from(node: &'static ast::StmtContinue<TextRange>) -> Self {
        StmtContinue(node)
    }
}

impl ToPyObject for StmtContinue {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::StmtContinue<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtContinue(self).to_object(py))
    }
}

#[pymethods]
impl StmtContinue {}

#[pyclass(module="rustpython_ast.ranged", name="_expr", extends=super::Ast, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Expr;

impl From<&'static ast::Expr<TextRange>> for Expr {
    fn from(_node: &'static ast::Expr<TextRange>) -> Self {
        Expr
    }
}

#[pymethods]
impl Expr {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(Ast).add_subclass(Self)
    }
}
impl ToPyObject for Expr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::Expr<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::BoolOp(cons) => cons.to_py_wrapper(py),
            Self::NamedExpr(cons) => cons.to_py_wrapper(py),
            Self::BinOp(cons) => cons.to_py_wrapper(py),
            Self::UnaryOp(cons) => cons.to_py_wrapper(py),
            Self::Lambda(cons) => cons.to_py_wrapper(py),
            Self::IfExp(cons) => cons.to_py_wrapper(py),
            Self::Dict(cons) => cons.to_py_wrapper(py),
            Self::Set(cons) => cons.to_py_wrapper(py),
            Self::ListComp(cons) => cons.to_py_wrapper(py),
            Self::SetComp(cons) => cons.to_py_wrapper(py),
            Self::DictComp(cons) => cons.to_py_wrapper(py),
            Self::GeneratorExp(cons) => cons.to_py_wrapper(py),
            Self::Await(cons) => cons.to_py_wrapper(py),
            Self::Yield(cons) => cons.to_py_wrapper(py),
            Self::YieldFrom(cons) => cons.to_py_wrapper(py),
            Self::Compare(cons) => cons.to_py_wrapper(py),
            Self::Call(cons) => cons.to_py_wrapper(py),
            Self::FormattedValue(cons) => cons.to_py_wrapper(py),
            Self::JoinedStr(cons) => cons.to_py_wrapper(py),
            Self::Constant(cons) => cons.to_py_wrapper(py),
            Self::Attribute(cons) => cons.to_py_wrapper(py),
            Self::Subscript(cons) => cons.to_py_wrapper(py),
            Self::Starred(cons) => cons.to_py_wrapper(py),
            Self::Name(cons) => cons.to_py_wrapper(py),
            Self::List(cons) => cons.to_py_wrapper(py),
            Self::Tuple(cons) => cons.to_py_wrapper(py),
            Self::Slice(cons) => cons.to_py_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_BoolOp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprBoolOp(pub &'static ast::ExprBoolOp<TextRange>);

impl From<&'static ast::ExprBoolOp<TextRange>> for ExprBoolOp {
    fn from(node: &'static ast::ExprBoolOp<TextRange>) -> Self {
        ExprBoolOp(node)
    }
}

impl ToPyObject for ExprBoolOp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprBoolOp<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprBoolOp(self).to_object(py))
    }
}

#[pymethods]
impl ExprBoolOp {
    #[getter]
    #[inline]
    fn get_op(&self, py: Python) -> PyResult<PyObject> {
        self.0.op.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_values(&self, py: Python) -> PyResult<PyObject> {
        self.0.values.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_NamedExpr", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprNamedExpr(pub &'static ast::ExprNamedExpr<TextRange>);

impl From<&'static ast::ExprNamedExpr<TextRange>> for ExprNamedExpr {
    fn from(node: &'static ast::ExprNamedExpr<TextRange>) -> Self {
        ExprNamedExpr(node)
    }
}

impl ToPyObject for ExprNamedExpr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprNamedExpr<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprNamedExpr(self).to_object(py))
    }
}

#[pymethods]
impl ExprNamedExpr {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_BinOp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprBinOp(pub &'static ast::ExprBinOp<TextRange>);

impl From<&'static ast::ExprBinOp<TextRange>> for ExprBinOp {
    fn from(node: &'static ast::ExprBinOp<TextRange>) -> Self {
        ExprBinOp(node)
    }
}

impl ToPyObject for ExprBinOp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprBinOp<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprBinOp(self).to_object(py))
    }
}

#[pymethods]
impl ExprBinOp {
    #[getter]
    #[inline]
    fn get_left(&self, py: Python) -> PyResult<PyObject> {
        self.0.left.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_op(&self, py: Python) -> PyResult<PyObject> {
        self.0.op.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_right(&self, py: Python) -> PyResult<PyObject> {
        self.0.right.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_UnaryOp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprUnaryOp(pub &'static ast::ExprUnaryOp<TextRange>);

impl From<&'static ast::ExprUnaryOp<TextRange>> for ExprUnaryOp {
    fn from(node: &'static ast::ExprUnaryOp<TextRange>) -> Self {
        ExprUnaryOp(node)
    }
}

impl ToPyObject for ExprUnaryOp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprUnaryOp<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprUnaryOp(self).to_object(py))
    }
}

#[pymethods]
impl ExprUnaryOp {
    #[getter]
    #[inline]
    fn get_op(&self, py: Python) -> PyResult<PyObject> {
        self.0.op.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_operand(&self, py: Python) -> PyResult<PyObject> {
        self.0.operand.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Lambda", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprLambda(pub &'static ast::ExprLambda<TextRange>);

impl From<&'static ast::ExprLambda<TextRange>> for ExprLambda {
    fn from(node: &'static ast::ExprLambda<TextRange>) -> Self {
        ExprLambda(node)
    }
}

impl ToPyObject for ExprLambda {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprLambda<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprLambda(self).to_object(py))
    }
}

#[pymethods]
impl ExprLambda {
    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_IfExp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprIfExp(pub &'static ast::ExprIfExp<TextRange>);

impl From<&'static ast::ExprIfExp<TextRange>> for ExprIfExp {
    fn from(node: &'static ast::ExprIfExp<TextRange>) -> Self {
        ExprIfExp(node)
    }
}

impl ToPyObject for ExprIfExp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprIfExp<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprIfExp(self).to_object(py))
    }
}

#[pymethods]
impl ExprIfExp {
    #[getter]
    #[inline]
    fn get_test(&self, py: Python) -> PyResult<PyObject> {
        self.0.test.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Dict", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprDict(pub &'static ast::ExprDict<TextRange>);

impl From<&'static ast::ExprDict<TextRange>> for ExprDict {
    fn from(node: &'static ast::ExprDict<TextRange>) -> Self {
        ExprDict(node)
    }
}

impl ToPyObject for ExprDict {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprDict<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprDict(self).to_object(py))
    }
}

#[pymethods]
impl ExprDict {
    #[getter]
    #[inline]
    fn get_keys(&self, py: Python) -> PyResult<PyObject> {
        self.0.keys.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_values(&self, py: Python) -> PyResult<PyObject> {
        self.0.values.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Set", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprSet(pub &'static ast::ExprSet<TextRange>);

impl From<&'static ast::ExprSet<TextRange>> for ExprSet {
    fn from(node: &'static ast::ExprSet<TextRange>) -> Self {
        ExprSet(node)
    }
}

impl ToPyObject for ExprSet {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprSet<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprSet(self).to_object(py))
    }
}

#[pymethods]
impl ExprSet {
    #[getter]
    #[inline]
    fn get_elts(&self, py: Python) -> PyResult<PyObject> {
        self.0.elts.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_ListComp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprListComp(pub &'static ast::ExprListComp<TextRange>);

impl From<&'static ast::ExprListComp<TextRange>> for ExprListComp {
    fn from(node: &'static ast::ExprListComp<TextRange>) -> Self {
        ExprListComp(node)
    }
}

impl ToPyObject for ExprListComp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprListComp<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprListComp(self).to_object(py))
    }
}

#[pymethods]
impl ExprListComp {
    #[getter]
    #[inline]
    fn get_elt(&self, py: Python) -> PyResult<PyObject> {
        self.0.elt.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_generators(&self, py: Python) -> PyResult<PyObject> {
        self.0.generators.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_SetComp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprSetComp(pub &'static ast::ExprSetComp<TextRange>);

impl From<&'static ast::ExprSetComp<TextRange>> for ExprSetComp {
    fn from(node: &'static ast::ExprSetComp<TextRange>) -> Self {
        ExprSetComp(node)
    }
}

impl ToPyObject for ExprSetComp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprSetComp<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprSetComp(self).to_object(py))
    }
}

#[pymethods]
impl ExprSetComp {
    #[getter]
    #[inline]
    fn get_elt(&self, py: Python) -> PyResult<PyObject> {
        self.0.elt.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_generators(&self, py: Python) -> PyResult<PyObject> {
        self.0.generators.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_DictComp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprDictComp(pub &'static ast::ExprDictComp<TextRange>);

impl From<&'static ast::ExprDictComp<TextRange>> for ExprDictComp {
    fn from(node: &'static ast::ExprDictComp<TextRange>) -> Self {
        ExprDictComp(node)
    }
}

impl ToPyObject for ExprDictComp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprDictComp<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprDictComp(self).to_object(py))
    }
}

#[pymethods]
impl ExprDictComp {
    #[getter]
    #[inline]
    fn get_key(&self, py: Python) -> PyResult<PyObject> {
        self.0.key.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_generators(&self, py: Python) -> PyResult<PyObject> {
        self.0.generators.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_GeneratorExp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprGeneratorExp(pub &'static ast::ExprGeneratorExp<TextRange>);

impl From<&'static ast::ExprGeneratorExp<TextRange>> for ExprGeneratorExp {
    fn from(node: &'static ast::ExprGeneratorExp<TextRange>) -> Self {
        ExprGeneratorExp(node)
    }
}

impl ToPyObject for ExprGeneratorExp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprGeneratorExp<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprGeneratorExp(self).to_object(py))
    }
}

#[pymethods]
impl ExprGeneratorExp {
    #[getter]
    #[inline]
    fn get_elt(&self, py: Python) -> PyResult<PyObject> {
        self.0.elt.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_generators(&self, py: Python) -> PyResult<PyObject> {
        self.0.generators.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Await", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprAwait(pub &'static ast::ExprAwait<TextRange>);

impl From<&'static ast::ExprAwait<TextRange>> for ExprAwait {
    fn from(node: &'static ast::ExprAwait<TextRange>) -> Self {
        ExprAwait(node)
    }
}

impl ToPyObject for ExprAwait {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprAwait<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprAwait(self).to_object(py))
    }
}

#[pymethods]
impl ExprAwait {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Yield", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprYield(pub &'static ast::ExprYield<TextRange>);

impl From<&'static ast::ExprYield<TextRange>> for ExprYield {
    fn from(node: &'static ast::ExprYield<TextRange>) -> Self {
        ExprYield(node)
    }
}

impl ToPyObject for ExprYield {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprYield<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprYield(self).to_object(py))
    }
}

#[pymethods]
impl ExprYield {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_YieldFrom", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprYieldFrom(pub &'static ast::ExprYieldFrom<TextRange>);

impl From<&'static ast::ExprYieldFrom<TextRange>> for ExprYieldFrom {
    fn from(node: &'static ast::ExprYieldFrom<TextRange>) -> Self {
        ExprYieldFrom(node)
    }
}

impl ToPyObject for ExprYieldFrom {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprYieldFrom<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprYieldFrom(self).to_object(py))
    }
}

#[pymethods]
impl ExprYieldFrom {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Compare", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprCompare(pub &'static ast::ExprCompare<TextRange>);

impl From<&'static ast::ExprCompare<TextRange>> for ExprCompare {
    fn from(node: &'static ast::ExprCompare<TextRange>) -> Self {
        ExprCompare(node)
    }
}

impl ToPyObject for ExprCompare {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprCompare<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprCompare(self).to_object(py))
    }
}

#[pymethods]
impl ExprCompare {
    #[getter]
    #[inline]
    fn get_left(&self, py: Python) -> PyResult<PyObject> {
        self.0.left.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ops(&self, py: Python) -> PyResult<PyObject> {
        self.0.ops.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_comparators(&self, py: Python) -> PyResult<PyObject> {
        self.0.comparators.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Call", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprCall(pub &'static ast::ExprCall<TextRange>);

impl From<&'static ast::ExprCall<TextRange>> for ExprCall {
    fn from(node: &'static ast::ExprCall<TextRange>) -> Self {
        ExprCall(node)
    }
}

impl ToPyObject for ExprCall {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprCall<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprCall(self).to_object(py))
    }
}

#[pymethods]
impl ExprCall {
    #[getter]
    #[inline]
    fn get_func(&self, py: Python) -> PyResult<PyObject> {
        self.0.func.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_keywords(&self, py: Python) -> PyResult<PyObject> {
        self.0.keywords.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_FormattedValue", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprFormattedValue(pub &'static ast::ExprFormattedValue<TextRange>);

impl From<&'static ast::ExprFormattedValue<TextRange>> for ExprFormattedValue {
    fn from(node: &'static ast::ExprFormattedValue<TextRange>) -> Self {
        ExprFormattedValue(node)
    }
}

impl ToPyObject for ExprFormattedValue {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprFormattedValue<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprFormattedValue(self).to_object(py))
    }
}

#[pymethods]
impl ExprFormattedValue {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_conversion(&self, py: Python) -> PyResult<PyObject> {
        self.0.conversion.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_format_spec(&self, py: Python) -> PyResult<PyObject> {
        self.0.format_spec.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_JoinedStr", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprJoinedStr(pub &'static ast::ExprJoinedStr<TextRange>);

impl From<&'static ast::ExprJoinedStr<TextRange>> for ExprJoinedStr {
    fn from(node: &'static ast::ExprJoinedStr<TextRange>) -> Self {
        ExprJoinedStr(node)
    }
}

impl ToPyObject for ExprJoinedStr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprJoinedStr<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprJoinedStr(self).to_object(py))
    }
}

#[pymethods]
impl ExprJoinedStr {
    #[getter]
    #[inline]
    fn get_values(&self, py: Python) -> PyResult<PyObject> {
        self.0.values.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Constant", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprConstant(pub &'static ast::ExprConstant<TextRange>);

impl From<&'static ast::ExprConstant<TextRange>> for ExprConstant {
    fn from(node: &'static ast::ExprConstant<TextRange>) -> Self {
        ExprConstant(node)
    }
}

impl ToPyObject for ExprConstant {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprConstant<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprConstant(self).to_object(py))
    }
}

#[pymethods]
impl ExprConstant {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kind(&self, py: Python) -> PyResult<PyObject> {
        self.0.kind.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Attribute", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprAttribute(pub &'static ast::ExprAttribute<TextRange>);

impl From<&'static ast::ExprAttribute<TextRange>> for ExprAttribute {
    fn from(node: &'static ast::ExprAttribute<TextRange>) -> Self {
        ExprAttribute(node)
    }
}

impl ToPyObject for ExprAttribute {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprAttribute<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprAttribute(self).to_object(py))
    }
}

#[pymethods]
impl ExprAttribute {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_attr(&self, py: Python) -> PyResult<PyObject> {
        self.0.attr.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Subscript", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprSubscript(pub &'static ast::ExprSubscript<TextRange>);

impl From<&'static ast::ExprSubscript<TextRange>> for ExprSubscript {
    fn from(node: &'static ast::ExprSubscript<TextRange>) -> Self {
        ExprSubscript(node)
    }
}

impl ToPyObject for ExprSubscript {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprSubscript<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprSubscript(self).to_object(py))
    }
}

#[pymethods]
impl ExprSubscript {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_slice(&self, py: Python) -> PyResult<PyObject> {
        self.0.slice.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Starred", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprStarred(pub &'static ast::ExprStarred<TextRange>);

impl From<&'static ast::ExprStarred<TextRange>> for ExprStarred {
    fn from(node: &'static ast::ExprStarred<TextRange>) -> Self {
        ExprStarred(node)
    }
}

impl ToPyObject for ExprStarred {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprStarred<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprStarred(self).to_object(py))
    }
}

#[pymethods]
impl ExprStarred {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Name", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprName(pub &'static ast::ExprName<TextRange>);

impl From<&'static ast::ExprName<TextRange>> for ExprName {
    fn from(node: &'static ast::ExprName<TextRange>) -> Self {
        ExprName(node)
    }
}

impl ToPyObject for ExprName {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprName<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprName(self).to_object(py))
    }
}

#[pymethods]
impl ExprName {
    #[getter]
    #[inline]
    fn get_id(&self, py: Python) -> PyResult<PyObject> {
        self.0.id.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_List", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprList(pub &'static ast::ExprList<TextRange>);

impl From<&'static ast::ExprList<TextRange>> for ExprList {
    fn from(node: &'static ast::ExprList<TextRange>) -> Self {
        ExprList(node)
    }
}

impl ToPyObject for ExprList {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprList<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprList(self).to_object(py))
    }
}

#[pymethods]
impl ExprList {
    #[getter]
    #[inline]
    fn get_elts(&self, py: Python) -> PyResult<PyObject> {
        self.0.elts.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Tuple", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprTuple(pub &'static ast::ExprTuple<TextRange>);

impl From<&'static ast::ExprTuple<TextRange>> for ExprTuple {
    fn from(node: &'static ast::ExprTuple<TextRange>) -> Self {
        ExprTuple(node)
    }
}

impl ToPyObject for ExprTuple {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprTuple<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprTuple(self).to_object(py))
    }
}

#[pymethods]
impl ExprTuple {
    #[getter]
    #[inline]
    fn get_elts(&self, py: Python) -> PyResult<PyObject> {
        self.0.elts.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Slice", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprSlice(pub &'static ast::ExprSlice<TextRange>);

impl From<&'static ast::ExprSlice<TextRange>> for ExprSlice {
    fn from(node: &'static ast::ExprSlice<TextRange>) -> Self {
        ExprSlice(node)
    }
}

impl ToPyObject for ExprSlice {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExprSlice<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprSlice(self).to_object(py))
    }
}

#[pymethods]
impl ExprSlice {
    #[getter]
    #[inline]
    fn get_lower(&self, py: Python) -> PyResult<PyObject> {
        self.0.lower.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_upper(&self, py: Python) -> PyResult<PyObject> {
        self.0.upper.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_step(&self, py: Python) -> PyResult<PyObject> {
        self.0.step.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_expr_context", extends=super::Ast, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct ExprContext;

impl From<&'static ast::ExprContext> for ExprContext {
    fn from(_node: &'static ast::ExprContext) -> Self {
        ExprContext
    }
}

#[pymethods]
impl ExprContext {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(Ast).add_subclass(Self)
    }
}
impl ToPyObject for ExprContext {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Load", extends=ExprContext)]
pub struct ExprContextLoad;

impl ToPyObject for ExprContextLoad {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(ExprContext)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Store", extends=ExprContext)]
pub struct ExprContextStore;

impl ToPyObject for ExprContextStore {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(ExprContext)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Del", extends=ExprContext)]
pub struct ExprContextDel;

impl ToPyObject for ExprContextDel {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(ExprContext)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_boolop", extends=super::Ast, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct BoolOp;

impl From<&'static ast::BoolOp> for BoolOp {
    fn from(_node: &'static ast::BoolOp) -> Self {
        BoolOp
    }
}

#[pymethods]
impl BoolOp {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(Ast).add_subclass(Self)
    }
}
impl ToPyObject for BoolOp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_And", extends=BoolOp)]
pub struct BoolOpAnd;

impl ToPyObject for BoolOpAnd {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(BoolOp)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Or", extends=BoolOp)]
pub struct BoolOpOr;

impl ToPyObject for BoolOpOr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(BoolOp)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_operator", extends=super::Ast, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Operator;

impl From<&'static ast::Operator> for Operator {
    fn from(_node: &'static ast::Operator) -> Self {
        Operator
    }
}

#[pymethods]
impl Operator {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(Ast).add_subclass(Self)
    }
}
impl ToPyObject for Operator {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Add", extends=Operator)]
pub struct OperatorAdd;

impl ToPyObject for OperatorAdd {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Sub", extends=Operator)]
pub struct OperatorSub;

impl ToPyObject for OperatorSub {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Mult", extends=Operator)]
pub struct OperatorMult;

impl ToPyObject for OperatorMult {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatMult", extends=Operator)]
pub struct OperatorMatMult;

impl ToPyObject for OperatorMatMult {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Div", extends=Operator)]
pub struct OperatorDiv;

impl ToPyObject for OperatorDiv {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Mod", extends=Operator)]
pub struct OperatorMod;

impl ToPyObject for OperatorMod {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Pow", extends=Operator)]
pub struct OperatorPow;

impl ToPyObject for OperatorPow {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_LShift", extends=Operator)]
pub struct OperatorLShift;

impl ToPyObject for OperatorLShift {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_RShift", extends=Operator)]
pub struct OperatorRShift;

impl ToPyObject for OperatorRShift {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_BitOr", extends=Operator)]
pub struct OperatorBitOr;

impl ToPyObject for OperatorBitOr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_BitXor", extends=Operator)]
pub struct OperatorBitXor;

impl ToPyObject for OperatorBitXor {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_BitAnd", extends=Operator)]
pub struct OperatorBitAnd;

impl ToPyObject for OperatorBitAnd {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_FloorDiv", extends=Operator)]
pub struct OperatorFloorDiv;

impl ToPyObject for OperatorFloorDiv {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_unaryop", extends=super::Ast, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct UnaryOp;

impl From<&'static ast::UnaryOp> for UnaryOp {
    fn from(_node: &'static ast::UnaryOp) -> Self {
        UnaryOp
    }
}

#[pymethods]
impl UnaryOp {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(Ast).add_subclass(Self)
    }
}
impl ToPyObject for UnaryOp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Invert", extends=UnaryOp)]
pub struct UnaryOpInvert;

impl ToPyObject for UnaryOpInvert {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(UnaryOp)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Not", extends=UnaryOp)]
pub struct UnaryOpNot;

impl ToPyObject for UnaryOpNot {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(UnaryOp)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_UAdd", extends=UnaryOp)]
pub struct UnaryOpUAdd;

impl ToPyObject for UnaryOpUAdd {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(UnaryOp)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_USub", extends=UnaryOp)]
pub struct UnaryOpUSub;

impl ToPyObject for UnaryOpUSub {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(UnaryOp)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_cmpop", extends=super::Ast, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct CmpOp;

impl From<&'static ast::CmpOp> for CmpOp {
    fn from(_node: &'static ast::CmpOp) -> Self {
        CmpOp
    }
}

#[pymethods]
impl CmpOp {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(Ast).add_subclass(Self)
    }
}
impl ToPyObject for CmpOp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Eq", extends=CmpOp)]
pub struct CmpOpEq;

impl ToPyObject for CmpOpEq {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(CmpOp)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_NotEq", extends=CmpOp)]
pub struct CmpOpNotEq;

impl ToPyObject for CmpOpNotEq {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(CmpOp)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Lt", extends=CmpOp)]
pub struct CmpOpLt;

impl ToPyObject for CmpOpLt {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(CmpOp)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_LtE", extends=CmpOp)]
pub struct CmpOpLtE;

impl ToPyObject for CmpOpLtE {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(CmpOp)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Gt", extends=CmpOp)]
pub struct CmpOpGt;

impl ToPyObject for CmpOpGt {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(CmpOp)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_GtE", extends=CmpOp)]
pub struct CmpOpGtE;

impl ToPyObject for CmpOpGtE {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(CmpOp)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Is", extends=CmpOp)]
pub struct CmpOpIs;

impl ToPyObject for CmpOpIs {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(CmpOp)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_IsNot", extends=CmpOp)]
pub struct CmpOpIsNot;

impl ToPyObject for CmpOpIsNot {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(CmpOp)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_In", extends=CmpOp)]
pub struct CmpOpIn;

impl ToPyObject for CmpOpIn {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(CmpOp)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_NotIn", extends=CmpOp)]
pub struct CmpOpNotIn;

impl ToPyObject for CmpOpNotIn {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(CmpOp)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_comprehension", extends=super::Ast, frozen)]
#[derive(Clone, Debug)]
pub struct Comprehension(pub &'static ast::Comprehension<TextRange>);

impl From<&'static ast::Comprehension<TextRange>> for Comprehension {
    fn from(node: &'static ast::Comprehension<TextRange>) -> Self {
        Comprehension(node)
    }
}

impl ToPyObject for Comprehension {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::Comprehension<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Comprehension(self).to_object(py))
    }
}

#[pymethods]
impl Comprehension {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_iter(&self, py: Python) -> PyResult<PyObject> {
        self.0.iter.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ifs(&self, py: Python) -> PyResult<PyObject> {
        self.0.ifs.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_is_async(&self, py: Python) -> PyResult<PyObject> {
        self.0.is_async.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_excepthandler", extends=super::Ast, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct ExceptHandler;

impl From<&'static ast::ExceptHandler<TextRange>> for ExceptHandler {
    fn from(_node: &'static ast::ExceptHandler<TextRange>) -> Self {
        ExceptHandler
    }
}

#[pymethods]
impl ExceptHandler {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(Ast).add_subclass(Self)
    }
}
impl ToPyObject for ExceptHandler {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExceptHandler<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::ExceptHandler(cons) => cons.to_py_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_ExceptHandler", extends=ExceptHandler, frozen)]
#[derive(Clone, Debug)]
pub struct ExceptHandlerExceptHandler(pub &'static ast::ExceptHandlerExceptHandler<TextRange>);

impl From<&'static ast::ExceptHandlerExceptHandler<TextRange>> for ExceptHandlerExceptHandler {
    fn from(node: &'static ast::ExceptHandlerExceptHandler<TextRange>) -> Self {
        ExceptHandlerExceptHandler(node)
    }
}

impl ToPyObject for ExceptHandlerExceptHandler {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(ExceptHandler)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::ExceptHandlerExceptHandler<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExceptHandlerExceptHandler(self).to_object(py))
    }
}

#[pymethods]
impl ExceptHandlerExceptHandler {
    #[getter]
    #[inline]
    fn get_type(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_arguments", extends=super::Ast, frozen)]
#[derive(Clone, Debug)]
pub struct Arguments(pub &'static ast::PythonArguments<TextRange>);

impl From<&'static ast::PythonArguments<TextRange>> for Arguments {
    fn from(node: &'static ast::PythonArguments<TextRange>) -> Self {
        Arguments(node)
    }
}

impl ToPyObject for Arguments {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::PythonArguments<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Arguments(self).to_object(py))
    }
}

#[pymethods]
impl Arguments {
    #[getter]
    #[inline]
    fn get_posonlyargs(&self, py: Python) -> PyResult<PyObject> {
        self.0.posonlyargs.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_vararg(&self, py: Python) -> PyResult<PyObject> {
        self.0.vararg.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kwonlyargs(&self, py: Python) -> PyResult<PyObject> {
        self.0.kwonlyargs.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kw_defaults(&self, py: Python) -> PyResult<PyObject> {
        self.0.kw_defaults.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kwarg(&self, py: Python) -> PyResult<PyObject> {
        self.0.kwarg.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_defaults(&self, py: Python) -> PyResult<PyObject> {
        self.0.defaults.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_arg", extends=super::Ast, frozen)]
#[derive(Clone, Debug)]
pub struct Arg(pub &'static ast::Arg<TextRange>);

impl From<&'static ast::Arg<TextRange>> for Arg {
    fn from(node: &'static ast::Arg<TextRange>) -> Self {
        Arg(node)
    }
}

impl ToPyObject for Arg {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::Arg<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Arg(self).to_object(py))
    }
}

#[pymethods]
impl Arg {
    #[getter]
    #[inline]
    fn get_arg(&self, py: Python) -> PyResult<PyObject> {
        self.0.arg.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_annotation(&self, py: Python) -> PyResult<PyObject> {
        self.0.annotation.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_keyword", extends=super::Ast, frozen)]
#[derive(Clone, Debug)]
pub struct Keyword(pub &'static ast::Keyword<TextRange>);

impl From<&'static ast::Keyword<TextRange>> for Keyword {
    fn from(node: &'static ast::Keyword<TextRange>) -> Self {
        Keyword(node)
    }
}

impl ToPyObject for Keyword {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::Keyword<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Keyword(self).to_object(py))
    }
}

#[pymethods]
impl Keyword {
    #[getter]
    #[inline]
    fn get_arg(&self, py: Python) -> PyResult<PyObject> {
        self.0.arg.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_alias", extends=super::Ast, frozen)]
#[derive(Clone, Debug)]
pub struct Alias(pub &'static ast::Alias<TextRange>);

impl From<&'static ast::Alias<TextRange>> for Alias {
    fn from(node: &'static ast::Alias<TextRange>) -> Self {
        Alias(node)
    }
}

impl ToPyObject for Alias {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::Alias<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Alias(self).to_object(py))
    }
}

#[pymethods]
impl Alias {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_asname(&self, py: Python) -> PyResult<PyObject> {
        self.0.asname.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_withitem", extends=super::Ast, frozen)]
#[derive(Clone, Debug)]
pub struct WithItem(pub &'static ast::WithItem<TextRange>);

impl From<&'static ast::WithItem<TextRange>> for WithItem {
    fn from(node: &'static ast::WithItem<TextRange>) -> Self {
        WithItem(node)
    }
}

impl ToPyObject for WithItem {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::WithItem<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(WithItem(self).to_object(py))
    }
}

#[pymethods]
impl WithItem {
    #[getter]
    #[inline]
    fn get_context_expr(&self, py: Python) -> PyResult<PyObject> {
        self.0.context_expr.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_optional_vars(&self, py: Python) -> PyResult<PyObject> {
        self.0.optional_vars.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_match_case", extends=super::Ast, frozen)]
#[derive(Clone, Debug)]
pub struct MatchCase(pub &'static ast::MatchCase<TextRange>);

impl From<&'static ast::MatchCase<TextRange>> for MatchCase {
    fn from(node: &'static ast::MatchCase<TextRange>) -> Self {
        MatchCase(node)
    }
}

impl ToPyObject for MatchCase {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::MatchCase<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(MatchCase(self).to_object(py))
    }
}

#[pymethods]
impl MatchCase {
    #[getter]
    #[inline]
    fn get_pattern(&self, py: Python) -> PyResult<PyObject> {
        self.0.pattern.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_guard(&self, py: Python) -> PyResult<PyObject> {
        self.0.guard.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_pattern", extends=super::Ast, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Pattern;

impl From<&'static ast::Pattern<TextRange>> for Pattern {
    fn from(_node: &'static ast::Pattern<TextRange>) -> Self {
        Pattern
    }
}

#[pymethods]
impl Pattern {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(Ast).add_subclass(Self)
    }
}
impl ToPyObject for Pattern {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::Pattern<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::MatchValue(cons) => cons.to_py_wrapper(py),
            Self::MatchSingleton(cons) => cons.to_py_wrapper(py),
            Self::MatchSequence(cons) => cons.to_py_wrapper(py),
            Self::MatchMapping(cons) => cons.to_py_wrapper(py),
            Self::MatchClass(cons) => cons.to_py_wrapper(py),
            Self::MatchStar(cons) => cons.to_py_wrapper(py),
            Self::MatchAs(cons) => cons.to_py_wrapper(py),
            Self::MatchOr(cons) => cons.to_py_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchValue", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchValue(pub &'static ast::PatternMatchValue<TextRange>);

impl From<&'static ast::PatternMatchValue<TextRange>> for PatternMatchValue {
    fn from(node: &'static ast::PatternMatchValue<TextRange>) -> Self {
        PatternMatchValue(node)
    }
}

impl ToPyObject for PatternMatchValue {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::PatternMatchValue<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchValue(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchValue {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchSingleton", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchSingleton(pub &'static ast::PatternMatchSingleton<TextRange>);

impl From<&'static ast::PatternMatchSingleton<TextRange>> for PatternMatchSingleton {
    fn from(node: &'static ast::PatternMatchSingleton<TextRange>) -> Self {
        PatternMatchSingleton(node)
    }
}

impl ToPyObject for PatternMatchSingleton {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::PatternMatchSingleton<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchSingleton(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchSingleton {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchSequence", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchSequence(pub &'static ast::PatternMatchSequence<TextRange>);

impl From<&'static ast::PatternMatchSequence<TextRange>> for PatternMatchSequence {
    fn from(node: &'static ast::PatternMatchSequence<TextRange>) -> Self {
        PatternMatchSequence(node)
    }
}

impl ToPyObject for PatternMatchSequence {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::PatternMatchSequence<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchSequence(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchSequence {
    #[getter]
    #[inline]
    fn get_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.patterns.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchMapping", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchMapping(pub &'static ast::PatternMatchMapping<TextRange>);

impl From<&'static ast::PatternMatchMapping<TextRange>> for PatternMatchMapping {
    fn from(node: &'static ast::PatternMatchMapping<TextRange>) -> Self {
        PatternMatchMapping(node)
    }
}

impl ToPyObject for PatternMatchMapping {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::PatternMatchMapping<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchMapping(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchMapping {
    #[getter]
    #[inline]
    fn get_keys(&self, py: Python) -> PyResult<PyObject> {
        self.0.keys.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.patterns.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_rest(&self, py: Python) -> PyResult<PyObject> {
        self.0.rest.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchClass", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchClass(pub &'static ast::PatternMatchClass<TextRange>);

impl From<&'static ast::PatternMatchClass<TextRange>> for PatternMatchClass {
    fn from(node: &'static ast::PatternMatchClass<TextRange>) -> Self {
        PatternMatchClass(node)
    }
}

impl ToPyObject for PatternMatchClass {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::PatternMatchClass<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchClass(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchClass {
    #[getter]
    #[inline]
    fn get_cls(&self, py: Python) -> PyResult<PyObject> {
        self.0.cls.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.patterns.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kwd_attrs(&self, py: Python) -> PyResult<PyObject> {
        self.0.kwd_attrs.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kwd_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.kwd_patterns.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchStar", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchStar(pub &'static ast::PatternMatchStar<TextRange>);

impl From<&'static ast::PatternMatchStar<TextRange>> for PatternMatchStar {
    fn from(node: &'static ast::PatternMatchStar<TextRange>) -> Self {
        PatternMatchStar(node)
    }
}

impl ToPyObject for PatternMatchStar {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::PatternMatchStar<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchStar(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchStar {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchAs", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchAs(pub &'static ast::PatternMatchAs<TextRange>);

impl From<&'static ast::PatternMatchAs<TextRange>> for PatternMatchAs {
    fn from(node: &'static ast::PatternMatchAs<TextRange>) -> Self {
        PatternMatchAs(node)
    }
}

impl ToPyObject for PatternMatchAs {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::PatternMatchAs<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchAs(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchAs {
    #[getter]
    #[inline]
    fn get_pattern(&self, py: Python) -> PyResult<PyObject> {
        self.0.pattern.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchOr", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchOr(pub &'static ast::PatternMatchOr<TextRange>);

impl From<&'static ast::PatternMatchOr<TextRange>> for PatternMatchOr {
    fn from(node: &'static ast::PatternMatchOr<TextRange>) -> Self {
        PatternMatchOr(node)
    }
}

impl ToPyObject for PatternMatchOr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::PatternMatchOr<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchOr(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchOr {
    #[getter]
    #[inline]
    fn get_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.patterns.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_type_ignore", extends=super::Ast, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct TypeIgnore;

impl From<&'static ast::TypeIgnore<TextRange>> for TypeIgnore {
    fn from(_node: &'static ast::TypeIgnore<TextRange>) -> Self {
        TypeIgnore
    }
}

#[pymethods]
impl TypeIgnore {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(Ast).add_subclass(Self)
    }
}
impl ToPyObject for TypeIgnore {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::TypeIgnore<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::TypeIgnore(cons) => cons.to_py_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_TypeIgnore", extends=TypeIgnore, frozen)]
#[derive(Clone, Debug)]
pub struct TypeIgnoreTypeIgnore(pub &'static ast::TypeIgnoreTypeIgnore<TextRange>);

impl From<&'static ast::TypeIgnoreTypeIgnore<TextRange>> for TypeIgnoreTypeIgnore {
    fn from(node: &'static ast::TypeIgnoreTypeIgnore<TextRange>) -> Self {
        TypeIgnoreTypeIgnore(node)
    }
}

impl ToPyObject for TypeIgnoreTypeIgnore {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast)
            .add_subclass(TypeIgnore)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::TypeIgnoreTypeIgnore<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(TypeIgnoreTypeIgnore(self).to_object(py))
    }
}

#[pymethods]
impl TypeIgnoreTypeIgnore {
    #[getter]
    #[inline]
    fn get_lineno(&self, py: Python) -> PyResult<PyObject> {
        self.0.lineno.to_py_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_tag(&self, py: Python) -> PyResult<PyObject> {
        self.0.tag.to_py_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_decorator", extends=super::Ast, frozen)]
#[derive(Clone, Debug)]
pub struct Decorator(pub &'static ast::Decorator<TextRange>);

impl From<&'static ast::Decorator<TextRange>> for Decorator {
    fn from(node: &'static ast::Decorator<TextRange>) -> Self {
        Decorator(node)
    }
}

impl ToPyObject for Decorator {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(Ast).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyWrapper for ast::Decorator<TextRange> {
    #[inline]
    fn to_py_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Decorator(self).to_object(py))
    }
}

#[pymethods]
impl Decorator {
    #[getter]
    #[inline]
    fn get_expression(&self, py: Python) -> PyResult<PyObject> {
        self.0.expression.to_py_wrapper(py)
    }
}

pub fn add_to_module(py: Python, m: &PyModule) -> PyResult<()> {
    super::init_module(py, m)?;
    super::init_type::<Mod, ast::Mod>(py, m)?;
    super::init_type::<ModModule, ast::ModModule>(py, m)?;
    super::init_type::<ModInteractive, ast::ModInteractive>(py, m)?;
    super::init_type::<ModExpression, ast::ModExpression>(py, m)?;
    super::init_type::<ModFunctionType, ast::ModFunctionType>(py, m)?;
    super::init_type::<Stmt, ast::Stmt>(py, m)?;
    super::init_type::<StmtFunctionDef, ast::StmtFunctionDef>(py, m)?;
    super::init_type::<StmtAsyncFunctionDef, ast::StmtAsyncFunctionDef>(py, m)?;
    super::init_type::<StmtClassDef, ast::StmtClassDef>(py, m)?;
    super::init_type::<StmtReturn, ast::StmtReturn>(py, m)?;
    super::init_type::<StmtDelete, ast::StmtDelete>(py, m)?;
    super::init_type::<StmtAssign, ast::StmtAssign>(py, m)?;
    super::init_type::<StmtAugAssign, ast::StmtAugAssign>(py, m)?;
    super::init_type::<StmtAnnAssign, ast::StmtAnnAssign>(py, m)?;
    super::init_type::<StmtFor, ast::StmtFor>(py, m)?;
    super::init_type::<StmtAsyncFor, ast::StmtAsyncFor>(py, m)?;
    super::init_type::<StmtWhile, ast::StmtWhile>(py, m)?;
    super::init_type::<StmtIf, ast::StmtIf>(py, m)?;
    super::init_type::<StmtWith, ast::StmtWith>(py, m)?;
    super::init_type::<StmtAsyncWith, ast::StmtAsyncWith>(py, m)?;
    super::init_type::<StmtMatch, ast::StmtMatch>(py, m)?;
    super::init_type::<StmtRaise, ast::StmtRaise>(py, m)?;
    super::init_type::<StmtTry, ast::StmtTry>(py, m)?;
    super::init_type::<StmtTryStar, ast::StmtTryStar>(py, m)?;
    super::init_type::<StmtAssert, ast::StmtAssert>(py, m)?;
    super::init_type::<StmtImport, ast::StmtImport>(py, m)?;
    super::init_type::<StmtImportFrom, ast::StmtImportFrom>(py, m)?;
    super::init_type::<StmtGlobal, ast::StmtGlobal>(py, m)?;
    super::init_type::<StmtNonlocal, ast::StmtNonlocal>(py, m)?;
    super::init_type::<StmtExpr, ast::StmtExpr>(py, m)?;
    super::init_type::<StmtPass, ast::StmtPass>(py, m)?;
    super::init_type::<StmtBreak, ast::StmtBreak>(py, m)?;
    super::init_type::<StmtContinue, ast::StmtContinue>(py, m)?;
    super::init_type::<Expr, ast::Expr>(py, m)?;
    super::init_type::<ExprBoolOp, ast::ExprBoolOp>(py, m)?;
    super::init_type::<ExprNamedExpr, ast::ExprNamedExpr>(py, m)?;
    super::init_type::<ExprBinOp, ast::ExprBinOp>(py, m)?;
    super::init_type::<ExprUnaryOp, ast::ExprUnaryOp>(py, m)?;
    super::init_type::<ExprLambda, ast::ExprLambda>(py, m)?;
    super::init_type::<ExprIfExp, ast::ExprIfExp>(py, m)?;
    super::init_type::<ExprDict, ast::ExprDict>(py, m)?;
    super::init_type::<ExprSet, ast::ExprSet>(py, m)?;
    super::init_type::<ExprListComp, ast::ExprListComp>(py, m)?;
    super::init_type::<ExprSetComp, ast::ExprSetComp>(py, m)?;
    super::init_type::<ExprDictComp, ast::ExprDictComp>(py, m)?;
    super::init_type::<ExprGeneratorExp, ast::ExprGeneratorExp>(py, m)?;
    super::init_type::<ExprAwait, ast::ExprAwait>(py, m)?;
    super::init_type::<ExprYield, ast::ExprYield>(py, m)?;
    super::init_type::<ExprYieldFrom, ast::ExprYieldFrom>(py, m)?;
    super::init_type::<ExprCompare, ast::ExprCompare>(py, m)?;
    super::init_type::<ExprCall, ast::ExprCall>(py, m)?;
    super::init_type::<ExprFormattedValue, ast::ExprFormattedValue>(py, m)?;
    super::init_type::<ExprJoinedStr, ast::ExprJoinedStr>(py, m)?;
    super::init_type::<ExprConstant, ast::ExprConstant>(py, m)?;
    super::init_type::<ExprAttribute, ast::ExprAttribute>(py, m)?;
    super::init_type::<ExprSubscript, ast::ExprSubscript>(py, m)?;
    super::init_type::<ExprStarred, ast::ExprStarred>(py, m)?;
    super::init_type::<ExprName, ast::ExprName>(py, m)?;
    super::init_type::<ExprList, ast::ExprList>(py, m)?;
    super::init_type::<ExprTuple, ast::ExprTuple>(py, m)?;
    super::init_type::<ExprSlice, ast::ExprSlice>(py, m)?;
    super::init_type::<ExprContext, ast::ExprContext>(py, m)?;
    super::init_type::<ExprContextLoad, ast::ExprContextLoad>(py, m)?;
    super::init_type::<ExprContextStore, ast::ExprContextStore>(py, m)?;
    super::init_type::<ExprContextDel, ast::ExprContextDel>(py, m)?;
    super::init_type::<BoolOp, ast::BoolOp>(py, m)?;
    super::init_type::<BoolOpAnd, ast::BoolOpAnd>(py, m)?;
    super::init_type::<BoolOpOr, ast::BoolOpOr>(py, m)?;
    super::init_type::<Operator, ast::Operator>(py, m)?;
    super::init_type::<OperatorAdd, ast::OperatorAdd>(py, m)?;
    super::init_type::<OperatorSub, ast::OperatorSub>(py, m)?;
    super::init_type::<OperatorMult, ast::OperatorMult>(py, m)?;
    super::init_type::<OperatorMatMult, ast::OperatorMatMult>(py, m)?;
    super::init_type::<OperatorDiv, ast::OperatorDiv>(py, m)?;
    super::init_type::<OperatorMod, ast::OperatorMod>(py, m)?;
    super::init_type::<OperatorPow, ast::OperatorPow>(py, m)?;
    super::init_type::<OperatorLShift, ast::OperatorLShift>(py, m)?;
    super::init_type::<OperatorRShift, ast::OperatorRShift>(py, m)?;
    super::init_type::<OperatorBitOr, ast::OperatorBitOr>(py, m)?;
    super::init_type::<OperatorBitXor, ast::OperatorBitXor>(py, m)?;
    super::init_type::<OperatorBitAnd, ast::OperatorBitAnd>(py, m)?;
    super::init_type::<OperatorFloorDiv, ast::OperatorFloorDiv>(py, m)?;
    super::init_type::<UnaryOp, ast::UnaryOp>(py, m)?;
    super::init_type::<UnaryOpInvert, ast::UnaryOpInvert>(py, m)?;
    super::init_type::<UnaryOpNot, ast::UnaryOpNot>(py, m)?;
    super::init_type::<UnaryOpUAdd, ast::UnaryOpUAdd>(py, m)?;
    super::init_type::<UnaryOpUSub, ast::UnaryOpUSub>(py, m)?;
    super::init_type::<CmpOp, ast::CmpOp>(py, m)?;
    super::init_type::<CmpOpEq, ast::CmpOpEq>(py, m)?;
    super::init_type::<CmpOpNotEq, ast::CmpOpNotEq>(py, m)?;
    super::init_type::<CmpOpLt, ast::CmpOpLt>(py, m)?;
    super::init_type::<CmpOpLtE, ast::CmpOpLtE>(py, m)?;
    super::init_type::<CmpOpGt, ast::CmpOpGt>(py, m)?;
    super::init_type::<CmpOpGtE, ast::CmpOpGtE>(py, m)?;
    super::init_type::<CmpOpIs, ast::CmpOpIs>(py, m)?;
    super::init_type::<CmpOpIsNot, ast::CmpOpIsNot>(py, m)?;
    super::init_type::<CmpOpIn, ast::CmpOpIn>(py, m)?;
    super::init_type::<CmpOpNotIn, ast::CmpOpNotIn>(py, m)?;
    super::init_type::<Comprehension, ast::Comprehension>(py, m)?;
    super::init_type::<ExceptHandler, ast::ExceptHandler>(py, m)?;
    super::init_type::<ExceptHandlerExceptHandler, ast::ExceptHandlerExceptHandler>(py, m)?;
    super::init_type::<Arguments, ast::PythonArguments>(py, m)?;
    super::init_type::<Arg, ast::Arg>(py, m)?;
    super::init_type::<Keyword, ast::Keyword>(py, m)?;
    super::init_type::<Alias, ast::Alias>(py, m)?;
    super::init_type::<WithItem, ast::WithItem>(py, m)?;
    super::init_type::<MatchCase, ast::MatchCase>(py, m)?;
    super::init_type::<Pattern, ast::Pattern>(py, m)?;
    super::init_type::<PatternMatchValue, ast::PatternMatchValue>(py, m)?;
    super::init_type::<PatternMatchSingleton, ast::PatternMatchSingleton>(py, m)?;
    super::init_type::<PatternMatchSequence, ast::PatternMatchSequence>(py, m)?;
    super::init_type::<PatternMatchMapping, ast::PatternMatchMapping>(py, m)?;
    super::init_type::<PatternMatchClass, ast::PatternMatchClass>(py, m)?;
    super::init_type::<PatternMatchStar, ast::PatternMatchStar>(py, m)?;
    super::init_type::<PatternMatchAs, ast::PatternMatchAs>(py, m)?;
    super::init_type::<PatternMatchOr, ast::PatternMatchOr>(py, m)?;
    super::init_type::<TypeIgnore, ast::TypeIgnore>(py, m)?;
    super::init_type::<TypeIgnoreTypeIgnore, ast::TypeIgnoreTypeIgnore>(py, m)?;
    super::init_type::<Decorator, ast::Decorator>(py, m)?;
    Ok(())
}
