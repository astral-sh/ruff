# PEP 695 Generics

[PEP 695] and Python 3.12 introduced new, more ergonomic syntax for type variables.

## Type variables

### Defining PEP 695 type variables

PEP 695 introduces a new syntax for defining type variables. The resulting type variables are
instances of `typing.TypeVar`, just like legacy type variables.

```py
def f[T]():
    reveal_type(type(T))  # revealed: Literal[TypeVar]
    reveal_type(T)  # revealed: T
    reveal_type(T.__name__)  # revealed: Literal["T"]
```

### Cannot have only one constraint

> `TypeVar` supports constraining parametric types to a fixed set of possible types...There should
> be at least two constraints, if any; specifying a single constraint is disallowed.

```py
# error: [invalid-type-variable-constraints] "TypeVar must have at least two constrained types"
def f[T: (int,)]():
    pass
```

## Invalid uses

Note that many of the invalid uses of legacy typevars do not apply to PEP 695 typevars, since the
PEP 695 syntax is only allowed places where typevars are allowed.

## Displaying typevars

We use a suffix when displaying the typevars of a generic function or class. This helps distinguish
different uses of the same typevar.

```py
def f[T](x: T, y: T) -> None:
    # TODO: revealed: T@f
    reveal_type(x)  # revealed: T

class C[T]:
    def m(self, x: T) -> None:
        # TODO: revealed: T@c
        reveal_type(x)  # revealed: T
```

## Subtyping and assignability

An unbounded, unconstrained typevar is assignable to itself, but is not a subtype of itself (or any
other type), since it might be specialized to `Any`, which does not participate in the subtyping
relationship.

It is neither assignable to or a subtype of any other type (including other typevars), since we can
make no assumption about what type it will be specialized to.

```py
from knot_extensions import is_assignable_to, is_subtype_of, static_assert

def unbounded_unconstrained[T, U](t: list[T], u: list[U]) -> None:
    static_assert(is_assignable_to(T, T))
    static_assert(is_assignable_to(U, U))
    static_assert(not is_assignable_to(T, U))
    static_assert(not is_assignable_to(U, T))

    static_assert(not is_subtype_of(T, T))
    static_assert(not is_subtype_of(U, U))
    static_assert(not is_subtype_of(T, U))
    static_assert(not is_subtype_of(U, T))
```

A bounded typevar is assignable to its bound, but the bound is not assignable to the typevar, since
the typevar might be specialized to a smaller type. (This is true even if the bound is a final
class, since the typevar can still be specialized to `Never`.)

```py
from typing_extensions import final

def bounded[T: int](t: list[T]) -> None:
    static_assert(is_assignable_to(T, int))
    static_assert(not is_assignable_to(int, T))

    static_assert(not is_subtype_of(T, int))
    static_assert(not is_subtype_of(int, T))

@final
class FinalClass: ...

def bounded_final[T: FinalClass](t: list[T]) -> None:
    static_assert(is_assignable_to(T, FinalClass))
    static_assert(not is_assignable_to(FinalClass, T))

    static_assert(not is_subtype_of(T, FinalClass))
    static_assert(not is_subtype_of(FinalClass, T))
```

Two distinct typevars are not assignable to each other, even if they have the same bounds, since
there is (still) no guarantee that they will be specialized to the same type. This is true even if
both typevars are bounded by the same final class, since you can specialize the typevars to `Never`
in addition to that final class.

```py
def two_bounded[T: int, U: int](t: list[T], u: list[U]) -> None:
    static_assert(not is_assignable_to(T, U))
    static_assert(not is_assignable_to(U, T))

    static_assert(not is_subtype_of(T, U))
    static_assert(not is_subtype_of(U, T))

def two_final_bounded[T: FinalClass, U: FinalClass](t: list[T], u: list[U]) -> None:
    static_assert(not is_assignable_to(T, U))
    static_assert(not is_assignable_to(U, T))

    static_assert(not is_subtype_of(T, U))
    static_assert(not is_subtype_of(U, T))
```

A constrained typevar is assignable to the union of its constraints, but not to any of the
constraints individually. None of the constraints are assignable to the typevar.

```py
def constrained[T: (int, str)](t: list[T]) -> None:
    static_assert(not is_assignable_to(T, int))
    static_assert(not is_assignable_to(T, str))
    static_assert(is_assignable_to(T, int | str))
    static_assert(not is_assignable_to(int, T))
    static_assert(not is_assignable_to(str, T))
    static_assert(not is_assignable_to(int | str, T))

    static_assert(not is_subtype_of(T, int))
    static_assert(not is_subtype_of(T, str))
    static_assert(not is_subtype_of(T, int | str))
    static_assert(not is_subtype_of(int, T))
    static_assert(not is_subtype_of(str, T))
    static_assert(not is_subtype_of(int | str, T))
```

Two distinct typevars are not assignable to each other, even if they have the same constraints, and
even if any of the constraints are final. There must always be at least two distinct constraints,
meaning that there is (still) no guarantee that they will be specialized to the same type.

```py
def two_constrained[T: (int, str), U: (int, str)](t: list[T], u: list[U]) -> None:
    static_assert(not is_assignable_to(T, U))
    static_assert(not is_assignable_to(U, T))

    static_assert(not is_subtype_of(T, U))
    static_assert(not is_subtype_of(U, T))

@final
class AnotherFinalClass: ...

def two_final_constrained[T: (FinalClass, AnotherFinalClass), U: (FinalClass, AnotherFinalClass)](t: list[T], u: list[U]) -> None:
    static_assert(not is_assignable_to(T, U))
    static_assert(not is_assignable_to(U, T))

    static_assert(not is_subtype_of(T, U))
    static_assert(not is_subtype_of(U, T))
```

## Singletons and single-valued types

(Note: for simplicity, all of the prose in this section refers to _singleton_ types, but all of the
claims apply to _single-valued_ types as well.)

An unbounded, unconstrained typevar is not a singleton, because it can be specialized to a
non-singleton type.

```py
from knot_extensions import is_singleton, is_single_valued, static_assert

def unbounded_unconstrained[T](t: list[T]) -> None:
    static_assert(not is_singleton(T))
    static_assert(not is_single_valued(T))
```

A bounded typevar is not a singleton, since it can still be specialized to `Never`.

```py
def bounded[T: int](t: list[T]) -> None:
    static_assert(not is_singleton(T))
    static_assert(not is_single_valued(T))
```

A constrained typevar is a singleton if all of its constraints are singletons. (Note that you cannot
specialize a constrained typevar to a subtype of a constraint.)

```py
from typing_extensions import Literal

def constrained_non_singletons[T: (int, str)](t: list[T]) -> None:
    static_assert(not is_singleton(T))
    static_assert(not is_single_valued(T))

def constrained_singletons[T: (Literal[True], Literal[False])](t: list[T]) -> None:
    static_assert(is_singleton(T))

def constrained_single_valued[T: (Literal[True], tuple[()])](t: list[T]) -> None:
    static_assert(is_single_valued(T))
```

[pep 695]: https://peps.python.org/pep-0695/
