# This file is auto-generated by crates/ruff_python_ast/generate.py
from __future__ import annotations

from typing import Optional, Sequence

from . import Node

__all__ = ['Module', 'Expression', 'FunctionDefStmt', 'ClassDefStmt', 'ReturnStmt', 'DeleteStmt', 'TypeAliasStmt', 'AssignStmt', 'AugAssignStmt', 'AnnAssignStmt', 'ForStmt', 'WhileStmt', 'IfStmt', 'WithStmt', 'MatchStmt', 'RaiseStmt', 'TryStmt', 'AssertStmt', 'ImportStmt', 'ImportFromStmt', 'GlobalStmt', 'NonlocalStmt', 'ExprStmt', 'PassStmt', 'BreakStmt', 'ContinueStmt', 'IpyEscapeCommandStmt', 'BoolOpExpr', 'NamedExpr', 'BinOpExpr', 'UnaryOpExpr', 'LambdaExpr', 'IfExpr', 'DictExpr', 'SetExpr', 'ListCompExpr', 'SetCompExpr', 'DictCompExpr', 'GeneratorExpr', 'AwaitExpr', 'YieldExpr', 'YieldFromExpr', 'CompareExpr', 'CallExpr', 'FStringExpr', 'TStringExpr', 'StringLiteralExpr', 'BytesLiteralExpr', 'NumberLiteralExpr', 'BooleanLiteralExpr', 'NoneLiteralExpr', 'EllipsisLiteralExpr', 'AttributeExpr', 'SubscriptExpr', 'StarredExpr', 'NameExpr', 'ListExpr', 'TupleExpr', 'SliceExpr', 'IpyEscapeCommandExpr', 'ExceptHandler', 'InterpolatedElement', 'InterpolatedStringLiteralElement', 'MatchValuePattern', 'MatchSingletonPattern', 'MatchSequencePattern', 'MatchMappingPattern', 'MatchClassPattern', 'MatchStarPattern', 'MatchAsPattern', 'MatchOrPattern', 'TypeVar', 'TypeVarTuple', 'ParamSpec', 'InterpolatedStringFormatSpec', 'PatternArguments', 'PatternKeyword', 'Comprehension', 'Parameters', 'Parameter', 'ParameterWithDefault', 'Alias', 'WithItem', 'MatchCase', 'Decorator', 'ElifElseClause', 'TypeParams', 'FString', 'TString', 'StringLiteral', 'BytesLiteral', 'Identifier', 'Arguments', 'Keyword']

class Module(Node):
    body: Sequence[Node]

class Expression(Node):
    body: Node

class FunctionDefStmt(Node):
    is_async: bool
    decorator_list: Sequence[Decorator]
    name: str
    type_params: Optional[TypeParams]
    parameters: Parameters
    returns: Optional[Node]
    body: Sequence[Node]

class ClassDefStmt(Node):
    decorator_list: Sequence[Decorator]
    name: str
    type_params: Optional[TypeParams]
    arguments: Optional[Arguments]
    body: Sequence[Node]

class ReturnStmt(Node):
    value: Optional[Node]

class DeleteStmt(Node):
    targets: Sequence[Node]

class TypeAliasStmt(Node):
    name: Node
    type_params: Optional[TypeParams]
    value: Node

class AssignStmt(Node):
    targets: Sequence[Node]
    value: Node

class AugAssignStmt(Node):
    target: Node
    op: str
    value: Node

class AnnAssignStmt(Node):
    target: Node
    annotation: Node
    value: Optional[Node]
    simple: bool

class ForStmt(Node):
    is_async: bool
    target: Node
    iter: Node
    body: Sequence[Node]
    orelse: Sequence[Node]

class WhileStmt(Node):
    test: Node
    body: Sequence[Node]
    orelse: Sequence[Node]

class IfStmt(Node):
    test: Node
    body: Sequence[Node]
    elif_else_clauses: Sequence[ElifElseClause]

class WithStmt(Node):
    is_async: bool
    items: Sequence[WithItem]
    body: Sequence[Node]

class MatchStmt(Node):
    subject: Node
    cases: Sequence[MatchCase]

class RaiseStmt(Node):
    exc: Optional[Node]
    cause: Optional[Node]

class TryStmt(Node):
    body: Sequence[Node]
    handlers: Sequence[Node]
    orelse: Sequence[Node]
    finalbody: Sequence[Node]
    is_star: bool

class AssertStmt(Node):
    test: Node
    msg: Optional[Node]

class ImportStmt(Node):
    names: Sequence[Alias]

class ImportFromStmt(Node):
    module: Optional[str]
    names: Sequence[Alias]
    level: int

class GlobalStmt(Node):
    names: Sequence[str]

class NonlocalStmt(Node):
    names: Sequence[str]

class ExprStmt(Node):
    value: Node

class PassStmt(Node):
    pass

class BreakStmt(Node):
    pass

class ContinueStmt(Node):
    pass

class IpyEscapeCommandStmt(Node):
    kind: str
    value: str

class BoolOpExpr(Node):
    op: str
    values: Sequence[Node]

class NamedExpr(Node):
    target: Node
    value: Node

class BinOpExpr(Node):
    left: Node
    op: str
    right: Node

class UnaryOpExpr(Node):
    op: str
    operand: Node

class LambdaExpr(Node):
    parameters: Optional[Parameters]
    body: Node

class IfExpr(Node):
    test: Node
    body: Node
    orelse: Node

class DictExpr(Node):
    items: Sequence[Node]

class SetExpr(Node):
    elts: Sequence[Node]

class ListCompExpr(Node):
    elt: Node
    generators: Sequence[Comprehension]

class SetCompExpr(Node):
    elt: Node
    generators: Sequence[Comprehension]

class DictCompExpr(Node):
    key: Node
    value: Node
    generators: Sequence[Comprehension]

class GeneratorExpr(Node):
    elt: Node
    generators: Sequence[Comprehension]
    parenthesized: bool

class AwaitExpr(Node):
    value: Node

class YieldExpr(Node):
    value: Optional[Node]

class YieldFromExpr(Node):
    value: Node

class CompareExpr(Node):
    left: Node
    ops: Sequence[str]
    comparators: Sequence[Node]

class CallExpr(Node):
    func: Node
    arguments: Arguments
    callee: Optional[str]
    function_text: Optional[str]
    function_kind: Optional[str]

class FStringExpr(Node):
    value: str

class TStringExpr(Node):
    value: str

class StringLiteralExpr(Node):
    value: str

class BytesLiteralExpr(Node):
    value: str

class NumberLiteralExpr(Node):
    value: float

class BooleanLiteralExpr(Node):
    value: bool

class NoneLiteralExpr(Node):
    pass

class EllipsisLiteralExpr(Node):
    pass

class AttributeExpr(Node):
    value: Node
    attr: str
    ctx: str

class SubscriptExpr(Node):
    value: Node
    slice: Node
    ctx: str

class StarredExpr(Node):
    value: Node
    ctx: str

class NameExpr(Node):
    id: str
    ctx: str

class ListExpr(Node):
    elts: Sequence[Node]
    ctx: str

class TupleExpr(Node):
    elts: Sequence[Node]
    ctx: str
    parenthesized: bool

class SliceExpr(Node):
    lower: Optional[Node]
    upper: Optional[Node]
    step: Optional[Node]

class IpyEscapeCommandExpr(Node):
    kind: str
    value: str

class ExceptHandler(Node):
    pass

class InterpolatedElement(Node):
    pass

class InterpolatedStringLiteralElement(Node):
    pass

class MatchValuePattern(Node):
    value: Node

class MatchSingletonPattern(Node):
    value: str

class MatchSequencePattern(Node):
    patterns: Sequence[Node]

class MatchMappingPattern(Node):
    keys: Sequence[Node]
    patterns: Sequence[Node]
    rest: Optional[str]

class MatchClassPattern(Node):
    cls: Node
    arguments: PatternArguments

class MatchStarPattern(Node):
    name: Optional[str]

class MatchAsPattern(Node):
    pattern: Optional[Node]
    name: Optional[str]

class MatchOrPattern(Node):
    patterns: Sequence[Node]

class TypeVar(Node):
    name: str
    bound: Optional[Node]
    default: Optional[Node]

class TypeVarTuple(Node):
    name: str
    default: Optional[Node]

class ParamSpec(Node):
    name: str
    default: Optional[Node]

class InterpolatedStringFormatSpec(Node):
    pass

class PatternArguments(Node):
    pass

class PatternKeyword(Node):
    pass

class Comprehension(Node):
    pass

class Parameters(Node):
    posonlyargs: Sequence[ParameterWithDefault]
    args: Sequence[ParameterWithDefault]
    vararg: Optional[Parameter]
    kwonlyargs: Sequence[ParameterWithDefault]
    kwarg: Optional[Parameter]

class Parameter(Node):
    name: str
    annotation: Optional[Node]

class ParameterWithDefault(Node):
    parameter: Parameter
    default: Optional[Node]

class Alias(Node):
    pass

class WithItem(Node):
    pass

class MatchCase(Node):
    pass

class Decorator(Node):
    pass

class ElifElseClause(Node):
    pass

class TypeParams(Node):
    pass

class FString(Node):
    pass

class TString(Node):
    pass

class StringLiteral(Node):
    pass

class BytesLiteral(Node):
    pass

class Identifier(Node):
    pass

class Arguments(Node):
    args: Sequence[Node]
    keywords: Sequence[Keyword]

class Keyword(Node):
    arg: Optional[str]
    value: Node

