// This file is auto-generated by crates/ruff_python_ast/generate.py

use pyo3::PyObject;
use pyo3::prelude::*;
use pyo3::types::PyTuple;

use ruff_python_ast::AnyNodeRef;
use ruff_text_size::Ranged;

use super::generated::{
    Alias, AnnAssignStmt, Arguments, AssertStmt, AssignStmt, AttributeExpr, AugAssignStmt,
    AwaitExpr, BinOpExpr, BoolOpExpr, BooleanLiteralExpr, BreakStmt, BytesLiteral,
    BytesLiteralExpr, CallExpr, ClassDefStmt, CompareExpr, Comprehension, ContinueStmt, Decorator,
    DeleteStmt, DictCompExpr, DictExpr, ElifElseClause, EllipsisLiteralExpr, ExceptHandler,
    ExprStmt, Expression, FString, FStringExpr, ForStmt, FunctionDefStmt, GeneratorExpr,
    GlobalStmt, Identifier, IfExpr, IfStmt, ImportFromStmt, ImportStmt, InterpolatedElement,
    InterpolatedStringFormatSpec, InterpolatedStringLiteralElement, IpyEscapeCommandExpr,
    IpyEscapeCommandStmt, Keyword, LambdaExpr, ListCompExpr, ListExpr, MatchAsPattern, MatchCase,
    MatchClassPattern, MatchMappingPattern, MatchOrPattern, MatchSequencePattern,
    MatchSingletonPattern, MatchStarPattern, MatchStmt, MatchValuePattern, Module, NameExpr,
    NamedExpr, NoneLiteralExpr, NonlocalStmt, NumberLiteralExpr, ParamSpec, Parameter,
    ParameterWithDefault, Parameters, PassStmt, PatternArguments, PatternKeyword, RaiseStmt,
    ReturnStmt, SetCompExpr, SetExpr, SliceExpr, StarredExpr, StringLiteral, StringLiteralExpr,
    SubscriptExpr, TString, TStringExpr, TryStmt, TupleExpr, TypeAliasStmt, TypeParams, TypeVar,
    TypeVarTuple, UnaryOpExpr, WhileStmt, WithItem, WithStmt, YieldExpr, YieldFromExpr,
};
use super::{
    ProjectionTypesRef, expr_to_python, extract_callee, node_to_python, optional_str, py_bool,
    py_string, source::SourceFileHandle, span_tuple,
};
use crate::Locator;
use crate::external::ast::target::{ExprKind, StmtKind};
#[derive(Clone, Copy, Debug)]
#[allow(dead_code)]
pub(crate) enum ProjectionMode<'a> {
    Generic,
    Typed,
    Fields(&'a [&'a str]),
}

impl ProjectionMode<'_> {
    pub(crate) const fn wants_typed(&self) -> bool {
        !matches!(self, ProjectionMode::Generic)
    }
}
#[allow(unreachable_patterns)]
pub(crate) fn project_typed_node(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: AnyNodeRef<'_>,
    mode: ProjectionMode<'_>,
    types: ProjectionTypesRef,
) -> PyResult<Option<PyObject>> {
    if !mode.wants_typed() {
        return Ok(None);
    }

    match node {
        AnyNodeRef::ModModule(node) => project_mod_module(py, locator, node, types).map(Some),
        AnyNodeRef::ModExpression(node) => {
            project_mod_expression(py, locator, node, types).map(Some)
        }
        AnyNodeRef::StmtFunctionDef(stmt) => {
            project_stmt_function_def(py, locator, stmt, types).map(Some)
        }
        AnyNodeRef::StmtClassDef(stmt) => {
            project_stmt_class_def(py, locator, stmt, types).map(Some)
        }
        AnyNodeRef::StmtReturn(stmt) => project_stmt_return(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtDelete(stmt) => project_stmt_delete(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtTypeAlias(stmt) => {
            project_stmt_type_alias(py, locator, stmt, types).map(Some)
        }
        AnyNodeRef::StmtAssign(stmt) => project_stmt_assign(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtAugAssign(stmt) => {
            project_stmt_aug_assign(py, locator, stmt, types).map(Some)
        }
        AnyNodeRef::StmtAnnAssign(stmt) => {
            project_stmt_ann_assign(py, locator, stmt, types).map(Some)
        }
        AnyNodeRef::StmtFor(stmt) => project_stmt_for(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtWhile(stmt) => project_stmt_while(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtIf(stmt) => project_stmt_if(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtWith(stmt) => project_stmt_with(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtMatch(stmt) => project_stmt_match(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtRaise(stmt) => project_stmt_raise(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtTry(stmt) => project_stmt_try(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtAssert(stmt) => project_stmt_assert(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtImport(stmt) => project_stmt_import(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtImportFrom(stmt) => {
            project_stmt_import_from(py, locator, stmt, types).map(Some)
        }
        AnyNodeRef::StmtGlobal(stmt) => project_stmt_global(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtNonlocal(stmt) => project_stmt_nonlocal(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtExpr(stmt) => project_stmt_expr(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtPass(stmt) => project_stmt_pass(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtBreak(stmt) => project_stmt_break(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtContinue(stmt) => project_stmt_continue(py, locator, stmt, types).map(Some),
        AnyNodeRef::StmtIpyEscapeCommand(stmt) => {
            project_stmt_ipy_escape_command(py, locator, stmt, types).map(Some)
        }
        AnyNodeRef::ExprBoolOp(expr) => project_expr_bool_op(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprNamed(expr) => project_expr_named(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprBinOp(expr) => project_expr_bin_op(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprUnaryOp(expr) => project_expr_unary_op(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprLambda(expr) => project_expr_lambda(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprIf(expr) => project_expr_if(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprDict(expr) => project_expr_dict(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprSet(expr) => project_expr_set(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprListComp(expr) => {
            project_expr_list_comp(py, locator, expr, types).map(Some)
        }
        AnyNodeRef::ExprSetComp(expr) => project_expr_set_comp(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprDictComp(expr) => {
            project_expr_dict_comp(py, locator, expr, types).map(Some)
        }
        AnyNodeRef::ExprGenerator(expr) => {
            project_expr_generator(py, locator, expr, types).map(Some)
        }
        AnyNodeRef::ExprAwait(expr) => project_expr_await(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprYield(expr) => project_expr_yield(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprYieldFrom(expr) => {
            project_expr_yield_from(py, locator, expr, types).map(Some)
        }
        AnyNodeRef::ExprCompare(expr) => project_expr_compare(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprCall(expr) => project_expr_call(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprFString(expr) => project_expr_f_string(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprTString(expr) => project_expr_t_string(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprStringLiteral(expr) => {
            project_expr_string_literal(py, locator, expr, types).map(Some)
        }
        AnyNodeRef::ExprBytesLiteral(expr) => {
            project_expr_bytes_literal(py, locator, expr, types).map(Some)
        }
        AnyNodeRef::ExprNumberLiteral(expr) => {
            project_expr_number_literal(py, locator, expr, types).map(Some)
        }
        AnyNodeRef::ExprBooleanLiteral(expr) => {
            project_expr_boolean_literal(py, locator, expr, types).map(Some)
        }
        AnyNodeRef::ExprNoneLiteral(expr) => {
            project_expr_none_literal(py, locator, expr, types).map(Some)
        }
        AnyNodeRef::ExprEllipsisLiteral(expr) => {
            project_expr_ellipsis_literal(py, locator, expr, types).map(Some)
        }
        AnyNodeRef::ExprAttribute(expr) => {
            project_expr_attribute(py, locator, expr, types).map(Some)
        }
        AnyNodeRef::ExprSubscript(expr) => {
            project_expr_subscript(py, locator, expr, types).map(Some)
        }
        AnyNodeRef::ExprStarred(expr) => project_expr_starred(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprName(expr) => project_expr_name(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprList(expr) => project_expr_list(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprTuple(expr) => project_expr_tuple(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprSlice(expr) => project_expr_slice(py, locator, expr, types).map(Some),
        AnyNodeRef::ExprIpyEscapeCommand(expr) => {
            project_expr_ipy_escape_command(py, locator, expr, types).map(Some)
        }
        AnyNodeRef::ExceptHandlerExceptHandler(node) => {
            project_except_handler_except_handler(py, locator, node, types).map(Some)
        }
        AnyNodeRef::InterpolatedElement(node) => {
            project_interpolated_element(py, locator, node, types).map(Some)
        }
        AnyNodeRef::InterpolatedStringLiteralElement(node) => {
            project_interpolated_string_literal_element(py, locator, node, types).map(Some)
        }
        AnyNodeRef::PatternMatchValue(node) => {
            project_pattern_match_value(py, locator, node, types).map(Some)
        }
        AnyNodeRef::PatternMatchSingleton(node) => {
            project_pattern_match_singleton(py, locator, node, types).map(Some)
        }
        AnyNodeRef::PatternMatchSequence(node) => {
            project_pattern_match_sequence(py, locator, node, types).map(Some)
        }
        AnyNodeRef::PatternMatchMapping(node) => {
            project_pattern_match_mapping(py, locator, node, types).map(Some)
        }
        AnyNodeRef::PatternMatchClass(node) => {
            project_pattern_match_class(py, locator, node, types).map(Some)
        }
        AnyNodeRef::PatternMatchStar(node) => {
            project_pattern_match_star(py, locator, node, types).map(Some)
        }
        AnyNodeRef::PatternMatchAs(node) => {
            project_pattern_match_as(py, locator, node, types).map(Some)
        }
        AnyNodeRef::PatternMatchOr(node) => {
            project_pattern_match_or(py, locator, node, types).map(Some)
        }
        AnyNodeRef::TypeParamTypeVar(node) => {
            project_type_param_type_var(py, locator, node, types).map(Some)
        }
        AnyNodeRef::TypeParamTypeVarTuple(node) => {
            project_type_param_type_var_tuple(py, locator, node, types).map(Some)
        }
        AnyNodeRef::TypeParamParamSpec(node) => {
            project_type_param_param_spec(py, locator, node, types).map(Some)
        }
        AnyNodeRef::InterpolatedStringFormatSpec(node) => {
            project_interpolated_string_format_spec(py, locator, node, types).map(Some)
        }
        AnyNodeRef::PatternArguments(node) => {
            project_pattern_arguments(py, locator, node, types).map(Some)
        }
        AnyNodeRef::PatternKeyword(node) => {
            project_pattern_keyword(py, locator, node, types).map(Some)
        }
        AnyNodeRef::Comprehension(node) => {
            project_comprehension(py, locator, node, types).map(Some)
        }
        AnyNodeRef::Parameters(node) => project_parameters(py, locator, node, types).map(Some),
        AnyNodeRef::Parameter(node) => project_parameter(py, locator, node, types).map(Some),
        AnyNodeRef::ParameterWithDefault(node) => {
            project_parameter_with_default(py, locator, node, types).map(Some)
        }
        AnyNodeRef::Alias(node) => project_alias(py, locator, node, types).map(Some),
        AnyNodeRef::WithItem(node) => project_with_item(py, locator, node, types).map(Some),
        AnyNodeRef::MatchCase(node) => project_match_case(py, locator, node, types).map(Some),
        AnyNodeRef::Decorator(node) => project_decorator(py, locator, node, types).map(Some),
        AnyNodeRef::ElifElseClause(node) => {
            project_elif_else_clause(py, locator, node, types).map(Some)
        }
        AnyNodeRef::TypeParams(node) => project_type_params(py, locator, node, types).map(Some),
        AnyNodeRef::FString(node) => project_f_string(py, locator, node, types).map(Some),
        AnyNodeRef::TString(node) => project_t_string(py, locator, node, types).map(Some),
        AnyNodeRef::StringLiteral(node) => {
            project_string_literal(py, locator, node, types).map(Some)
        }
        AnyNodeRef::BytesLiteral(node) => project_bytes_literal(py, locator, node, types).map(Some),
        AnyNodeRef::Identifier(node) => project_identifier(py, locator, node, types).map(Some),
        AnyNodeRef::Arguments(node) => project_arguments(py, locator, node, types).map(Some),
        AnyNodeRef::Keyword(node) => project_keyword(py, locator, node, types).map(Some),
        _ => Ok(None),
    }
}
fn project_mod_module(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::ModModule,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "Module".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    Module::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_mod_expression(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::ModExpression,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "Expression".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    Expression::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_function_def(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtFunctionDef,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::FunctionDef.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    let is_async = py_bool(py, stmt.is_async);
    let name = py_string(py, stmt.name.as_str());
    FunctionDefStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        is_async,
        name,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_class_def(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtClassDef,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::ClassDef.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    let name = py_string(py, stmt.name.as_str());
    ClassDefStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        name,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_return(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtReturn,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::Return.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    ReturnStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_delete(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtDelete,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::Delete.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    DeleteStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_type_alias(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtTypeAlias,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::TypeAlias.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    TypeAliasStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_assign(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtAssign,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::Assign.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    AssignStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_aug_assign(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtAugAssign,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::AugAssign.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    let op = py_string(py, stmt.op.as_str());
    AugAssignStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        op,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_ann_assign(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtAnnAssign,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::AnnAssign.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    let simple = py_bool(py, stmt.simple);
    AnnAssignStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        simple,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_for(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtFor,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::For.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    let is_async = py_bool(py, stmt.is_async);
    ForStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        is_async,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_while(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtWhile,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::While.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    WhileStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_if(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtIf,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::If.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    let test = expr_to_python(py, locator, &stmt.test, types)?;
    IfStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        test,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_with(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtWith,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::With.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    let is_async = py_bool(py, stmt.is_async);
    WithStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        is_async,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_match(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtMatch,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::Match.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    MatchStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_raise(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtRaise,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::Raise.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    RaiseStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_try(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtTry,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::Try.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    let is_star = py_bool(py, stmt.is_star);
    TryStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        is_star,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_assert(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtAssert,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::Assert.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    AssertStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_import(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtImport,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::Import.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    ImportStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_import_from(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtImportFrom,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::ImportFrom.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    let module = optional_str(
        py,
        stmt.module
            .as_ref()
            .map(ruff_python_ast::Identifier::as_str),
    );
    ImportFromStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        module,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_global(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtGlobal,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::Global.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    GlobalStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_nonlocal(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtNonlocal,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::Nonlocal.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    NonlocalStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_expr(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtExpr,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::Expr.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    ExprStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_pass(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtPass,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::Pass.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    PassStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_break(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtBreak,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::Break.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    BreakStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_continue(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtContinue,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::Continue.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    ContinueStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_stmt_ipy_escape_command(
    py: Python<'_>,
    locator: &Locator<'_>,
    stmt: &ruff_python_ast::StmtIpyEscapeCommand,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = StmtKind::IpyEscapeCommand.as_str().to_string();
    let range = stmt.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{stmt:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(stmt);
    let kind_field = py_string(py, stmt.kind.as_str());
    IpyEscapeCommandStmt::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        kind_field,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_bool_op(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprBoolOp,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::BoolOp.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    let op = py_string(py, expr.op.as_str());
    BoolOpExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        op,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_named(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprNamed,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::Named.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    NamedExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_bin_op(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprBinOp,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::BinOp.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    let op = py_string(py, expr.op.as_str());
    BinOpExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        op,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_unary_op(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprUnaryOp,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::UnaryOp.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    let op = py_string(py, expr.op.as_str());
    UnaryOpExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        op,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_lambda(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprLambda,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::Lambda.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    LambdaExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_if(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprIf,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::If.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    let test = expr_to_python(py, locator, &expr.test, types)?;
    IfExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        test,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_dict(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprDict,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::Dict.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    DictExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_set(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprSet,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::Set.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    SetExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_list_comp(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprListComp,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::ListComp.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    ListCompExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_set_comp(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprSetComp,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::SetComp.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    SetCompExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_dict_comp(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprDictComp,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::DictComp.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    DictCompExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_generator(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprGenerator,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::Generator.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    let parenthesized = py_bool(py, expr.parenthesized);
    GeneratorExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        parenthesized,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_await(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprAwait,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::Await.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    AwaitExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_yield(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprYield,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::Yield.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    YieldExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_yield_from(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprYieldFrom,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::YieldFrom.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    YieldFromExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_compare(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprCompare,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::Compare.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    let mut ops_values = Vec::with_capacity(expr.ops.len());
    for value in &expr.ops {
        ops_values.push(py_string(py, value.as_str()));
    }
    let ops = PyTuple::new(py, ops_values)?.into_any().unbind();
    CompareExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        ops,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_call(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprCall,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::Call.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    let callee = extract_callee(locator, range, expr);
    let function_text = Some(locator.slice(expr.func.range()).trim().to_string());
    let function_kind = Some(ExprKind::from(expr.func.as_ref()).as_str().to_owned());
    let arguments = node_to_python(py, locator, AnyNodeRef::from(&expr.arguments), types)?;
    CallExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        arguments,
        callee,
        function_text,
        function_kind,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_f_string(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprFString,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::FString.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    FStringExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_t_string(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprTString,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::TString.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    TStringExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_string_literal(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprStringLiteral,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::StringLiteral.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    StringLiteralExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_bytes_literal(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprBytesLiteral,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::BytesLiteral.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    BytesLiteralExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_number_literal(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprNumberLiteral,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::NumberLiteral.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    NumberLiteralExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_boolean_literal(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprBooleanLiteral,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::BooleanLiteral.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    let value = py_bool(py, expr.value);
    BooleanLiteralExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        value,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_none_literal(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprNoneLiteral,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::NoneLiteral.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    NoneLiteralExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_ellipsis_literal(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprEllipsisLiteral,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::EllipsisLiteral.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    EllipsisLiteralExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_attribute(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprAttribute,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::Attribute.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    let attr = py_string(py, expr.attr.as_str());
    let ctx_value = format!("{access:?}", access = expr.ctx);
    let ctx = py_string(py, &ctx_value);
    AttributeExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        attr,
        ctx,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_subscript(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprSubscript,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::Subscript.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    let ctx_value = format!("{access:?}", access = expr.ctx);
    let ctx = py_string(py, &ctx_value);
    SubscriptExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        ctx,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_starred(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprStarred,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::Starred.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    let ctx_value = format!("{access:?}", access = expr.ctx);
    let ctx = py_string(py, &ctx_value);
    StarredExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        ctx,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_name(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprName,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::Name.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    let ctx_value = format!("{access:?}", access = expr.ctx);
    let ctx = py_string(py, &ctx_value);
    NameExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        ctx,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_list(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprList,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::List.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    let ctx_value = format!("{access:?}", access = expr.ctx);
    let ctx = py_string(py, &ctx_value);
    ListExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        ctx,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_tuple(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprTuple,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::Tuple.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    let ctx_value = format!("{access:?}", access = expr.ctx);
    let ctx = py_string(py, &ctx_value);
    let parenthesized = py_bool(py, expr.parenthesized);
    TupleExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        ctx,
        parenthesized,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_slice(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprSlice,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::Slice.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    SliceExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_expr_ipy_escape_command(
    py: Python<'_>,
    locator: &Locator<'_>,
    expr: &ruff_python_ast::ExprIpyEscapeCommand,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = ExprKind::IpyEscapeCommand.as_str().to_string();
    let range = expr.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{expr:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(expr);
    let kind_field = py_string(py, expr.kind.as_str());
    IpyEscapeCommandExpr::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        kind_field,
        SourceFileHandle::new(),
        types,
    )
}
fn project_except_handler_except_handler(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::ExceptHandlerExceptHandler,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "ExceptHandler".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    ExceptHandler::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_interpolated_element(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::InterpolatedElement,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "Interpolation".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    InterpolatedElement::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_interpolated_string_literal_element(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::InterpolatedStringLiteralElement,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "Literal".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    InterpolatedStringLiteralElement::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_pattern_match_value(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::PatternMatchValue,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "MatchValue".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    MatchValuePattern::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_pattern_match_singleton(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::PatternMatchSingleton,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "MatchSingleton".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    MatchSingletonPattern::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_pattern_match_sequence(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::PatternMatchSequence,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "MatchSequence".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    MatchSequencePattern::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_pattern_match_mapping(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::PatternMatchMapping,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "MatchMapping".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    let rest = optional_str(
        py,
        node.rest.as_ref().map(ruff_python_ast::Identifier::as_str),
    );
    MatchMappingPattern::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        rest,
        SourceFileHandle::new(),
        types,
    )
}
fn project_pattern_match_class(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::PatternMatchClass,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "MatchClass".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    MatchClassPattern::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_pattern_match_star(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::PatternMatchStar,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "MatchStar".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    let name = optional_str(
        py,
        node.name.as_ref().map(ruff_python_ast::Identifier::as_str),
    );
    MatchStarPattern::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        name,
        SourceFileHandle::new(),
        types,
    )
}
fn project_pattern_match_as(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::PatternMatchAs,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "MatchAs".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    let name = optional_str(
        py,
        node.name.as_ref().map(ruff_python_ast::Identifier::as_str),
    );
    MatchAsPattern::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        name,
        SourceFileHandle::new(),
        types,
    )
}
fn project_pattern_match_or(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::PatternMatchOr,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "MatchOr".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    MatchOrPattern::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_type_param_type_var(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::TypeParamTypeVar,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "TypeVar".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    let name = py_string(py, node.name.as_str());
    TypeVar::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        name,
        SourceFileHandle::new(),
        types,
    )
}
fn project_type_param_type_var_tuple(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::TypeParamTypeVarTuple,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "TypeVarTuple".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    let name = py_string(py, node.name.as_str());
    TypeVarTuple::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        name,
        SourceFileHandle::new(),
        types,
    )
}
fn project_type_param_param_spec(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::TypeParamParamSpec,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "ParamSpec".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    let name = py_string(py, node.name.as_str());
    ParamSpec::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        name,
        SourceFileHandle::new(),
        types,
    )
}
fn project_interpolated_string_format_spec(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::InterpolatedStringFormatSpec,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "InterpolatedStringFormatSpec".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    InterpolatedStringFormatSpec::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_pattern_arguments(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::PatternArguments,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "PatternArguments".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    PatternArguments::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_pattern_keyword(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::PatternKeyword,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "PatternKeyword".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    PatternKeyword::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_comprehension(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::Comprehension,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "Comprehension".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    Comprehension::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_parameters(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::Parameters,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "Parameters".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    Parameters::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_parameter(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::Parameter,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "Parameter".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    Parameter::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_parameter_with_default(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::ParameterWithDefault,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "ParameterWithDefault".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    ParameterWithDefault::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_alias(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::Alias,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "Alias".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    Alias::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_with_item(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::WithItem,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "WithItem".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    WithItem::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_match_case(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::MatchCase,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "MatchCase".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    MatchCase::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_decorator(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::Decorator,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "Decorator".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    Decorator::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_elif_else_clause(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::ElifElseClause,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "ElifElseClause".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    ElifElseClause::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_type_params(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::TypeParams,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "TypeParams".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    TypeParams::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_f_string(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::FString,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "FString".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    FString::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_t_string(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::TString,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "TString".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    TString::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_string_literal(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::StringLiteral,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "StringLiteral".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    StringLiteral::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_bytes_literal(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::BytesLiteral,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "BytesLiteral".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    BytesLiteral::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_identifier(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::Identifier,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "Identifier".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    Identifier::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_arguments(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::Arguments,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "Arguments".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    Arguments::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
fn project_keyword(
    py: Python<'_>,
    locator: &Locator<'_>,
    node: &ruff_python_ast::Keyword,
    types: ProjectionTypesRef,
) -> PyResult<PyObject> {
    let kind = "Keyword".to_string();
    let range = node.range();
    let text = locator.slice(range).to_string();
    let repr_value = format!("{node:?}");
    let store = super::store::current_store();
    let node_id = store.ensure(node);
    Keyword::new_instance(
        py,
        kind,
        span_tuple(py, range)?,
        text,
        repr_value,
        node_id,
        store,
        SourceFileHandle::new(),
        types,
    )
}
