// This file is auto-generated by crates/ruff_python_ast/generate.py

#![allow(clippy::unnecessary_wraps)]

use pyo3::exceptions::PyRuntimeError;

use pyo3::PyClassInitializer;
use pyo3::prelude::*;
use pyo3::types::{PyModule, PyTuple};

use ruff_python_ast::AnyNodeRef;

use super::ProjectionTypesRef;
use super::bindings;
use super::source::SourceFileHandle;
use super::store::AstStoreHandle;
use super::{
    expr_to_python, node_to_python, optional_str, py_int, py_none, py_string, stmt_to_python,
};
fn cache_value(slot: &mut Option<PyObject>, py: Python<'_>, value: PyObject) -> PyResult<PyObject> {
    *slot = Some(value.clone_ref(py));
    Ok(value)
}

fn map_option<T>(
    py: Python<'_>,
    value: Option<T>,
    mapper: impl FnOnce(T) -> PyResult<PyObject>,
) -> PyResult<PyObject> {
    match value {
        Some(value) => mapper(value),
        None => Ok(py_none(py)),
    }
}

fn map_tuple<I, F>(py: Python<'_>, iter: I, mut mapper: F) -> PyResult<PyObject>
where
    I: IntoIterator,
    F: FnMut(I::Item) -> PyResult<PyObject>,
{
    let mut values = Vec::new();
    for value in iter {
        values.push(mapper(value)?);
    }
    Ok(PyTuple::new(py, values)?.into_any().unbind())
}

fn get_ast<T>(store: &AstStoreHandle, id: u32) -> PyResult<&T>
where
    T: 'static,
{
    store
        .get::<T>(id)
        .map_err(|err| PyRuntimeError::new_err(err.to_string()))
}
pub(crate) const GENERATED_EXPORTS: &[&str] = &[
    "Module",
    "Expression",
    "FunctionDefStmt",
    "ClassDefStmt",
    "ReturnStmt",
    "DeleteStmt",
    "TypeAliasStmt",
    "AssignStmt",
    "AugAssignStmt",
    "AnnAssignStmt",
    "ForStmt",
    "WhileStmt",
    "IfStmt",
    "WithStmt",
    "MatchStmt",
    "RaiseStmt",
    "TryStmt",
    "AssertStmt",
    "ImportStmt",
    "ImportFromStmt",
    "GlobalStmt",
    "NonlocalStmt",
    "ExprStmt",
    "PassStmt",
    "BreakStmt",
    "ContinueStmt",
    "IpyEscapeCommandStmt",
    "BoolOpExpr",
    "NamedExpr",
    "BinOpExpr",
    "UnaryOpExpr",
    "LambdaExpr",
    "IfExpr",
    "DictExpr",
    "SetExpr",
    "ListCompExpr",
    "SetCompExpr",
    "DictCompExpr",
    "GeneratorExpr",
    "AwaitExpr",
    "YieldExpr",
    "YieldFromExpr",
    "CompareExpr",
    "CallExpr",
    "FStringExpr",
    "TStringExpr",
    "StringLiteralExpr",
    "BytesLiteralExpr",
    "NumberLiteralExpr",
    "BooleanLiteralExpr",
    "NoneLiteralExpr",
    "EllipsisLiteralExpr",
    "AttributeExpr",
    "SubscriptExpr",
    "StarredExpr",
    "NameExpr",
    "ListExpr",
    "TupleExpr",
    "SliceExpr",
    "IpyEscapeCommandExpr",
    "ExceptHandler",
    "InterpolatedElement",
    "InterpolatedStringLiteralElement",
    "MatchValuePattern",
    "MatchSingletonPattern",
    "MatchSequencePattern",
    "MatchMappingPattern",
    "MatchClassPattern",
    "MatchStarPattern",
    "MatchAsPattern",
    "MatchOrPattern",
    "TypeVar",
    "TypeVarTuple",
    "ParamSpec",
    "InterpolatedStringFormatSpec",
    "PatternArguments",
    "PatternKeyword",
    "Comprehension",
    "Parameters",
    "Parameter",
    "ParameterWithDefault",
    "Alias",
    "WithItem",
    "MatchCase",
    "Decorator",
    "ElifElseClause",
    "TypeParams",
    "FString",
    "TString",
    "StringLiteral",
    "BytesLiteral",
    "Identifier",
    "Arguments",
    "Keyword",
];
pub(crate) fn add_generated_classes(module: &Bound<'_, PyModule>) -> PyResult<()> {
    module.add_class::<Module>()?;
    module.add_class::<Expression>()?;
    module.add_class::<FunctionDefStmt>()?;
    module.add_class::<ClassDefStmt>()?;
    module.add_class::<ReturnStmt>()?;
    module.add_class::<DeleteStmt>()?;
    module.add_class::<TypeAliasStmt>()?;
    module.add_class::<AssignStmt>()?;
    module.add_class::<AugAssignStmt>()?;
    module.add_class::<AnnAssignStmt>()?;
    module.add_class::<ForStmt>()?;
    module.add_class::<WhileStmt>()?;
    module.add_class::<IfStmt>()?;
    module.add_class::<WithStmt>()?;
    module.add_class::<MatchStmt>()?;
    module.add_class::<RaiseStmt>()?;
    module.add_class::<TryStmt>()?;
    module.add_class::<AssertStmt>()?;
    module.add_class::<ImportStmt>()?;
    module.add_class::<ImportFromStmt>()?;
    module.add_class::<GlobalStmt>()?;
    module.add_class::<NonlocalStmt>()?;
    module.add_class::<ExprStmt>()?;
    module.add_class::<PassStmt>()?;
    module.add_class::<BreakStmt>()?;
    module.add_class::<ContinueStmt>()?;
    module.add_class::<IpyEscapeCommandStmt>()?;
    module.add_class::<BoolOpExpr>()?;
    module.add_class::<NamedExpr>()?;
    module.add_class::<BinOpExpr>()?;
    module.add_class::<UnaryOpExpr>()?;
    module.add_class::<LambdaExpr>()?;
    module.add_class::<IfExpr>()?;
    module.add_class::<DictExpr>()?;
    module.add_class::<SetExpr>()?;
    module.add_class::<ListCompExpr>()?;
    module.add_class::<SetCompExpr>()?;
    module.add_class::<DictCompExpr>()?;
    module.add_class::<GeneratorExpr>()?;
    module.add_class::<AwaitExpr>()?;
    module.add_class::<YieldExpr>()?;
    module.add_class::<YieldFromExpr>()?;
    module.add_class::<CompareExpr>()?;
    module.add_class::<CallExpr>()?;
    module.add_class::<FStringExpr>()?;
    module.add_class::<TStringExpr>()?;
    module.add_class::<StringLiteralExpr>()?;
    module.add_class::<BytesLiteralExpr>()?;
    module.add_class::<NumberLiteralExpr>()?;
    module.add_class::<BooleanLiteralExpr>()?;
    module.add_class::<NoneLiteralExpr>()?;
    module.add_class::<EllipsisLiteralExpr>()?;
    module.add_class::<AttributeExpr>()?;
    module.add_class::<SubscriptExpr>()?;
    module.add_class::<StarredExpr>()?;
    module.add_class::<NameExpr>()?;
    module.add_class::<ListExpr>()?;
    module.add_class::<TupleExpr>()?;
    module.add_class::<SliceExpr>()?;
    module.add_class::<IpyEscapeCommandExpr>()?;
    module.add_class::<ExceptHandler>()?;
    module.add_class::<InterpolatedElement>()?;
    module.add_class::<InterpolatedStringLiteralElement>()?;
    module.add_class::<MatchValuePattern>()?;
    module.add_class::<MatchSingletonPattern>()?;
    module.add_class::<MatchSequencePattern>()?;
    module.add_class::<MatchMappingPattern>()?;
    module.add_class::<MatchClassPattern>()?;
    module.add_class::<MatchStarPattern>()?;
    module.add_class::<MatchAsPattern>()?;
    module.add_class::<MatchOrPattern>()?;
    module.add_class::<TypeVar>()?;
    module.add_class::<TypeVarTuple>()?;
    module.add_class::<ParamSpec>()?;
    module.add_class::<InterpolatedStringFormatSpec>()?;
    module.add_class::<PatternArguments>()?;
    module.add_class::<PatternKeyword>()?;
    module.add_class::<Comprehension>()?;
    module.add_class::<Parameters>()?;
    module.add_class::<Parameter>()?;
    module.add_class::<ParameterWithDefault>()?;
    module.add_class::<Alias>()?;
    module.add_class::<WithItem>()?;
    module.add_class::<MatchCase>()?;
    module.add_class::<Decorator>()?;
    module.add_class::<ElifElseClause>()?;
    module.add_class::<TypeParams>()?;
    module.add_class::<FString>()?;
    module.add_class::<TString>()?;
    module.add_class::<StringLiteral>()?;
    module.add_class::<BytesLiteral>()?;
    module.add_class::<Identifier>()?;
    module.add_class::<Arguments>()?;
    module.add_class::<Keyword>()?;
    Ok(())
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct Module {
    body: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl Module {
    #[getter]
    fn body(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.body {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_body(this)
    }
    fn load_body(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ModModule>(&store, node_id)?;
        let value = map_tuple(py, ast.body.iter(), |value| {
            stmt_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.body, py, value)
    }
}
impl Module {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                body: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct Expression {
    body: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl Expression {
    #[getter]
    fn body(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.body {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_body(this)
    }
    fn load_body(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ModExpression>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.body, this.projection)?;
        cache_value(&mut this.body, py, value)
    }
}
impl Expression {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                body: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct FunctionDefStmt {
    is_async: Option<PyObject>,
    decorator_list: Option<PyObject>,
    name: Option<PyObject>,
    type_params: Option<PyObject>,
    parameters: Option<PyObject>,
    returns: Option<PyObject>,
    body: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl FunctionDefStmt {
    #[getter]
    fn is_async(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.is_async.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn decorator_list(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.decorator_list {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_decorator_list(this)
    }
    #[getter]
    fn name(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.name.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn type_params(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.type_params {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_type_params(this)
    }
    #[getter]
    fn parameters(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.parameters {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_parameters(this)
    }
    #[getter]
    fn returns(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.returns {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_returns(this)
    }
    #[getter]
    fn body(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.body {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_body(this)
    }
    fn load_decorator_list(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtFunctionDef>(&store, node_id)?;
        let value = map_tuple(py, ast.decorator_list.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.decorator_list, py, value)
    }
    fn load_type_params(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtFunctionDef>(&store, node_id)?;
        let value = map_option(py, ast.type_params.as_ref(), |value| {
            node_to_python(
                py,
                &locator,
                AnyNodeRef::from(value.as_ref()),
                this.projection,
            )
        })?;
        cache_value(&mut this.type_params, py, value)
    }
    fn load_parameters(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtFunctionDef>(&store, node_id)?;
        let value = node_to_python(
            py,
            &locator,
            AnyNodeRef::from(ast.parameters.as_ref()),
            this.projection,
        )?;
        cache_value(&mut this.parameters, py, value)
    }
    fn load_returns(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtFunctionDef>(&store, node_id)?;
        let value = map_option(py, ast.returns.as_ref(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.returns, py, value)
    }
    fn load_body(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtFunctionDef>(&store, node_id)?;
        let value = map_tuple(py, ast.body.iter(), |value| {
            stmt_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.body, py, value)
    }
}
impl FunctionDefStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        is_async: PyObject,
        name: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                is_async: Some(is_async),
                decorator_list: None,
                name: Some(name),
                type_params: None,
                parameters: None,
                returns: None,
                body: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        is_async: PyObject,
        name: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, is_async, name, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct ClassDefStmt {
    decorator_list: Option<PyObject>,
    name: Option<PyObject>,
    type_params: Option<PyObject>,
    arguments: Option<PyObject>,
    body: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl ClassDefStmt {
    #[getter]
    fn decorator_list(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.decorator_list {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_decorator_list(this)
    }
    #[getter]
    fn name(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.name.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn type_params(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.type_params {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_type_params(this)
    }
    #[getter]
    fn arguments(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.arguments {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_arguments(this)
    }
    #[getter]
    fn body(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.body {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_body(this)
    }
    fn load_decorator_list(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtClassDef>(&store, node_id)?;
        let value = map_tuple(py, ast.decorator_list.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.decorator_list, py, value)
    }
    fn load_type_params(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtClassDef>(&store, node_id)?;
        let value = map_option(py, ast.type_params.as_ref(), |value| {
            node_to_python(
                py,
                &locator,
                AnyNodeRef::from(value.as_ref()),
                this.projection,
            )
        })?;
        cache_value(&mut this.type_params, py, value)
    }
    fn load_arguments(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtClassDef>(&store, node_id)?;
        let value = map_option(py, ast.arguments.as_ref(), |value| {
            node_to_python(
                py,
                &locator,
                AnyNodeRef::from(value.as_ref()),
                this.projection,
            )
        })?;
        cache_value(&mut this.arguments, py, value)
    }
    fn load_body(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtClassDef>(&store, node_id)?;
        let value = map_tuple(py, ast.body.iter(), |value| {
            stmt_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.body, py, value)
    }
}
impl ClassDefStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        name: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                decorator_list: None,
                name: Some(name),
                type_params: None,
                arguments: None,
                body: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        name: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, name, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct ReturnStmt {
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl ReturnStmt {
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtReturn>(&store, node_id)?;
        let value = map_option(py, ast.value.as_ref(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.value, py, value)
    }
}
impl ReturnStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct DeleteStmt {
    targets: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl DeleteStmt {
    #[getter]
    fn targets(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.targets {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_targets(this)
    }
    fn load_targets(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtDelete>(&store, node_id)?;
        let value = map_tuple(py, ast.targets.iter(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.targets, py, value)
    }
}
impl DeleteStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                targets: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct TypeAliasStmt {
    name: Option<PyObject>,
    type_params: Option<PyObject>,
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl TypeAliasStmt {
    #[getter]
    fn name(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.name {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_name(this)
    }
    #[getter]
    fn type_params(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.type_params {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_type_params(this)
    }
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_name(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtTypeAlias>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.name, this.projection)?;
        cache_value(&mut this.name, py, value)
    }
    fn load_type_params(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtTypeAlias>(&store, node_id)?;
        let value = map_option(py, ast.type_params.as_ref(), |value| {
            node_to_python(
                py,
                &locator,
                AnyNodeRef::from(value.as_ref()),
                this.projection,
            )
        })?;
        cache_value(&mut this.type_params, py, value)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtTypeAlias>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.value, this.projection)?;
        cache_value(&mut this.value, py, value)
    }
}
impl TypeAliasStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                name: None,
                type_params: None,
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct AssignStmt {
    targets: Option<PyObject>,
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl AssignStmt {
    #[getter]
    fn targets(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.targets {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_targets(this)
    }
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_targets(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtAssign>(&store, node_id)?;
        let value = map_tuple(py, ast.targets.iter(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.targets, py, value)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtAssign>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.value, this.projection)?;
        cache_value(&mut this.value, py, value)
    }
}
impl AssignStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                targets: None,
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct AugAssignStmt {
    target: Option<PyObject>,
    op: Option<PyObject>,
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl AugAssignStmt {
    #[getter]
    fn target(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.target {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_target(this)
    }
    #[getter]
    fn op(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.op.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_target(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtAugAssign>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.target, this.projection)?;
        cache_value(&mut this.target, py, value)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtAugAssign>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.value, this.projection)?;
        cache_value(&mut this.value, py, value)
    }
}
impl AugAssignStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        op: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                target: None,
                op: Some(op),
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        op: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, op, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct AnnAssignStmt {
    target: Option<PyObject>,
    annotation: Option<PyObject>,
    value: Option<PyObject>,
    simple: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl AnnAssignStmt {
    #[getter]
    fn target(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.target {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_target(this)
    }
    #[getter]
    fn annotation(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.annotation {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_annotation(this)
    }
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    #[getter]
    fn simple(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.simple.as_ref().unwrap().clone_ref(py))
    }
    fn load_target(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtAnnAssign>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.target, this.projection)?;
        cache_value(&mut this.target, py, value)
    }
    fn load_annotation(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtAnnAssign>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.annotation, this.projection)?;
        cache_value(&mut this.annotation, py, value)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtAnnAssign>(&store, node_id)?;
        let value = map_option(py, ast.value.as_ref(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.value, py, value)
    }
}
impl AnnAssignStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        simple: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                target: None,
                annotation: None,
                value: None,
                simple: Some(simple),
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        simple: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, simple, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct ForStmt {
    is_async: Option<PyObject>,
    target: Option<PyObject>,
    iter: Option<PyObject>,
    body: Option<PyObject>,
    orelse: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl ForStmt {
    #[getter]
    fn is_async(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.is_async.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn target(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.target {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_target(this)
    }
    #[allow(clippy::iter_not_returning_iterator)]
    #[getter]
    fn iter(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.iter {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_iter(this)
    }
    #[getter]
    fn body(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.body {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_body(this)
    }
    #[getter]
    fn orelse(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.orelse {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_orelse(this)
    }
    fn load_target(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtFor>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.target, this.projection)?;
        cache_value(&mut this.target, py, value)
    }
    fn load_iter(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtFor>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.iter, this.projection)?;
        cache_value(&mut this.iter, py, value)
    }
    fn load_body(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtFor>(&store, node_id)?;
        let value = map_tuple(py, ast.body.iter(), |value| {
            stmt_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.body, py, value)
    }
    fn load_orelse(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtFor>(&store, node_id)?;
        let value = map_tuple(py, ast.orelse.iter(), |value| {
            stmt_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.orelse, py, value)
    }
}
impl ForStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        is_async: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                is_async: Some(is_async),
                target: None,
                iter: None,
                body: None,
                orelse: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        is_async: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, is_async, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct WhileStmt {
    test: Option<PyObject>,
    body: Option<PyObject>,
    orelse: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl WhileStmt {
    #[getter]
    fn test(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.test {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_test(this)
    }
    #[getter]
    fn body(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.body {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_body(this)
    }
    #[getter]
    fn orelse(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.orelse {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_orelse(this)
    }
    fn load_test(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtWhile>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.test, this.projection)?;
        cache_value(&mut this.test, py, value)
    }
    fn load_body(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtWhile>(&store, node_id)?;
        let value = map_tuple(py, ast.body.iter(), |value| {
            stmt_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.body, py, value)
    }
    fn load_orelse(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtWhile>(&store, node_id)?;
        let value = map_tuple(py, ast.orelse.iter(), |value| {
            stmt_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.orelse, py, value)
    }
}
impl WhileStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                test: None,
                body: None,
                orelse: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct IfStmt {
    test: Option<PyObject>,
    body: Option<PyObject>,
    elif_else_clauses: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl IfStmt {
    #[getter]
    fn test(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.test.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn body(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.body {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_body(this)
    }
    #[getter]
    fn elif_else_clauses(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.elif_else_clauses {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_elif_else_clauses(this)
    }
    fn load_body(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtIf>(&store, node_id)?;
        let value = map_tuple(py, ast.body.iter(), |value| {
            stmt_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.body, py, value)
    }
    fn load_elif_else_clauses(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtIf>(&store, node_id)?;
        let value = map_tuple(py, ast.elif_else_clauses.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.elif_else_clauses, py, value)
    }
}
impl IfStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        test: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                test: Some(test),
                body: None,
                elif_else_clauses: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        test: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, test, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct WithStmt {
    is_async: Option<PyObject>,
    items: Option<PyObject>,
    body: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl WithStmt {
    #[getter]
    fn is_async(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.is_async.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn items(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.items {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_items(this)
    }
    #[getter]
    fn body(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.body {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_body(this)
    }
    fn load_items(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtWith>(&store, node_id)?;
        let value = map_tuple(py, ast.items.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.items, py, value)
    }
    fn load_body(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtWith>(&store, node_id)?;
        let value = map_tuple(py, ast.body.iter(), |value| {
            stmt_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.body, py, value)
    }
}
impl WithStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        is_async: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                is_async: Some(is_async),
                items: None,
                body: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        is_async: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, is_async, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct MatchStmt {
    subject: Option<PyObject>,
    cases: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl MatchStmt {
    #[getter]
    fn subject(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.subject {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_subject(this)
    }
    #[getter]
    fn cases(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.cases {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_cases(this)
    }
    fn load_subject(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtMatch>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.subject, this.projection)?;
        cache_value(&mut this.subject, py, value)
    }
    fn load_cases(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtMatch>(&store, node_id)?;
        let value = map_tuple(py, ast.cases.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.cases, py, value)
    }
}
impl MatchStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                subject: None,
                cases: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct RaiseStmt {
    exc: Option<PyObject>,
    cause: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl RaiseStmt {
    #[getter]
    fn exc(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.exc {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_exc(this)
    }
    #[getter]
    fn cause(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.cause {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_cause(this)
    }
    fn load_exc(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtRaise>(&store, node_id)?;
        let value = map_option(py, ast.exc.as_ref(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.exc, py, value)
    }
    fn load_cause(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtRaise>(&store, node_id)?;
        let value = map_option(py, ast.cause.as_ref(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.cause, py, value)
    }
}
impl RaiseStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                exc: None,
                cause: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct TryStmt {
    body: Option<PyObject>,
    handlers: Option<PyObject>,
    orelse: Option<PyObject>,
    finalbody: Option<PyObject>,
    is_star: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl TryStmt {
    #[getter]
    fn body(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.body {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_body(this)
    }
    #[getter]
    fn handlers(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.handlers {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_handlers(this)
    }
    #[getter]
    fn orelse(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.orelse {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_orelse(this)
    }
    #[getter]
    fn finalbody(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.finalbody {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_finalbody(this)
    }
    #[getter]
    fn is_star(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.is_star.as_ref().unwrap().clone_ref(py))
    }
    fn load_body(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtTry>(&store, node_id)?;
        let value = map_tuple(py, ast.body.iter(), |value| {
            stmt_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.body, py, value)
    }
    fn load_handlers(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtTry>(&store, node_id)?;
        let value = map_tuple(py, ast.handlers.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.handlers, py, value)
    }
    fn load_orelse(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtTry>(&store, node_id)?;
        let value = map_tuple(py, ast.orelse.iter(), |value| {
            stmt_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.orelse, py, value)
    }
    fn load_finalbody(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtTry>(&store, node_id)?;
        let value = map_tuple(py, ast.finalbody.iter(), |value| {
            stmt_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.finalbody, py, value)
    }
}
impl TryStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        is_star: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                body: None,
                handlers: None,
                orelse: None,
                finalbody: None,
                is_star: Some(is_star),
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        is_star: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, is_star, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct AssertStmt {
    test: Option<PyObject>,
    msg: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl AssertStmt {
    #[getter]
    fn test(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.test {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_test(this)
    }
    #[getter]
    fn msg(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.msg {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_msg(this)
    }
    fn load_test(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtAssert>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.test, this.projection)?;
        cache_value(&mut this.test, py, value)
    }
    fn load_msg(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtAssert>(&store, node_id)?;
        let value = map_option(py, ast.msg.as_ref(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.msg, py, value)
    }
}
impl AssertStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                test: None,
                msg: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct ImportStmt {
    names: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl ImportStmt {
    #[getter]
    fn names(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.names {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_names(this)
    }
    fn load_names(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtImport>(&store, node_id)?;
        let value = map_tuple(py, ast.names.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.names, py, value)
    }
}
impl ImportStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                names: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct ImportFromStmt {
    module: Option<PyObject>,
    names: Option<PyObject>,
    level: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl ImportFromStmt {
    #[getter]
    fn module(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.module.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn names(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.names {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_names(this)
    }
    #[getter]
    fn level(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.level {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_level(this)
    }
    fn load_names(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtImportFrom>(&store, node_id)?;
        let value = map_tuple(py, ast.names.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.names, py, value)
    }
    fn load_level(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let ast = get_ast::<ruff_python_ast::StmtImportFrom>(&store, node_id)?;
        let value = py_int(py, ast.level);
        cache_value(&mut this.level, py, value)
    }
}
impl ImportFromStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        module: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                module: Some(module),
                names: None,
                level: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        module: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, module, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct GlobalStmt {
    names: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl GlobalStmt {
    #[getter]
    fn names(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.names {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_names(this)
    }
    fn load_names(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let ast = get_ast::<ruff_python_ast::StmtGlobal>(&store, node_id)?;
        let value = map_tuple(py, ast.names.iter(), |value| {
            Ok(py_string(py, value.as_str()))
        })?;
        cache_value(&mut this.names, py, value)
    }
}
impl GlobalStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                names: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct NonlocalStmt {
    names: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl NonlocalStmt {
    #[getter]
    fn names(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.names {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_names(this)
    }
    fn load_names(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let ast = get_ast::<ruff_python_ast::StmtNonlocal>(&store, node_id)?;
        let value = map_tuple(py, ast.names.iter(), |value| {
            Ok(py_string(py, value.as_str()))
        })?;
        cache_value(&mut this.names, py, value)
    }
}
impl NonlocalStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                names: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct ExprStmt {
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl ExprStmt {
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::StmtExpr>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.value, this.projection)?;
        cache_value(&mut this.value, py, value)
    }
}
impl ExprStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct PassStmt {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl PassStmt {}
impl PassStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct BreakStmt {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl BreakStmt {}
impl BreakStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct ContinueStmt {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl ContinueStmt {}
impl ContinueStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct IpyEscapeCommandStmt {
    kind: Option<PyObject>,
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl IpyEscapeCommandStmt {
    #[getter]
    fn kind(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.kind.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let ast = get_ast::<ruff_python_ast::StmtIpyEscapeCommand>(&store, node_id)?;
        let value = py_string(py, ast.value.as_ref());
        cache_value(&mut this.value, py, value)
    }
}
impl IpyEscapeCommandStmt {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        kind_field: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                kind: Some(kind_field),
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        kind_field: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, kind_field, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct BoolOpExpr {
    op: Option<PyObject>,
    values: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl BoolOpExpr {
    #[getter]
    fn op(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.op.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn values(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.values {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_values(this)
    }
    fn load_values(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprBoolOp>(&store, node_id)?;
        let value = map_tuple(py, ast.values.iter(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.values, py, value)
    }
}
impl BoolOpExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        op: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                op: Some(op),
                values: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        op: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, op, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct NamedExpr {
    target: Option<PyObject>,
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl NamedExpr {
    #[getter]
    fn target(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.target {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_target(this)
    }
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_target(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprNamed>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.target, this.projection)?;
        cache_value(&mut this.target, py, value)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprNamed>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.value, this.projection)?;
        cache_value(&mut this.value, py, value)
    }
}
impl NamedExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                target: None,
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct BinOpExpr {
    left: Option<PyObject>,
    op: Option<PyObject>,
    right: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl BinOpExpr {
    #[getter]
    fn left(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.left {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_left(this)
    }
    #[getter]
    fn op(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.op.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn right(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.right {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_right(this)
    }
    fn load_left(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprBinOp>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.left, this.projection)?;
        cache_value(&mut this.left, py, value)
    }
    fn load_right(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprBinOp>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.right, this.projection)?;
        cache_value(&mut this.right, py, value)
    }
}
impl BinOpExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        op: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                left: None,
                op: Some(op),
                right: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        op: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, op, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct UnaryOpExpr {
    op: Option<PyObject>,
    operand: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl UnaryOpExpr {
    #[getter]
    fn op(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.op.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn operand(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.operand {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_operand(this)
    }
    fn load_operand(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprUnaryOp>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.operand, this.projection)?;
        cache_value(&mut this.operand, py, value)
    }
}
impl UnaryOpExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        op: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                op: Some(op),
                operand: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        op: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, op, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct LambdaExpr {
    parameters: Option<PyObject>,
    body: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl LambdaExpr {
    #[getter]
    fn parameters(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.parameters {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_parameters(this)
    }
    #[getter]
    fn body(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.body {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_body(this)
    }
    fn load_parameters(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprLambda>(&store, node_id)?;
        let value = map_option(py, ast.parameters.as_ref(), |value| {
            node_to_python(
                py,
                &locator,
                AnyNodeRef::from(value.as_ref()),
                this.projection,
            )
        })?;
        cache_value(&mut this.parameters, py, value)
    }
    fn load_body(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprLambda>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.body, this.projection)?;
        cache_value(&mut this.body, py, value)
    }
}
impl LambdaExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                parameters: None,
                body: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct IfExpr {
    test: Option<PyObject>,
    body: Option<PyObject>,
    orelse: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl IfExpr {
    #[getter]
    fn test(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.test.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn body(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.body {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_body(this)
    }
    #[getter]
    fn orelse(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.orelse {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_orelse(this)
    }
    fn load_body(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprIf>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.body, this.projection)?;
        cache_value(&mut this.body, py, value)
    }
    fn load_orelse(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprIf>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.orelse, this.projection)?;
        cache_value(&mut this.orelse, py, value)
    }
}
impl IfExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        test: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                test: Some(test),
                body: None,
                orelse: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        test: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, test, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct DictExpr {
    items: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl DictExpr {
    #[getter]
    fn items(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.items {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_items(this)
    }
    fn load_items(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprDict>(&store, node_id)?;
        let value = map_tuple(py, ast.items.iter(), |item| {
            let key = map_option(py, item.key.as_ref(), |key| {
                expr_to_python(py, &locator, key, this.projection)
            })?;
            let value = expr_to_python(py, &locator, &item.value, this.projection)?;
            PyTuple::new(py, [key, value]).map(|tuple| tuple.into_any().unbind())
        })?;
        cache_value(&mut this.items, py, value)
    }
}
impl DictExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                items: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct SetExpr {
    elts: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl SetExpr {
    #[getter]
    fn elts(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.elts {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_elts(this)
    }
    fn load_elts(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprSet>(&store, node_id)?;
        let value = map_tuple(py, ast.elts.iter(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.elts, py, value)
    }
}
impl SetExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                elts: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct ListCompExpr {
    elt: Option<PyObject>,
    generators: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl ListCompExpr {
    #[getter]
    fn elt(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.elt {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_elt(this)
    }
    #[getter]
    fn generators(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.generators {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_generators(this)
    }
    fn load_elt(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprListComp>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.elt, this.projection)?;
        cache_value(&mut this.elt, py, value)
    }
    fn load_generators(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprListComp>(&store, node_id)?;
        let value = map_tuple(py, ast.generators.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.generators, py, value)
    }
}
impl ListCompExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                elt: None,
                generators: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct SetCompExpr {
    elt: Option<PyObject>,
    generators: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl SetCompExpr {
    #[getter]
    fn elt(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.elt {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_elt(this)
    }
    #[getter]
    fn generators(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.generators {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_generators(this)
    }
    fn load_elt(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprSetComp>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.elt, this.projection)?;
        cache_value(&mut this.elt, py, value)
    }
    fn load_generators(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprSetComp>(&store, node_id)?;
        let value = map_tuple(py, ast.generators.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.generators, py, value)
    }
}
impl SetCompExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                elt: None,
                generators: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct DictCompExpr {
    key: Option<PyObject>,
    value: Option<PyObject>,
    generators: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl DictCompExpr {
    #[getter]
    fn key(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.key {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_key(this)
    }
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    #[getter]
    fn generators(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.generators {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_generators(this)
    }
    fn load_key(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprDictComp>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.key, this.projection)?;
        cache_value(&mut this.key, py, value)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprDictComp>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.value, this.projection)?;
        cache_value(&mut this.value, py, value)
    }
    fn load_generators(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprDictComp>(&store, node_id)?;
        let value = map_tuple(py, ast.generators.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.generators, py, value)
    }
}
impl DictCompExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                key: None,
                value: None,
                generators: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct GeneratorExpr {
    elt: Option<PyObject>,
    generators: Option<PyObject>,
    parenthesized: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl GeneratorExpr {
    #[getter]
    fn elt(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.elt {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_elt(this)
    }
    #[getter]
    fn generators(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.generators {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_generators(this)
    }
    #[getter]
    fn parenthesized(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.parenthesized.as_ref().unwrap().clone_ref(py))
    }
    fn load_elt(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprGenerator>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.elt, this.projection)?;
        cache_value(&mut this.elt, py, value)
    }
    fn load_generators(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprGenerator>(&store, node_id)?;
        let value = map_tuple(py, ast.generators.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.generators, py, value)
    }
}
impl GeneratorExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        parenthesized: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                elt: None,
                generators: None,
                parenthesized: Some(parenthesized),
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        parenthesized: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py,
            kind,
            span,
            text,
            repr_value,
            node_id,
            store,
            parenthesized,
            locator,
            projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct AwaitExpr {
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl AwaitExpr {
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprAwait>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.value, this.projection)?;
        cache_value(&mut this.value, py, value)
    }
}
impl AwaitExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct YieldExpr {
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl YieldExpr {
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprYield>(&store, node_id)?;
        let value = map_option(py, ast.value.as_ref(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.value, py, value)
    }
}
impl YieldExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct YieldFromExpr {
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl YieldFromExpr {
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprYieldFrom>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.value, this.projection)?;
        cache_value(&mut this.value, py, value)
    }
}
impl YieldFromExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct CompareExpr {
    left: Option<PyObject>,
    ops: Option<PyObject>,
    comparators: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl CompareExpr {
    #[getter]
    fn left(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.left {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_left(this)
    }
    #[getter]
    fn ops(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.ops.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn comparators(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.comparators {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_comparators(this)
    }
    fn load_left(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprCompare>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.left, this.projection)?;
        cache_value(&mut this.left, py, value)
    }
    fn load_comparators(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprCompare>(&store, node_id)?;
        let value = map_tuple(py, ast.comparators.iter(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.comparators, py, value)
    }
}
impl CompareExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        ops: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                left: None,
                ops: Some(ops),
                comparators: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        ops: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, ops, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct CallExpr {
    func: Option<PyObject>,
    arguments: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
    callee: Option<String>,
    function_text: Option<String>,
    function_kind: Option<String>,
}
#[pymethods]
impl CallExpr {
    #[getter]
    fn func(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.func {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_func(this)
    }
    #[getter]
    fn arguments(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.arguments.as_ref().unwrap().clone_ref(py))
    }
    fn load_func(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprCall>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.func, this.projection)?;
        cache_value(&mut this.func, py, value)
    }
    #[getter]
    fn callee(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(optional_str(py, self.callee.as_deref()))
    }
    #[getter]
    fn function_text(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(optional_str(py, self.function_text.as_deref()))
    }
    #[getter]
    fn function_kind(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(optional_str(py, self.function_kind.as_deref()))
    }
}
impl CallExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        arguments: PyObject,
        callee: Option<String>,
        function_text: Option<String>,
        function_kind: Option<String>,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                func: None,
                arguments: Some(arguments),
                locator,
                projection,
                callee,
                function_text,
                function_kind,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        arguments: PyObject,
        callee: Option<String>,
        function_text: Option<String>,
        function_kind: Option<String>,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py,
            kind,
            span,
            text,
            repr_value,
            node_id,
            store,
            arguments,
            callee,
            function_text,
            function_kind,
            locator,
            projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct FStringExpr {
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl FStringExpr {
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let ast = get_ast::<ruff_python_ast::ExprFString>(&store, node_id)?;
        let value = py_string(py, &format!("{value:?}", value = ast.value));
        cache_value(&mut this.value, py, value)
    }
}
impl FStringExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct TStringExpr {
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl TStringExpr {
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let ast = get_ast::<ruff_python_ast::ExprTString>(&store, node_id)?;
        let value = py_string(py, &format!("{value:?}", value = ast.value));
        cache_value(&mut this.value, py, value)
    }
}
impl TStringExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct StringLiteralExpr {
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl StringLiteralExpr {
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let ast = get_ast::<ruff_python_ast::ExprStringLiteral>(&store, node_id)?;
        let value = py_string(py, ast.value.to_str());
        cache_value(&mut this.value, py, value)
    }
}
impl StringLiteralExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct BytesLiteralExpr {
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl BytesLiteralExpr {
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let ast = get_ast::<ruff_python_ast::ExprBytesLiteral>(&store, node_id)?;
        let value = py_string(py, &format!("{value:?}", value = ast.value));
        cache_value(&mut this.value, py, value)
    }
}
impl BytesLiteralExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct NumberLiteralExpr {
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl NumberLiteralExpr {
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let value = py_none(py);
        cache_value(&mut this.value, py, value)
    }
}
impl NumberLiteralExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct BooleanLiteralExpr {
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl BooleanLiteralExpr {
    #[getter]
    fn value(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.value.as_ref().unwrap().clone_ref(py))
    }
}
impl BooleanLiteralExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        value: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                value: Some(value),
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        value: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, value, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct NoneLiteralExpr {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl NoneLiteralExpr {}
impl NoneLiteralExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct EllipsisLiteralExpr {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl EllipsisLiteralExpr {}
impl EllipsisLiteralExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct AttributeExpr {
    value: Option<PyObject>,
    attr: Option<PyObject>,
    ctx: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl AttributeExpr {
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    #[getter]
    fn attr(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.attr.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn ctx(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.ctx.as_ref().unwrap().clone_ref(py))
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprAttribute>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.value, this.projection)?;
        cache_value(&mut this.value, py, value)
    }
}
impl AttributeExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        attr: PyObject,
        ctx: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                value: None,
                attr: Some(attr),
                ctx: Some(ctx),
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        attr: PyObject,
        ctx: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, attr, ctx, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct SubscriptExpr {
    value: Option<PyObject>,
    slice: Option<PyObject>,
    ctx: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl SubscriptExpr {
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    #[getter]
    fn slice(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.slice {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_slice(this)
    }
    #[getter]
    fn ctx(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.ctx.as_ref().unwrap().clone_ref(py))
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprSubscript>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.value, this.projection)?;
        cache_value(&mut this.value, py, value)
    }
    fn load_slice(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprSubscript>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.slice, this.projection)?;
        cache_value(&mut this.slice, py, value)
    }
}
impl SubscriptExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        ctx: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                value: None,
                slice: None,
                ctx: Some(ctx),
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        ctx: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, ctx, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct StarredExpr {
    value: Option<PyObject>,
    ctx: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl StarredExpr {
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    #[getter]
    fn ctx(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.ctx.as_ref().unwrap().clone_ref(py))
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprStarred>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.value, this.projection)?;
        cache_value(&mut this.value, py, value)
    }
}
impl StarredExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        ctx: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                value: None,
                ctx: Some(ctx),
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        ctx: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, ctx, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct NameExpr {
    id: Option<PyObject>,
    ctx: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl NameExpr {
    #[getter]
    fn id(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.id {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_id(this)
    }
    #[getter]
    fn ctx(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.ctx.as_ref().unwrap().clone_ref(py))
    }
    fn load_id(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let ast = get_ast::<ruff_python_ast::ExprName>(&store, node_id)?;
        let value = py_string(py, ast.id.as_str());
        cache_value(&mut this.id, py, value)
    }
}
impl NameExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        ctx: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                id: None,
                ctx: Some(ctx),
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        ctx: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, ctx, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct ListExpr {
    elts: Option<PyObject>,
    ctx: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl ListExpr {
    #[getter]
    fn elts(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.elts {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_elts(this)
    }
    #[getter]
    fn ctx(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.ctx.as_ref().unwrap().clone_ref(py))
    }
    fn load_elts(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprList>(&store, node_id)?;
        let value = map_tuple(py, ast.elts.iter(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.elts, py, value)
    }
}
impl ListExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        ctx: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                elts: None,
                ctx: Some(ctx),
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        ctx: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, ctx, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct TupleExpr {
    elts: Option<PyObject>,
    ctx: Option<PyObject>,
    parenthesized: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl TupleExpr {
    #[getter]
    fn elts(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.elts {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_elts(this)
    }
    #[getter]
    fn ctx(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.ctx.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn parenthesized(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.parenthesized.as_ref().unwrap().clone_ref(py))
    }
    fn load_elts(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprTuple>(&store, node_id)?;
        let value = map_tuple(py, ast.elts.iter(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.elts, py, value)
    }
}
impl TupleExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        ctx: PyObject,
        parenthesized: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                elts: None,
                ctx: Some(ctx),
                parenthesized: Some(parenthesized),
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        ctx: PyObject,
        parenthesized: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py,
            kind,
            span,
            text,
            repr_value,
            node_id,
            store,
            ctx,
            parenthesized,
            locator,
            projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct SliceExpr {
    lower: Option<PyObject>,
    upper: Option<PyObject>,
    step: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl SliceExpr {
    #[getter]
    fn lower(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.lower {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_lower(this)
    }
    #[getter]
    fn upper(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.upper {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_upper(this)
    }
    #[getter]
    fn step(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.step {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_step(this)
    }
    fn load_lower(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprSlice>(&store, node_id)?;
        let value = map_option(py, ast.lower.as_ref(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.lower, py, value)
    }
    fn load_upper(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprSlice>(&store, node_id)?;
        let value = map_option(py, ast.upper.as_ref(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.upper, py, value)
    }
    fn load_step(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ExprSlice>(&store, node_id)?;
        let value = map_option(py, ast.step.as_ref(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.step, py, value)
    }
}
impl SliceExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                lower: None,
                upper: None,
                step: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct IpyEscapeCommandExpr {
    kind: Option<PyObject>,
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl IpyEscapeCommandExpr {
    #[getter]
    fn kind(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.kind.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let ast = get_ast::<ruff_python_ast::ExprIpyEscapeCommand>(&store, node_id)?;
        let value = py_string(py, ast.value.as_ref());
        cache_value(&mut this.value, py, value)
    }
}
impl IpyEscapeCommandExpr {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        kind_field: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                kind: Some(kind_field),
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        kind_field: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, kind_field, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct ExceptHandler {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl ExceptHandler {}
impl ExceptHandler {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct InterpolatedElement {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl InterpolatedElement {}
impl InterpolatedElement {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct InterpolatedStringLiteralElement {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl InterpolatedStringLiteralElement {}
impl InterpolatedStringLiteralElement {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct MatchValuePattern {
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl MatchValuePattern {
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::PatternMatchValue>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.value, this.projection)?;
        cache_value(&mut this.value, py, value)
    }
}
impl MatchValuePattern {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct MatchSingletonPattern {
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl MatchSingletonPattern {
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let value = py_none(py);
        cache_value(&mut this.value, py, value)
    }
}
impl MatchSingletonPattern {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct MatchSequencePattern {
    patterns: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl MatchSequencePattern {
    #[getter]
    fn patterns(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.patterns {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_patterns(this)
    }
    fn load_patterns(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::PatternMatchSequence>(&store, node_id)?;
        let value = map_tuple(py, ast.patterns.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.patterns, py, value)
    }
}
impl MatchSequencePattern {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                patterns: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct MatchMappingPattern {
    keys: Option<PyObject>,
    patterns: Option<PyObject>,
    rest: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl MatchMappingPattern {
    #[getter]
    fn keys(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.keys {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_keys(this)
    }
    #[getter]
    fn patterns(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.patterns {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_patterns(this)
    }
    #[getter]
    fn rest(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.rest.as_ref().unwrap().clone_ref(py))
    }
    fn load_keys(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::PatternMatchMapping>(&store, node_id)?;
        let value = map_tuple(py, ast.keys.iter(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.keys, py, value)
    }
    fn load_patterns(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::PatternMatchMapping>(&store, node_id)?;
        let value = map_tuple(py, ast.patterns.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.patterns, py, value)
    }
}
impl MatchMappingPattern {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        rest: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                keys: None,
                patterns: None,
                rest: Some(rest),
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        rest: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, rest, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct MatchClassPattern {
    cls: Option<PyObject>,
    arguments: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl MatchClassPattern {
    #[getter]
    fn cls(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.cls {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_cls(this)
    }
    #[getter]
    fn arguments(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.arguments {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_arguments(this)
    }
    fn load_cls(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::PatternMatchClass>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.cls, this.projection)?;
        cache_value(&mut this.cls, py, value)
    }
    fn load_arguments(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::PatternMatchClass>(&store, node_id)?;
        let value = node_to_python(
            py,
            &locator,
            AnyNodeRef::from(&ast.arguments),
            this.projection,
        )?;
        cache_value(&mut this.arguments, py, value)
    }
}
impl MatchClassPattern {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                cls: None,
                arguments: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct MatchStarPattern {
    name: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl MatchStarPattern {
    #[getter]
    fn name(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.name.as_ref().unwrap().clone_ref(py))
    }
}
impl MatchStarPattern {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        name: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                name: Some(name),
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        name: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, name, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct MatchAsPattern {
    pattern: Option<PyObject>,
    name: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl MatchAsPattern {
    #[getter]
    fn pattern(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.pattern {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_pattern(this)
    }
    #[getter]
    fn name(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.name.as_ref().unwrap().clone_ref(py))
    }
    fn load_pattern(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::PatternMatchAs>(&store, node_id)?;
        let value = map_option(py, ast.pattern.as_ref(), |value| {
            node_to_python(
                py,
                &locator,
                AnyNodeRef::from(value.as_ref()),
                this.projection,
            )
        })?;
        cache_value(&mut this.pattern, py, value)
    }
}
impl MatchAsPattern {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        name: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                pattern: None,
                name: Some(name),
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        name: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, name, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct MatchOrPattern {
    patterns: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl MatchOrPattern {
    #[getter]
    fn patterns(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.patterns {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_patterns(this)
    }
    fn load_patterns(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::PatternMatchOr>(&store, node_id)?;
        let value = map_tuple(py, ast.patterns.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.patterns, py, value)
    }
}
impl MatchOrPattern {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                patterns: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct TypeVar {
    name: Option<PyObject>,
    bound: Option<PyObject>,
    default: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl TypeVar {
    #[getter]
    fn name(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.name.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn bound(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.bound {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_bound(this)
    }
    #[getter]
    fn default(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.default {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_default(this)
    }
    fn load_bound(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::TypeParamTypeVar>(&store, node_id)?;
        let value = map_option(py, ast.bound.as_ref(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.bound, py, value)
    }
    fn load_default(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::TypeParamTypeVar>(&store, node_id)?;
        let value = map_option(py, ast.default.as_ref(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.default, py, value)
    }
}
impl TypeVar {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        name: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                name: Some(name),
                bound: None,
                default: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        name: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, name, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct TypeVarTuple {
    name: Option<PyObject>,
    default: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl TypeVarTuple {
    #[getter]
    fn name(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.name.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn default(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.default {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_default(this)
    }
    fn load_default(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::TypeParamTypeVarTuple>(&store, node_id)?;
        let value = map_option(py, ast.default.as_ref(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.default, py, value)
    }
}
impl TypeVarTuple {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        name: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                name: Some(name),
                default: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        name: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, name, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct ParamSpec {
    name: Option<PyObject>,
    default: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl ParamSpec {
    #[getter]
    fn name(&self, py: Python<'_>) -> PyResult<PyObject> {
        Ok(self.name.as_ref().unwrap().clone_ref(py))
    }
    #[getter]
    fn default(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.default {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_default(this)
    }
    fn load_default(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::TypeParamParamSpec>(&store, node_id)?;
        let value = map_option(py, ast.default.as_ref(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.default, py, value)
    }
}
impl ParamSpec {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        name: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                name: Some(name),
                default: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        name: PyObject,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, name, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct InterpolatedStringFormatSpec {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl InterpolatedStringFormatSpec {}
impl InterpolatedStringFormatSpec {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct PatternArguments {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl PatternArguments {}
impl PatternArguments {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct PatternKeyword {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl PatternKeyword {}
impl PatternKeyword {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct Comprehension {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl Comprehension {}
impl Comprehension {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct Parameters {
    posonlyargs: Option<PyObject>,
    args: Option<PyObject>,
    vararg: Option<PyObject>,
    kwonlyargs: Option<PyObject>,
    kwarg: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl Parameters {
    #[getter]
    fn posonlyargs(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.posonlyargs {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_posonlyargs(this)
    }
    #[getter]
    fn args(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.args {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_args(this)
    }
    #[getter]
    fn vararg(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.vararg {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_vararg(this)
    }
    #[getter]
    fn kwonlyargs(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.kwonlyargs {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_kwonlyargs(this)
    }
    #[getter]
    fn kwarg(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.kwarg {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_kwarg(this)
    }
    fn load_posonlyargs(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::Parameters>(&store, node_id)?;
        let value = map_tuple(py, ast.posonlyargs.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.posonlyargs, py, value)
    }
    fn load_args(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::Parameters>(&store, node_id)?;
        let value = map_tuple(py, ast.args.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.args, py, value)
    }
    fn load_vararg(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::Parameters>(&store, node_id)?;
        let value = map_option(py, ast.vararg.as_ref(), |value| {
            node_to_python(
                py,
                &locator,
                AnyNodeRef::from(value.as_ref()),
                this.projection,
            )
        })?;
        cache_value(&mut this.vararg, py, value)
    }
    fn load_kwonlyargs(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::Parameters>(&store, node_id)?;
        let value = map_tuple(py, ast.kwonlyargs.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.kwonlyargs, py, value)
    }
    fn load_kwarg(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::Parameters>(&store, node_id)?;
        let value = map_option(py, ast.kwarg.as_ref(), |value| {
            node_to_python(
                py,
                &locator,
                AnyNodeRef::from(value.as_ref()),
                this.projection,
            )
        })?;
        cache_value(&mut this.kwarg, py, value)
    }
}
impl Parameters {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                posonlyargs: None,
                args: None,
                vararg: None,
                kwonlyargs: None,
                kwarg: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct Parameter {
    name: Option<PyObject>,
    annotation: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl Parameter {
    #[getter]
    fn name(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.name {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_name(this)
    }
    #[getter]
    fn annotation(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.annotation {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_annotation(this)
    }
    fn load_name(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let ast = get_ast::<ruff_python_ast::Parameter>(&store, node_id)?;
        let value = py_string(py, ast.name.as_str());
        cache_value(&mut this.name, py, value)
    }
    fn load_annotation(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::Parameter>(&store, node_id)?;
        let value = map_option(py, ast.annotation.as_ref(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.annotation, py, value)
    }
}
impl Parameter {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                name: None,
                annotation: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct ParameterWithDefault {
    parameter: Option<PyObject>,
    default: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl ParameterWithDefault {
    #[getter]
    fn parameter(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.parameter {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_parameter(this)
    }
    #[getter]
    fn default(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.default {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_default(this)
    }
    fn load_parameter(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ParameterWithDefault>(&store, node_id)?;
        let value = node_to_python(
            py,
            &locator,
            AnyNodeRef::from(&ast.parameter),
            this.projection,
        )?;
        cache_value(&mut this.parameter, py, value)
    }
    fn load_default(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::ParameterWithDefault>(&store, node_id)?;
        let value = map_option(py, ast.default.as_ref(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.default, py, value)
    }
}
impl ParameterWithDefault {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                parameter: None,
                default: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct Alias {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl Alias {}
impl Alias {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct WithItem {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl WithItem {}
impl WithItem {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct MatchCase {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl MatchCase {}
impl MatchCase {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct Decorator {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl Decorator {}
impl Decorator {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct ElifElseClause {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl ElifElseClause {}
impl ElifElseClause {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct TypeParams {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl TypeParams {}
impl TypeParams {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct FString {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl FString {}
impl FString {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct TString {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl TString {}
impl TString {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct StringLiteral {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl StringLiteral {}
impl StringLiteral {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct BytesLiteral {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl BytesLiteral {}
impl BytesLiteral {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct Identifier {
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl Identifier {}
impl Identifier {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct Arguments {
    args: Option<PyObject>,
    keywords: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl Arguments {
    #[getter]
    fn args(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.args {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_args(this)
    }
    #[getter]
    fn keywords(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.keywords {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_keywords(this)
    }
    fn load_args(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::Arguments>(&store, node_id)?;
        let value = map_tuple(py, ast.args.iter(), |value| {
            expr_to_python(py, &locator, value, this.projection)
        })?;
        cache_value(&mut this.args, py, value)
    }
    fn load_keywords(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::Arguments>(&store, node_id)?;
        let value = map_tuple(py, ast.keywords.iter(), |value| {
            node_to_python(py, &locator, AnyNodeRef::from(value), this.projection)
        })?;
        cache_value(&mut this.keywords, py, value)
    }
}
impl Arguments {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                args: None,
                keywords: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
#[pyclass(module = "ruff_external", extends = bindings::Node, unsendable)]
pub(crate) struct Keyword {
    arg: Option<PyObject>,
    value: Option<PyObject>,
    #[allow(dead_code)]
    locator: SourceFileHandle,
    #[allow(dead_code)]
    projection: ProjectionTypesRef,
}
#[pymethods]
impl Keyword {
    #[getter]
    fn arg(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.arg {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_arg(this)
    }
    #[getter]
    fn value(this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        if let Some(value) = &this.value {
            return Ok(value.clone_ref(this.py()));
        }
        Self::load_value(this)
    }
    fn load_arg(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let ast = get_ast::<ruff_python_ast::Keyword>(&store, node_id)?;
        let value = optional_str(
            py,
            ast.arg.as_ref().map(ruff_python_ast::Identifier::as_str),
        );
        cache_value(&mut this.arg, py, value)
    }
    fn load_value(mut this: PyRefMut<'_, Self>) -> PyResult<PyObject> {
        let py = this.py();
        let (node_id, store) = {
            let super_ = this.as_super();
            (super_.node_id(), super_.store().clone())
        };
        let locator = this.locator.locator();
        let ast = get_ast::<ruff_python_ast::Keyword>(&store, node_id)?;
        let value = expr_to_python(py, &locator, &ast.value, this.projection)?;
        cache_value(&mut this.value, py, value)
    }
}
impl Keyword {
    #[allow(clippy::too_many_arguments)]
    fn init_parts(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> (Self, bindings::Node) {
        (
            Self {
                arg: None,
                value: None,
                locator,
                projection,
            },
            bindings::Node::new_inner(py, kind, span, text, repr_value, node_id, store),
        )
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn new_instance(
        py: Python<'_>,
        kind: String,
        span: PyObject,
        text: String,
        repr_value: String,
        node_id: u32,
        store: AstStoreHandle,
        locator: SourceFileHandle,
        projection: ProjectionTypesRef,
    ) -> PyResult<PyObject> {
        let (this, node) = Self::init_parts(
            py, kind, span, text, repr_value, node_id, store, locator, projection,
        );
        let initializer = PyClassInitializer::from(node).add_subclass(this);
        Ok(Py::new(py, initializer)?.into_any())
    }
}
