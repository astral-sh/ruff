---
source: crates/ruff_linter/src/rules/flake8_pyi/mod.rs
---
PYI034 [*] `__new__` methods in classes like `Bad` usually return `self` at runtime
  --> PYI034.py:21:9
   |
19 |     object
20 | ):  # Y040 Do not inherit from "object" explicitly, as it is redundant in Python 3
21 |     def __new__(cls, *args: Any, **kwargs: Any) -> Bad:
   |         ^^^^^^^
22 |         ...  # Y034 "__new__" methods usually return "self" at runtime. Consider using "typing_extensions.Self" in "Bad.__new__", e.g.…
   |
help: Use `Self` as return type
18 | class Bad(
19 |     object
20 | ):  # Y040 Do not inherit from "object" explicitly, as it is redundant in Python 3
   -     def __new__(cls, *args: Any, **kwargs: Any) -> Bad:
21 +     def __new__(cls, *args: Any, **kwargs: Any) -> typing.Self:
22 |         ...  # Y034 "__new__" methods usually return "self" at runtime. Consider using "typing_extensions.Self" in "Bad.__new__", e.g. "def __new__(cls, *args: Any, **kwargs: Any) -> Self: ..."
23 | 
24 |     def __repr__(self) -> str:
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__enter__` methods in classes like `Bad` usually return `self` at runtime
  --> PYI034.py:36:9
   |
34 |         ...  # Y032 Prefer "object" to "Any" for the second parameter in "__ne__" methods
35 |
36 |     def __enter__(self) -> Bad:
   |         ^^^^^^^^^
37 |         ...  # Y034 "__enter__" methods in classes like "Bad" usually return "self" at runtime. Consider using "typing_extensions.Self…
   |
help: Use `Self` as return type
33 |     def __ne__(self, other: typing.Any) -> typing.Any:
34 |         ...  # Y032 Prefer "object" to "Any" for the second parameter in "__ne__" methods
35 | 
   -     def __enter__(self) -> Bad:
36 +     def __enter__(self) -> typing.Self:
37 |         ...  # Y034 "__enter__" methods in classes like "Bad" usually return "self" at runtime. Consider using "typing_extensions.Self" in "Bad.__enter__", e.g. "def __enter__(self) -> Self: ..."
38 | 
39 |     async def __aenter__(self) -> Bad:
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__aenter__` methods in classes like `Bad` usually return `self` at runtime
  --> PYI034.py:39:15
   |
37 |         ...  # Y034 "__enter__" methods in classes like "Bad" usually return "self" at runtime. Consider using "typing_extensions.Self…
38 |
39 |     async def __aenter__(self) -> Bad:
   |               ^^^^^^^^^^
40 |         ...  # Y034 "__aenter__" methods in classes like "Bad" usually return "self" at runtime. Consider using "typing_extensions.Sel…
   |
help: Use `Self` as return type
36 |     def __enter__(self) -> Bad:
37 |         ...  # Y034 "__enter__" methods in classes like "Bad" usually return "self" at runtime. Consider using "typing_extensions.Self" in "Bad.__enter__", e.g. "def __enter__(self) -> Self: ..."
38 | 
   -     async def __aenter__(self) -> Bad:
39 +     async def __aenter__(self) -> typing.Self:
40 |         ...  # Y034 "__aenter__" methods in classes like "Bad" usually return "self" at runtime. Consider using "typing_extensions.Self" in "Bad.__aenter__", e.g. "async def __aenter__(self) -> Self: ..."
41 | 
42 |     def __iadd__(self, other: Bad) -> Bad:
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__iadd__` methods in classes like `Bad` usually return `self` at runtime
  --> PYI034.py:42:9
   |
40 |         ...  # Y034 "__aenter__" methods in classes like "Bad" usually return "self" at runtime. Consider using "typing_extensions.Sel…
41 |
42 |     def __iadd__(self, other: Bad) -> Bad:
   |         ^^^^^^^^
43 |         ...  # Y034 "__iadd__" methods in classes like "Bad" usually return "self" at runtime. Consider using "typing_extensions.Self"…
   |
help: Use `Self` as return type
39 |     async def __aenter__(self) -> Bad:
40 |         ...  # Y034 "__aenter__" methods in classes like "Bad" usually return "self" at runtime. Consider using "typing_extensions.Self" in "Bad.__aenter__", e.g. "async def __aenter__(self) -> Self: ..."
41 | 
   -     def __iadd__(self, other: Bad) -> Bad:
42 +     def __iadd__(self, other: Bad) -> typing.Self:
43 |         ...  # Y034 "__iadd__" methods in classes like "Bad" usually return "self" at runtime. Consider using "typing_extensions.Self" in "Bad.__iadd__", e.g. "def __iadd__(self, other: Bad) -> Self: ..."
44 | 
45 | 
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__iter__` methods in classes like `BadIterator1` usually return `self` at runtime
   --> PYI034.py:165:9
    |
164 | class BadIterator1(Iterator[int]):
165 |     def __iter__(self) -> Iterator[int]:
    |         ^^^^^^^^
166 |         ...  # Y034 "__iter__" methods in classes like "BadIterator1" usually return "self" at runtime. Consider using "typing_extens…
    |
help: Use `Self` as return type
162 | 
163 | 
164 | class BadIterator1(Iterator[int]):
    -     def __iter__(self) -> Iterator[int]:
165 +     def __iter__(self) -> typing.Self:
166 |         ...  # Y034 "__iter__" methods in classes like "BadIterator1" usually return "self" at runtime. Consider using "typing_extensions.Self" in "BadIterator1.__iter__", e.g. "def __iter__(self) -> Self: ..."
167 | 
168 | 
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__iter__` methods in classes like `BadIterator2` usually return `self` at runtime
   --> PYI034.py:172:9
    |
170 |     typing.Iterator[int]
171 | ):  # Y022 Use "collections.abc.Iterator[T]" instead of "typing.Iterator[T]" (PEP 585 syntax)
172 |     def __iter__(self) -> Iterator[int]:
    |         ^^^^^^^^
173 |         ...  # Y034 "__iter__" methods in classes like "BadIterator2" usually return "self" at runtime. Consider using "typing_extens…
    |
help: Use `Self` as return type
169 | class BadIterator2(
170 |     typing.Iterator[int]
171 | ):  # Y022 Use "collections.abc.Iterator[T]" instead of "typing.Iterator[T]" (PEP 585 syntax)
    -     def __iter__(self) -> Iterator[int]:
172 +     def __iter__(self) -> typing.Self:
173 |         ...  # Y034 "__iter__" methods in classes like "BadIterator2" usually return "self" at runtime. Consider using "typing_extensions.Self" in "BadIterator2.__iter__", e.g. "def __iter__(self) -> Self: ..."
174 | 
175 | 
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__iter__` methods in classes like `BadIterator3` usually return `self` at runtime
   --> PYI034.py:179:9
    |
177 |     typing.Iterator[int]
178 | ):  # Y022 Use "collections.abc.Iterator[T]" instead of "typing.Iterator[T]" (PEP 585 syntax)
179 |     def __iter__(self) -> collections.abc.Iterator[int]:
    |         ^^^^^^^^
180 |         ...  # Y034 "__iter__" methods in classes like "BadIterator3" usually return "self" at runtime. Consider using "typing_extens…
    |
help: Use `Self` as return type
176 | class BadIterator3(
177 |     typing.Iterator[int]
178 | ):  # Y022 Use "collections.abc.Iterator[T]" instead of "typing.Iterator[T]" (PEP 585 syntax)
    -     def __iter__(self) -> collections.abc.Iterator[int]:
179 +     def __iter__(self) -> typing.Self:
180 |         ...  # Y034 "__iter__" methods in classes like "BadIterator3" usually return "self" at runtime. Consider using "typing_extensions.Self" in "BadIterator3.__iter__", e.g. "def __iter__(self) -> Self: ..."
181 | 
182 | 
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__iter__` methods in classes like `BadIterator4` usually return `self` at runtime
   --> PYI034.py:185:9
    |
183 | class BadIterator4(Iterator[int]):
184 |     # Note: *Iterable*, not *Iterator*, returned!
185 |     def __iter__(self) -> Iterable[int]:
    |         ^^^^^^^^
186 |         ...  # Y034 "__iter__" methods in classes like "BadIterator4" usually return "self" at runtime. Consider using "typing_extens…
    |
help: Use `Self` as return type
182 | 
183 | class BadIterator4(Iterator[int]):
184 |     # Note: *Iterable*, not *Iterator*, returned!
    -     def __iter__(self) -> Iterable[int]:
185 +     def __iter__(self) -> typing.Self:
186 |         ...  # Y034 "__iter__" methods in classes like "BadIterator4" usually return "self" at runtime. Consider using "typing_extensions.Self" in "BadIterator4.__iter__", e.g. "def __iter__(self) -> Self: ..."
187 | 
188 | 
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__aiter__` methods in classes like `BadAsyncIterator` usually return `self` at runtime
   --> PYI034.py:195:9
    |
194 | class BadAsyncIterator(collections.abc.AsyncIterator[str]):
195 |     def __aiter__(self) -> typing.AsyncIterator[str]:
    |         ^^^^^^^^^
196 |         ...  # Y034 "__aiter__" methods in classes like "BadAsyncIterator" usually return "self" at runtime. Consider using "typing_e…
    |
help: Use `Self` as return type
192 | 
193 | 
194 | class BadAsyncIterator(collections.abc.AsyncIterator[str]):
    -     def __aiter__(self) -> typing.AsyncIterator[str]:
195 +     def __aiter__(self) -> typing.Self:
196 |         ...  # Y034 "__aiter__" methods in classes like "BadAsyncIterator" usually return "self" at runtime. Consider using "typing_extensions.Self" in "BadAsyncIterator.__aiter__", e.g. "def __aiter__(self) -> Self: ..."  # Y022 Use "collections.abc.AsyncIterator[T]" instead of "typing.AsyncIterator[T]" (PEP 585 syntax)
197 | 
198 | class SubclassOfBadIterator3(BadIterator3):
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__iter__` methods in classes like `SubclassOfBadIterator3` usually return `self` at runtime
   --> PYI034.py:199:9
    |
198 | class SubclassOfBadIterator3(BadIterator3):
199 |     def __iter__(self) -> Iterator[int]:  # Y034
    |         ^^^^^^^^
200 |         ...
    |
help: Use `Self` as return type
196 |         ...  # Y034 "__aiter__" methods in classes like "BadAsyncIterator" usually return "self" at runtime. Consider using "typing_extensions.Self" in "BadAsyncIterator.__aiter__", e.g. "def __aiter__(self) -> Self: ..."  # Y022 Use "collections.abc.AsyncIterator[T]" instead of "typing.AsyncIterator[T]" (PEP 585 syntax)
197 | 
198 | class SubclassOfBadIterator3(BadIterator3):
    -     def __iter__(self) -> Iterator[int]:  # Y034
199 +     def __iter__(self) -> typing.Self:  # Y034
200 |         ...
201 | 
202 | class SubclassOfBadAsyncIterator(BadAsyncIterator):
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__aiter__` methods in classes like `SubclassOfBadAsyncIterator` usually return `self` at runtime
   --> PYI034.py:203:9
    |
202 | class SubclassOfBadAsyncIterator(BadAsyncIterator):
203 |     def __aiter__(self) -> collections.abc.AsyncIterator[str]:  # Y034
    |         ^^^^^^^^^
204 |         ...
    |
help: Use `Self` as return type
200 |         ...
201 | 
202 | class SubclassOfBadAsyncIterator(BadAsyncIterator):
    -     def __aiter__(self) -> collections.abc.AsyncIterator[str]:  # Y034
203 +     def __aiter__(self) -> typing.Self:  # Y034
204 |         ...
205 | 
206 | class AsyncIteratorReturningAsyncIterable:
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__new__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime
   --> PYI034.py:327:9
    |
326 | class UsesStringizedForwardReferences:
327 |     def __new__(cls) -> "UsesStringizedForwardReferences": ...       # PYI034
    |         ^^^^^^^
328 |     def __enter__(self) -> "UsesStringizedForwardReferences": ...    # PYI034
329 |     async def __aenter__(self) -> "UsesStringizedForwardReferences": ...  # PYI034
    |
help: Use `Self` as return type
324 | 
325 | 
326 | class UsesStringizedForwardReferences:
    -     def __new__(cls) -> "UsesStringizedForwardReferences": ...       # PYI034
327 +     def __new__(cls) -> typing.Self: ...       # PYI034
328 |     def __enter__(self) -> "UsesStringizedForwardReferences": ...    # PYI034
329 |     async def __aenter__(self) -> "UsesStringizedForwardReferences": ...  # PYI034
330 |     def __iadd__(self, other) -> "UsesStringizedForwardReferences": ...  # PYI034
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__enter__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime
   --> PYI034.py:328:9
    |
326 | class UsesStringizedForwardReferences:
327 |     def __new__(cls) -> "UsesStringizedForwardReferences": ...       # PYI034
328 |     def __enter__(self) -> "UsesStringizedForwardReferences": ...    # PYI034
    |         ^^^^^^^^^
329 |     async def __aenter__(self) -> "UsesStringizedForwardReferences": ...  # PYI034
330 |     def __iadd__(self, other) -> "UsesStringizedForwardReferences": ...  # PYI034
    |
help: Use `Self` as return type
325 | 
326 | class UsesStringizedForwardReferences:
327 |     def __new__(cls) -> "UsesStringizedForwardReferences": ...       # PYI034
    -     def __enter__(self) -> "UsesStringizedForwardReferences": ...    # PYI034
328 +     def __enter__(self) -> typing.Self: ...    # PYI034
329 |     async def __aenter__(self) -> "UsesStringizedForwardReferences": ...  # PYI034
330 |     def __iadd__(self, other) -> "UsesStringizedForwardReferences": ...  # PYI034
331 | 
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__aenter__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime
   --> PYI034.py:329:15
    |
327 |     def __new__(cls) -> "UsesStringizedForwardReferences": ...       # PYI034
328 |     def __enter__(self) -> "UsesStringizedForwardReferences": ...    # PYI034
329 |     async def __aenter__(self) -> "UsesStringizedForwardReferences": ...  # PYI034
    |               ^^^^^^^^^^
330 |     def __iadd__(self, other) -> "UsesStringizedForwardReferences": ...  # PYI034
    |
help: Use `Self` as return type
326 | class UsesStringizedForwardReferences:
327 |     def __new__(cls) -> "UsesStringizedForwardReferences": ...       # PYI034
328 |     def __enter__(self) -> "UsesStringizedForwardReferences": ...    # PYI034
    -     async def __aenter__(self) -> "UsesStringizedForwardReferences": ...  # PYI034
329 +     async def __aenter__(self) -> typing.Self: ...  # PYI034
330 |     def __iadd__(self, other) -> "UsesStringizedForwardReferences": ...  # PYI034
331 | 
332 | 
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__iadd__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime
   --> PYI034.py:330:9
    |
328 |     def __enter__(self) -> "UsesStringizedForwardReferences": ...    # PYI034
329 |     async def __aenter__(self) -> "UsesStringizedForwardReferences": ...  # PYI034
330 |     def __iadd__(self, other) -> "UsesStringizedForwardReferences": ...  # PYI034
    |         ^^^^^^^^
    |
help: Use `Self` as return type
327 |     def __new__(cls) -> "UsesStringizedForwardReferences": ...       # PYI034
328 |     def __enter__(self) -> "UsesStringizedForwardReferences": ...    # PYI034
329 |     async def __aenter__(self) -> "UsesStringizedForwardReferences": ...  # PYI034
    -     def __iadd__(self, other) -> "UsesStringizedForwardReferences": ...  # PYI034
330 +     def __iadd__(self, other) -> typing.Self: ...  # PYI034
331 | 
332 | 
333 | class NonGeneric1(tuple):
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__new__` methods in classes like `NonGeneric1` usually return `self` at runtime
   --> PYI034.py:334:9
    |
333 | class NonGeneric1(tuple):
334 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...
    |         ^^^^^^^
335 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...
    |
help: Use `Self` as return type
331 | 
332 | 
333 | class NonGeneric1(tuple):
    -     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...
334 +     def __new__(cls, *args, **kwargs) -> typing.Self: ...
335 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...
336 | 
337 | class NonGeneric2(tuple):
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__enter__` methods in classes like `NonGeneric1` usually return `self` at runtime
   --> PYI034.py:335:9
    |
333 | class NonGeneric1(tuple):
334 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...
335 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...
    |         ^^^^^^^^^
336 |
337 | class NonGeneric2(tuple):
    |
help: Use `Self` as return type
332 | 
333 | class NonGeneric1(tuple):
334 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...
    -     def __enter__(self: NonGeneric1) -> NonGeneric1: ...
335 +     def __enter__(self) -> typing.Self: ...
336 | 
337 | class NonGeneric2(tuple):
338 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__new__` methods in classes like `NonGeneric2` usually return `self` at runtime
   --> PYI034.py:338:9
    |
337 | class NonGeneric2(tuple):
338 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...
    |         ^^^^^^^
339 |
340 | class Generic1[T](list):
    |
help: Use `Self` as return type
335 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...
336 | 
337 | class NonGeneric2(tuple):
    -     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...
338 +     def __new__(cls) -> typing.Self: ...
339 | 
340 | class Generic1[T](list):
341 |     def __new__(cls: type[Generic1]) -> Generic1: ...
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__new__` methods in classes like `Generic1` usually return `self` at runtime
   --> PYI034.py:341:9
    |
340 | class Generic1[T](list):
341 |     def __new__(cls: type[Generic1]) -> Generic1: ...
    |         ^^^^^^^
342 |     def __enter__(self: Generic1) -> Generic1: ...
    |
help: Use `Self` as return type
338 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...
339 | 
340 | class Generic1[T](list):
    -     def __new__(cls: type[Generic1]) -> Generic1: ...
341 +     def __new__(cls) -> typing.Self: ...
342 |     def __enter__(self: Generic1) -> Generic1: ...
343 | 
344 | 
note: This is a display-only fix and is likely to be incorrect

PYI034 [*] `__enter__` methods in classes like `Generic1` usually return `self` at runtime
   --> PYI034.py:342:9
    |
340 | class Generic1[T](list):
341 |     def __new__(cls: type[Generic1]) -> Generic1: ...
342 |     def __enter__(self: Generic1) -> Generic1: ...
    |         ^^^^^^^^^
    |
help: Use `Self` as return type
339 | 
340 | class Generic1[T](list):
341 |     def __new__(cls: type[Generic1]) -> Generic1: ...
    -     def __enter__(self: Generic1) -> Generic1: ...
342 +     def __enter__(self) -> typing.Self: ...
343 | 
344 | 
345 | ### Correctness of typevar-likes are not verified.
note: This is a display-only fix and is likely to be incorrect

PYI034 [*] `__new__` methods in classes like `Generic2` usually return `self` at runtime
   --> PYI034.py:352:9
    |
351 | class Generic2(Generic[T]):
352 |     def __new__(cls: type[Generic2]) -> Generic2: ...
    |         ^^^^^^^
353 |     def __enter__(self: Generic2) -> Generic2: ...
    |
help: Use `Self` as return type
349 | Ts = TypeVarTuple('foo')
350 | 
351 | class Generic2(Generic[T]):
    -     def __new__(cls: type[Generic2]) -> Generic2: ...
352 +     def __new__(cls) -> typing.Self: ...
353 |     def __enter__(self: Generic2) -> Generic2: ...
354 | 
355 | class Generic3(tuple[*Ts]):
note: This is a display-only fix and is likely to be incorrect

PYI034 [*] `__enter__` methods in classes like `Generic2` usually return `self` at runtime
   --> PYI034.py:353:9
    |
351 | class Generic2(Generic[T]):
352 |     def __new__(cls: type[Generic2]) -> Generic2: ...
353 |     def __enter__(self: Generic2) -> Generic2: ...
    |         ^^^^^^^^^
354 |
355 | class Generic3(tuple[*Ts]):
    |
help: Use `Self` as return type
350 | 
351 | class Generic2(Generic[T]):
352 |     def __new__(cls: type[Generic2]) -> Generic2: ...
    -     def __enter__(self: Generic2) -> Generic2: ...
353 +     def __enter__(self) -> typing.Self: ...
354 | 
355 | class Generic3(tuple[*Ts]):
356 |     def __new__(cls: type[Generic3]) -> Generic3: ...
note: This is a display-only fix and is likely to be incorrect

PYI034 [*] `__new__` methods in classes like `Generic3` usually return `self` at runtime
   --> PYI034.py:356:9
    |
355 | class Generic3(tuple[*Ts]):
356 |     def __new__(cls: type[Generic3]) -> Generic3: ...
    |         ^^^^^^^
357 |     def __enter__(self: Generic3) -> Generic3: ...
    |
help: Use `Self` as return type
353 |     def __enter__(self: Generic2) -> Generic2: ...
354 | 
355 | class Generic3(tuple[*Ts]):
    -     def __new__(cls: type[Generic3]) -> Generic3: ...
356 +     def __new__(cls) -> typing.Self: ...
357 |     def __enter__(self: Generic3) -> Generic3: ...
358 | 
359 | class Generic4(collections.abc.Callable[P, ...]):
note: This is a display-only fix and is likely to be incorrect

PYI034 [*] `__enter__` methods in classes like `Generic3` usually return `self` at runtime
   --> PYI034.py:357:9
    |
355 | class Generic3(tuple[*Ts]):
356 |     def __new__(cls: type[Generic3]) -> Generic3: ...
357 |     def __enter__(self: Generic3) -> Generic3: ...
    |         ^^^^^^^^^
358 |
359 | class Generic4(collections.abc.Callable[P, ...]):
    |
help: Use `Self` as return type
354 | 
355 | class Generic3(tuple[*Ts]):
356 |     def __new__(cls: type[Generic3]) -> Generic3: ...
    -     def __enter__(self: Generic3) -> Generic3: ...
357 +     def __enter__(self) -> typing.Self: ...
358 | 
359 | class Generic4(collections.abc.Callable[P, ...]):
360 |     def __new__(cls: type[Generic4]) -> Generic4: ...
note: This is a display-only fix and is likely to be incorrect

PYI034 [*] `__new__` methods in classes like `Generic4` usually return `self` at runtime
   --> PYI034.py:360:9
    |
359 | class Generic4(collections.abc.Callable[P, ...]):
360 |     def __new__(cls: type[Generic4]) -> Generic4: ...
    |         ^^^^^^^
361 |     def __enter__(self: Generic4) -> Generic4: ...
    |
help: Use `Self` as return type
357 |     def __enter__(self: Generic3) -> Generic3: ...
358 | 
359 | class Generic4(collections.abc.Callable[P, ...]):
    -     def __new__(cls: type[Generic4]) -> Generic4: ...
360 +     def __new__(cls) -> typing.Self: ...
361 |     def __enter__(self: Generic4) -> Generic4: ...
362 | 
363 | from some_module import PotentialTypeVar
note: This is a display-only fix and is likely to be incorrect

PYI034 [*] `__enter__` methods in classes like `Generic4` usually return `self` at runtime
   --> PYI034.py:361:9
    |
359 | class Generic4(collections.abc.Callable[P, ...]):
360 |     def __new__(cls: type[Generic4]) -> Generic4: ...
361 |     def __enter__(self: Generic4) -> Generic4: ...
    |         ^^^^^^^^^
362 |
363 | from some_module import PotentialTypeVar
    |
help: Use `Self` as return type
358 | 
359 | class Generic4(collections.abc.Callable[P, ...]):
360 |     def __new__(cls: type[Generic4]) -> Generic4: ...
    -     def __enter__(self: Generic4) -> Generic4: ...
361 +     def __enter__(self) -> typing.Self: ...
362 | 
363 | from some_module import PotentialTypeVar
364 | 
note: This is a display-only fix and is likely to be incorrect

PYI034 [*] `__new__` methods in classes like `Generic5` usually return `self` at runtime
   --> PYI034.py:366:9
    |
365 | class Generic5(list[PotentialTypeVar]):
366 |     def __new__(cls: type[Generic5]) -> Generic5: ...
    |         ^^^^^^^
367 |     def __enter__(self: Generic5) -> Generic5: ...
    |
help: Use `Self` as return type
363 | from some_module import PotentialTypeVar
364 | 
365 | class Generic5(list[PotentialTypeVar]):
    -     def __new__(cls: type[Generic5]) -> Generic5: ...
366 +     def __new__(cls) -> typing.Self: ...
367 |     def __enter__(self: Generic5) -> Generic5: ...
368 | 
369 | 
note: This is an unsafe fix and may change runtime behavior

PYI034 [*] `__enter__` methods in classes like `Generic5` usually return `self` at runtime
   --> PYI034.py:367:9
    |
365 | class Generic5(list[PotentialTypeVar]):
366 |     def __new__(cls: type[Generic5]) -> Generic5: ...
367 |     def __enter__(self: Generic5) -> Generic5: ...
    |         ^^^^^^^^^
    |
help: Use `Self` as return type
364 | 
365 | class Generic5(list[PotentialTypeVar]):
366 |     def __new__(cls: type[Generic5]) -> Generic5: ...
    -     def __enter__(self: Generic5) -> Generic5: ...
367 +     def __enter__(self) -> typing.Self: ...
368 | 
369 | 
370 | # Test cases based on issue #20781 - metaclasses that triggers IsMetaclass::Maybe
note: This is an unsafe fix and may change runtime behavior
