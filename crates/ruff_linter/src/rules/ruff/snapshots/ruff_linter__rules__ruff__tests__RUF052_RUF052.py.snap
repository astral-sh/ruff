---
source: crates/ruff_linter/src/rules/ruff/mod.rs
---
RUF052 [*] Local dummy variable `_var` is accessed
   --> RUF052.py:108:9
    |
106 | class Class_:
107 |     def fun(self):
108 |         _var = "method variable" # [RUF052]
    |         ^^^^
109 |         return _var
    |
help: Remove leading underscores
105 | 
106 | class Class_:
107 |     def fun(self):
    -         _var = "method variable" # [RUF052]
    -         return _var
108 +         var = "method variable" # [RUF052]
109 +         return var
110 | 
111 | def fun(_var): # parameters are ignored
112 |     return _var
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_list` is accessed
   --> RUF052.py:115:5
    |
114 | def fun():
115 |     _list = "built-in" # [RUF052]
    |     ^^^^^
116 |     return _list
    |
help: Prefer using trailing underscores to avoid shadowing a built-in
112 |     return _var
113 | 
114 | def fun():
    -     _list = "built-in" # [RUF052]
    -     return _list
115 +     list_ = "built-in" # [RUF052]
116 +     return list_
117 | 
118 | x = "global"
119 | 
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_x` is accessed
   --> RUF052.py:122:5
    |
120 | def fun():
121 |     global x
122 |     _x = "shadows global" # [RUF052]
    |     ^^
123 |     return _x
    |
help: Prefer using trailing underscores to avoid shadowing a variable
119 | 
120 | def fun():
121 |     global x
    -     _x = "shadows global" # [RUF052]
    -     return _x
122 +     x_ = "shadows global" # [RUF052]
123 +     return x_
124 | 
125 | def foo():
126 |   x = "outer"
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_x` is accessed
   --> RUF052.py:129:5
    |
127 |   def bar():
128 |     nonlocal x
129 |     _x = "shadows nonlocal" # [RUF052]
    |     ^^
130 |     return _x
131 |   bar()
    |
help: Prefer using trailing underscores to avoid shadowing a variable
126 |   x = "outer"
127 |   def bar():
128 |     nonlocal x
    -     _x = "shadows nonlocal" # [RUF052]
    -     return _x
129 +     x_ = "shadows nonlocal" # [RUF052]
130 +     return x_
131 |   bar()
132 |   return x
133 | 
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_x` is accessed
   --> RUF052.py:136:5
    |
134 | def fun():
135 |     x = "local"
136 |     _x = "shadows local" # [RUF052]
    |     ^^
137 |     return _x
    |
help: Prefer using trailing underscores to avoid shadowing a variable
133 | 
134 | def fun():
135 |     x = "local"
    -     _x = "shadows local" # [RUF052]
    -     return _x
136 +     x_ = "shadows local" # [RUF052]
137 +     return x_
138 | 
139 | 
140 | GLOBAL_1 = "global 1"
note: This is an unsafe fix and may change runtime behavior

RUF052 Local dummy variable `_GLOBAL_1` is accessed
   --> RUF052.py:144:5
    |
143 | def unfixables():
144 |     _GLOBAL_1 = "foo"
    |     ^^^^^^^^^
145 |     # unfixable because the rename would shadow a global variable
146 |     print(_GLOBAL_1)  # [RUF052]
    |
help: Prefer using trailing underscores to avoid shadowing a variable

RUF052 Local dummy variable `_local` is accessed
   --> RUF052.py:152:5
    |
151 |     # unfixable because the rename would shadow a local variable
152 |     _local = "local3"  # [RUF052]
    |     ^^^^^^
153 |     print(_local)
    |
help: Prefer using trailing underscores to avoid shadowing a variable

RUF052 Local dummy variable `_GLOBAL_1` is accessed
   --> RUF052.py:156:9
    |
155 |     def nested():
156 |         _GLOBAL_1 = "foo"
    |         ^^^^^^^^^
157 |         # unfixable because the rename would shadow a global variable
158 |         print(_GLOBAL_1)  # [RUF052]
    |
help: Prefer using trailing underscores to avoid shadowing a variable

RUF052 Local dummy variable `_local` is accessed
   --> RUF052.py:161:9
    |
160 |         # unfixable because the rename would shadow a variable from the outer function
161 |         _local = "local4"
    |         ^^^^^^
162 |         print(_local)
    |
help: Prefer using trailing underscores to avoid shadowing a variable

RUF052 [*] Local dummy variable `_P` is accessed
   --> RUF052.py:169:5
    |
167 |     from collections import namedtuple
168 |
169 |     _P = ParamSpec("_P")
    |     ^^
170 |     _T = TypeVar(name="_T", covariant=True, bound=int|str)
171 |     _NT = NamedTuple("_NT", [("foo", int)])
    |
help: Remove leading underscores
166 |     from enum import Enum
167 |     from collections import namedtuple
168 | 
    -     _P = ParamSpec("_P")
169 +     P = ParamSpec("P")
170 |     _T = TypeVar(name="_T", covariant=True, bound=int|str)
171 |     _NT = NamedTuple("_NT", [("foo", int)])
172 |     _E = Enum("_E", ["a", "b", "c"])
--------------------------------------------------------------------------------
175 |     _DynamicClass = type("_DynamicClass", (), {})
176 |     _NotADynamicClass = type("_NotADynamicClass")
177 | 
    -     print(_T, _P, _NT, _E, _NT2, _NT3, _DynamicClass, _NotADynamicClass)
178 +     print(_T, P, _NT, _E, _NT2, _NT3, _DynamicClass, _NotADynamicClass)
179 | 
180 | # Do not emit diagnostic if parameter is private
181 | # even if it is later shadowed in the body of the function
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_T` is accessed
   --> RUF052.py:170:5
    |
169 |     _P = ParamSpec("_P")
170 |     _T = TypeVar(name="_T", covariant=True, bound=int|str)
    |     ^^
171 |     _NT = NamedTuple("_NT", [("foo", int)])
172 |     _E = Enum("_E", ["a", "b", "c"])
    |
help: Remove leading underscores
167 |     from collections import namedtuple
168 | 
169 |     _P = ParamSpec("_P")
    -     _T = TypeVar(name="_T", covariant=True, bound=int|str)
170 +     T = TypeVar(name="T", covariant=True, bound=int|str)
171 |     _NT = NamedTuple("_NT", [("foo", int)])
172 |     _E = Enum("_E", ["a", "b", "c"])
173 |     _NT2 = namedtuple("_NT2", ['x', 'y', 'z'])
--------------------------------------------------------------------------------
175 |     _DynamicClass = type("_DynamicClass", (), {})
176 |     _NotADynamicClass = type("_NotADynamicClass")
177 | 
    -     print(_T, _P, _NT, _E, _NT2, _NT3, _DynamicClass, _NotADynamicClass)
178 +     print(T, _P, _NT, _E, _NT2, _NT3, _DynamicClass, _NotADynamicClass)
179 | 
180 | # Do not emit diagnostic if parameter is private
181 | # even if it is later shadowed in the body of the function
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_NT` is accessed
   --> RUF052.py:171:5
    |
169 |     _P = ParamSpec("_P")
170 |     _T = TypeVar(name="_T", covariant=True, bound=int|str)
171 |     _NT = NamedTuple("_NT", [("foo", int)])
    |     ^^^
172 |     _E = Enum("_E", ["a", "b", "c"])
173 |     _NT2 = namedtuple("_NT2", ['x', 'y', 'z'])
    |
help: Remove leading underscores
168 | 
169 |     _P = ParamSpec("_P")
170 |     _T = TypeVar(name="_T", covariant=True, bound=int|str)
    -     _NT = NamedTuple("_NT", [("foo", int)])
171 +     NT = NamedTuple("NT", [("foo", int)])
172 |     _E = Enum("_E", ["a", "b", "c"])
173 |     _NT2 = namedtuple("_NT2", ['x', 'y', 'z'])
174 |     _NT3 = namedtuple(typename="_NT3", field_names=['x', 'y', 'z'])
175 |     _DynamicClass = type("_DynamicClass", (), {})
176 |     _NotADynamicClass = type("_NotADynamicClass")
177 | 
    -     print(_T, _P, _NT, _E, _NT2, _NT3, _DynamicClass, _NotADynamicClass)
178 +     print(_T, _P, NT, _E, _NT2, _NT3, _DynamicClass, _NotADynamicClass)
179 | 
180 | # Do not emit diagnostic if parameter is private
181 | # even if it is later shadowed in the body of the function
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_E` is accessed
   --> RUF052.py:172:5
    |
170 |     _T = TypeVar(name="_T", covariant=True, bound=int|str)
171 |     _NT = NamedTuple("_NT", [("foo", int)])
172 |     _E = Enum("_E", ["a", "b", "c"])
    |     ^^
173 |     _NT2 = namedtuple("_NT2", ['x', 'y', 'z'])
174 |     _NT3 = namedtuple(typename="_NT3", field_names=['x', 'y', 'z'])
    |
help: Remove leading underscores
169 |     _P = ParamSpec("_P")
170 |     _T = TypeVar(name="_T", covariant=True, bound=int|str)
171 |     _NT = NamedTuple("_NT", [("foo", int)])
    -     _E = Enum("_E", ["a", "b", "c"])
172 +     E = Enum("E", ["a", "b", "c"])
173 |     _NT2 = namedtuple("_NT2", ['x', 'y', 'z'])
174 |     _NT3 = namedtuple(typename="_NT3", field_names=['x', 'y', 'z'])
175 |     _DynamicClass = type("_DynamicClass", (), {})
176 |     _NotADynamicClass = type("_NotADynamicClass")
177 | 
    -     print(_T, _P, _NT, _E, _NT2, _NT3, _DynamicClass, _NotADynamicClass)
178 +     print(_T, _P, _NT, E, _NT2, _NT3, _DynamicClass, _NotADynamicClass)
179 | 
180 | # Do not emit diagnostic if parameter is private
181 | # even if it is later shadowed in the body of the function
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_NT2` is accessed
   --> RUF052.py:173:5
    |
171 |     _NT = NamedTuple("_NT", [("foo", int)])
172 |     _E = Enum("_E", ["a", "b", "c"])
173 |     _NT2 = namedtuple("_NT2", ['x', 'y', 'z'])
    |     ^^^^
174 |     _NT3 = namedtuple(typename="_NT3", field_names=['x', 'y', 'z'])
175 |     _DynamicClass = type("_DynamicClass", (), {})
    |
help: Remove leading underscores
170 |     _T = TypeVar(name="_T", covariant=True, bound=int|str)
171 |     _NT = NamedTuple("_NT", [("foo", int)])
172 |     _E = Enum("_E", ["a", "b", "c"])
    -     _NT2 = namedtuple("_NT2", ['x', 'y', 'z'])
173 +     NT2 = namedtuple("NT2", ['x', 'y', 'z'])
174 |     _NT3 = namedtuple(typename="_NT3", field_names=['x', 'y', 'z'])
175 |     _DynamicClass = type("_DynamicClass", (), {})
176 |     _NotADynamicClass = type("_NotADynamicClass")
177 | 
    -     print(_T, _P, _NT, _E, _NT2, _NT3, _DynamicClass, _NotADynamicClass)
178 +     print(_T, _P, _NT, _E, NT2, _NT3, _DynamicClass, _NotADynamicClass)
179 | 
180 | # Do not emit diagnostic if parameter is private
181 | # even if it is later shadowed in the body of the function
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_NT3` is accessed
   --> RUF052.py:174:5
    |
172 |     _E = Enum("_E", ["a", "b", "c"])
173 |     _NT2 = namedtuple("_NT2", ['x', 'y', 'z'])
174 |     _NT3 = namedtuple(typename="_NT3", field_names=['x', 'y', 'z'])
    |     ^^^^
175 |     _DynamicClass = type("_DynamicClass", (), {})
176 |     _NotADynamicClass = type("_NotADynamicClass")
    |
help: Remove leading underscores
171 |     _NT = NamedTuple("_NT", [("foo", int)])
172 |     _E = Enum("_E", ["a", "b", "c"])
173 |     _NT2 = namedtuple("_NT2", ['x', 'y', 'z'])
    -     _NT3 = namedtuple(typename="_NT3", field_names=['x', 'y', 'z'])
174 +     NT3 = namedtuple(typename="NT3", field_names=['x', 'y', 'z'])
175 |     _DynamicClass = type("_DynamicClass", (), {})
176 |     _NotADynamicClass = type("_NotADynamicClass")
177 | 
    -     print(_T, _P, _NT, _E, _NT2, _NT3, _DynamicClass, _NotADynamicClass)
178 +     print(_T, _P, _NT, _E, _NT2, NT3, _DynamicClass, _NotADynamicClass)
179 | 
180 | # Do not emit diagnostic if parameter is private
181 | # even if it is later shadowed in the body of the function
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_DynamicClass` is accessed
   --> RUF052.py:175:5
    |
173 |     _NT2 = namedtuple("_NT2", ['x', 'y', 'z'])
174 |     _NT3 = namedtuple(typename="_NT3", field_names=['x', 'y', 'z'])
175 |     _DynamicClass = type("_DynamicClass", (), {})
    |     ^^^^^^^^^^^^^
176 |     _NotADynamicClass = type("_NotADynamicClass")
    |
help: Remove leading underscores
172 |     _E = Enum("_E", ["a", "b", "c"])
173 |     _NT2 = namedtuple("_NT2", ['x', 'y', 'z'])
174 |     _NT3 = namedtuple(typename="_NT3", field_names=['x', 'y', 'z'])
    -     _DynamicClass = type("_DynamicClass", (), {})
175 +     DynamicClass = type("DynamicClass", (), {})
176 |     _NotADynamicClass = type("_NotADynamicClass")
177 | 
    -     print(_T, _P, _NT, _E, _NT2, _NT3, _DynamicClass, _NotADynamicClass)
178 +     print(_T, _P, _NT, _E, _NT2, _NT3, DynamicClass, _NotADynamicClass)
179 | 
180 | # Do not emit diagnostic if parameter is private
181 | # even if it is later shadowed in the body of the function
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_NotADynamicClass` is accessed
   --> RUF052.py:176:5
    |
174 |     _NT3 = namedtuple(typename="_NT3", field_names=['x', 'y', 'z'])
175 |     _DynamicClass = type("_DynamicClass", (), {})
176 |     _NotADynamicClass = type("_NotADynamicClass")
    |     ^^^^^^^^^^^^^^^^^
177 |
178 |     print(_T, _P, _NT, _E, _NT2, _NT3, _DynamicClass, _NotADynamicClass)
    |
help: Remove leading underscores
173 |     _NT2 = namedtuple("_NT2", ['x', 'y', 'z'])
174 |     _NT3 = namedtuple(typename="_NT3", field_names=['x', 'y', 'z'])
175 |     _DynamicClass = type("_DynamicClass", (), {})
    -     _NotADynamicClass = type("_NotADynamicClass")
176 +     NotADynamicClass = type("_NotADynamicClass")
177 | 
    -     print(_T, _P, _NT, _E, _NT2, _NT3, _DynamicClass, _NotADynamicClass)
178 +     print(_T, _P, _NT, _E, _NT2, _NT3, _DynamicClass, NotADynamicClass)
179 | 
180 | # Do not emit diagnostic if parameter is private
181 | # even if it is later shadowed in the body of the function
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_dummy_var` is accessed
   --> RUF052.py:198:5
    |
197 | def foo():
198 |     _dummy_var = 42
    |     ^^^^^^^^^^
199 |
200 |     def bar():
    |
help: Prefer using trailing underscores to avoid shadowing a variable
195 | 
196 | 
197 | def foo():
    -     _dummy_var = 42
198 +     dummy_var_ = 42
199 | 
200 |     def bar():
201 |         dummy_var = 43
    -         print(_dummy_var)
202 +         print(dummy_var_)
203 | 
204 | 
205 | def foo():
note: This is an unsafe fix and may change runtime behavior

RUF052 Local dummy variable `_dummy_var` is accessed
   --> RUF052.py:208:5
    |
206 |     # Unfixable because both possible candidates for the new name are shadowed
207 |     # in the scope of one of the references to the variable
208 |     _dummy_var = 42
    |     ^^^^^^^^^^
209 |
210 |     def bar():
    |
help: Prefer using trailing underscores to avoid shadowing a variable

RUF052 [*] Local dummy variable `_item` is accessed
   --> RUF052.py:221:9
    |
220 |     # Should detect used dummy variable
221 |     for _item in my_list:
    |         ^^^^^
222 |         print(_item["foo"])  # RUF052: Local dummy variable `_item` is accessed
    |
help: Remove leading underscores
218 |     my_list = [{"foo": 1}, {"foo": 2}]
219 | 
220 |     # Should detect used dummy variable
    -     for _item in my_list:
    -         print(_item["foo"])  # RUF052: Local dummy variable `_item` is accessed
221 +     for item in my_list:
222 +         print(item["foo"])  # RUF052: Local dummy variable `_item` is accessed
223 | 
224 |     # Should detect used dummy variable
225 |     for _index, _value in enumerate(my_list):
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_index` is accessed
   --> RUF052.py:225:9
    |
224 |     # Should detect used dummy variable
225 |     for _index, _value in enumerate(my_list):
    |         ^^^^^^
226 |         result = _index + _value["foo"]  # RUF052: Both `_index` and `_value` are accessed
    |
help: Remove leading underscores
222 |         print(_item["foo"])  # RUF052: Local dummy variable `_item` is accessed
223 | 
224 |     # Should detect used dummy variable
    -     for _index, _value in enumerate(my_list):
    -         result = _index + _value["foo"]  # RUF052: Both `_index` and `_value` are accessed
225 +     for index, _value in enumerate(my_list):
226 +         result = index + _value["foo"]  # RUF052: Both `_index` and `_value` are accessed
227 | 
228 | # List Comprehensions
229 | def test_list_comprehensions():
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_value` is accessed
   --> RUF052.py:225:17
    |
224 |     # Should detect used dummy variable
225 |     for _index, _value in enumerate(my_list):
    |                 ^^^^^^
226 |         result = _index + _value["foo"]  # RUF052: Both `_index` and `_value` are accessed
    |
help: Remove leading underscores
222 |         print(_item["foo"])  # RUF052: Local dummy variable `_item` is accessed
223 | 
224 |     # Should detect used dummy variable
    -     for _index, _value in enumerate(my_list):
    -         result = _index + _value["foo"]  # RUF052: Both `_index` and `_value` are accessed
225 +     for _index, value in enumerate(my_list):
226 +         result = _index + value["foo"]  # RUF052: Both `_index` and `_value` are accessed
227 | 
228 | # List Comprehensions
229 | def test_list_comprehensions():
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_item` is accessed
   --> RUF052.py:233:32
    |
232 |     # Should detect used dummy variable
233 |     result = [_item["foo"] for _item in my_list]  # RUF052: Local dummy variable `_item` is accessed
    |                                ^^^^^
234 |
235 |     # Should detect used dummy variable in nested comprehension
    |
help: Remove leading underscores
230 |     my_list = [{"foo": 1}, {"foo": 2}]
231 | 
232 |     # Should detect used dummy variable
    -     result = [_item["foo"] for _item in my_list]  # RUF052: Local dummy variable `_item` is accessed
233 +     result = [item["foo"] for item in my_list]  # RUF052: Local dummy variable `_item` is accessed
234 | 
235 |     # Should detect used dummy variable in nested comprehension
236 |     nested = [[_item["foo"] for _item in sublist] for _sublist in [my_list, my_list]]
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_item` is accessed
   --> RUF052.py:236:33
    |
235 |     # Should detect used dummy variable in nested comprehension
236 |     nested = [[_item["foo"] for _item in sublist] for _sublist in [my_list, my_list]]
    |                                 ^^^^^
237 |     # RUF052: Both `_item` and `_sublist` are accessed
    |
help: Remove leading underscores
233 |     result = [_item["foo"] for _item in my_list]  # RUF052: Local dummy variable `_item` is accessed
234 | 
235 |     # Should detect used dummy variable in nested comprehension
    -     nested = [[_item["foo"] for _item in sublist] for _sublist in [my_list, my_list]]
236 +     nested = [[item["foo"] for item in sublist] for _sublist in [my_list, my_list]]
237 |     # RUF052: Both `_item` and `_sublist` are accessed
238 | 
239 |     # Should detect with conditions
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_item` is accessed
   --> RUF052.py:240:34
    |
239 |     # Should detect with conditions
240 |     filtered = [_item["foo"] for _item in my_list if _item["foo"] > 0]
    |                                  ^^^^^
241 |     # RUF052: Local dummy variable `_item` is accessed
    |
help: Remove leading underscores
237 |     # RUF052: Both `_item` and `_sublist` are accessed
238 | 
239 |     # Should detect with conditions
    -     filtered = [_item["foo"] for _item in my_list if _item["foo"] > 0]
240 +     filtered = [item["foo"] for item in my_list if item["foo"] > 0]
241 |     # RUF052: Local dummy variable `_item` is accessed
242 | 
243 | # Dict Comprehensions
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_item` is accessed
   --> RUF052.py:248:48
    |
247 |     # Should detect used dummy variable
248 |     result = {_item["key"]: _item["value"] for _item in my_list}
    |                                                ^^^^^
249 |     # RUF052: Local dummy variable `_item` is accessed
    |
help: Remove leading underscores
245 |     my_list = [{"key": "a", "value": 1}, {"key": "b", "value": 2}]
246 | 
247 |     # Should detect used dummy variable
    -     result = {_item["key"]: _item["value"] for _item in my_list}
248 +     result = {item["key"]: item["value"] for item in my_list}
249 |     # RUF052: Local dummy variable `_item` is accessed
250 | 
251 |     # Should detect with enumerate
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_index` is accessed
   --> RUF052.py:252:43
    |
251 |     # Should detect with enumerate
252 |     indexed = {_index: _item["value"] for _index, _item in enumerate(my_list)}
    |                                           ^^^^^^
253 |     # RUF052: Both `_index` and `_item` are accessed
    |
help: Remove leading underscores
249 |     # RUF052: Local dummy variable `_item` is accessed
250 | 
251 |     # Should detect with enumerate
    -     indexed = {_index: _item["value"] for _index, _item in enumerate(my_list)}
252 +     indexed = {index: _item["value"] for index, _item in enumerate(my_list)}
253 |     # RUF052: Both `_index` and `_item` are accessed
254 | 
255 |     # Should detect in nested dict comprehension
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_item` is accessed
   --> RUF052.py:252:51
    |
251 |     # Should detect with enumerate
252 |     indexed = {_index: _item["value"] for _index, _item in enumerate(my_list)}
    |                                                   ^^^^^
253 |     # RUF052: Both `_index` and `_item` are accessed
    |
help: Remove leading underscores
249 |     # RUF052: Local dummy variable `_item` is accessed
250 | 
251 |     # Should detect with enumerate
    -     indexed = {_index: _item["value"] for _index, _item in enumerate(my_list)}
252 +     indexed = {_index: item["value"] for _index, item in enumerate(my_list)}
253 |     # RUF052: Both `_index` and `_item` are accessed
254 | 
255 |     # Should detect in nested dict comprehension
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_inner` is accessed
   --> RUF052.py:256:59
    |
255 |     # Should detect in nested dict comprehension
256 |     nested = {_outer: {_inner["key"]: _inner["value"] for _inner in sublist}
    |                                                           ^^^^^^
257 |               for _outer, sublist in enumerate([my_list])}
258 |     # RUF052: `_outer`, `_inner` are accessed
    |
help: Remove leading underscores
253 |     # RUF052: Both `_index` and `_item` are accessed
254 | 
255 |     # Should detect in nested dict comprehension
    -     nested = {_outer: {_inner["key"]: _inner["value"] for _inner in sublist}
256 +     nested = {_outer: {inner["key"]: inner["value"] for inner in sublist}
257 |               for _outer, sublist in enumerate([my_list])}
258 |     # RUF052: `_outer`, `_inner` are accessed
259 | 
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_outer` is accessed
   --> RUF052.py:257:19
    |
255 |     # Should detect in nested dict comprehension
256 |     nested = {_outer: {_inner["key"]: _inner["value"] for _inner in sublist}
257 |               for _outer, sublist in enumerate([my_list])}
    |                   ^^^^^^
258 |     # RUF052: `_outer`, `_inner` are accessed
    |
help: Remove leading underscores
253 |     # RUF052: Both `_index` and `_item` are accessed
254 | 
255 |     # Should detect in nested dict comprehension
    -     nested = {_outer: {_inner["key"]: _inner["value"] for _inner in sublist}
    -               for _outer, sublist in enumerate([my_list])}
256 +     nested = {outer: {_inner["key"]: _inner["value"] for _inner in sublist}
257 +               for outer, sublist in enumerate([my_list])}
258 |     # RUF052: `_outer`, `_inner` are accessed
259 | 
260 | # Set Comprehensions
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_item` is accessed
   --> RUF052.py:265:39
    |
264 |     # Should detect used dummy variable
265 |     unique_values = {_item["foo"] for _item in my_list}
    |                                       ^^^^^
266 |     # RUF052: Local dummy variable `_item` is accessed
    |
help: Remove leading underscores
262 |     my_list = [{"foo": 1}, {"foo": 2}, {"foo": 1}]  # Note: duplicate values
263 | 
264 |     # Should detect used dummy variable
    -     unique_values = {_item["foo"] for _item in my_list}
265 +     unique_values = {item["foo"] for item in my_list}
266 |     # RUF052: Local dummy variable `_item` is accessed
267 | 
268 |     # Should detect with conditions
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_item` is accessed
   --> RUF052.py:269:38
    |
268 |     # Should detect with conditions
269 |     filtered_set = {_item["foo"] for _item in my_list if _item["foo"] > 0}
    |                                      ^^^^^
270 |     # RUF052: Local dummy variable `_item` is accessed
    |
help: Remove leading underscores
266 |     # RUF052: Local dummy variable `_item` is accessed
267 | 
268 |     # Should detect with conditions
    -     filtered_set = {_item["foo"] for _item in my_list if _item["foo"] > 0}
269 +     filtered_set = {item["foo"] for item in my_list if item["foo"] > 0}
270 |     # RUF052: Local dummy variable `_item` is accessed
271 | 
272 |     # Should detect with complex expression
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_item` is accessed
   --> RUF052.py:273:39
    |
272 |     # Should detect with complex expression
273 |     processed = {_item["foo"] * 2 for _item in my_list}
    |                                       ^^^^^
274 |     # RUF052: Local dummy variable `_item` is accessed
    |
help: Remove leading underscores
270 |     # RUF052: Local dummy variable `_item` is accessed
271 | 
272 |     # Should detect with complex expression
    -     processed = {_item["foo"] * 2 for _item in my_list}
273 +     processed = {item["foo"] * 2 for item in my_list}
274 |     # RUF052: Local dummy variable `_item` is accessed
275 | 
276 | # Generator Expressions
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_item` is accessed
   --> RUF052.py:281:29
    |
280 |     # Should detect used dummy variable
281 |     gen = (_item["foo"] for _item in my_list)
    |                             ^^^^^
282 |     # RUF052: Local dummy variable `_item` is accessed
    |
help: Remove leading underscores
278 |     my_list = [{"foo": 1}, {"foo": 2}]
279 | 
280 |     # Should detect used dummy variable
    -     gen = (_item["foo"] for _item in my_list)
281 +     gen = (item["foo"] for item in my_list)
282 |     # RUF052: Local dummy variable `_item` is accessed
283 | 
284 |     # Should detect when passed to function
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_item` is accessed
   --> RUF052.py:285:34
    |
284 |     # Should detect when passed to function
285 |     total = sum(_item["foo"] for _item in my_list)
    |                                  ^^^^^
286 |     # RUF052: Local dummy variable `_item` is accessed
    |
help: Remove leading underscores
282 |     # RUF052: Local dummy variable `_item` is accessed
283 | 
284 |     # Should detect when passed to function
    -     total = sum(_item["foo"] for _item in my_list)
285 +     total = sum(item["foo"] for item in my_list)
286 |     # RUF052: Local dummy variable `_item` is accessed
287 | 
288 |     # Should detect with multiple generators
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_x` is accessed
   --> RUF052.py:289:27
    |
288 |     # Should detect with multiple generators
289 |     pairs = ((_x, _y) for _x in range(3) for _y in range(3) if _x != _y)
    |                           ^^
290 |     # RUF052: Both `_x` and `_y` are accessed
    |
help: Prefer using trailing underscores to avoid shadowing a variable
286 |     # RUF052: Local dummy variable `_item` is accessed
287 | 
288 |     # Should detect with multiple generators
    -     pairs = ((_x, _y) for _x in range(3) for _y in range(3) if _x != _y)
289 +     pairs = ((x_, _y) for x_ in range(3) for _y in range(3) if x_ != _y)
290 |     # RUF052: Both `_x` and `_y` are accessed
291 | 
292 |     # Should detect in nested generator
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_y` is accessed
   --> RUF052.py:289:46
    |
288 |     # Should detect with multiple generators
289 |     pairs = ((_x, _y) for _x in range(3) for _y in range(3) if _x != _y)
    |                                              ^^
290 |     # RUF052: Both `_x` and `_y` are accessed
    |
help: Remove leading underscores
286 |     # RUF052: Local dummy variable `_item` is accessed
287 | 
288 |     # Should detect with multiple generators
    -     pairs = ((_x, _y) for _x in range(3) for _y in range(3) if _x != _y)
289 +     pairs = ((_x, y) for _x in range(3) for y in range(3) if _x != y)
290 |     # RUF052: Both `_x` and `_y` are accessed
291 | 
292 |     # Should detect in nested generator
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_inner` is accessed
   --> RUF052.py:293:41
    |
292 |     # Should detect in nested generator
293 |     nested_gen = (sum(_inner["foo"] for _inner in sublist) for _sublist in [my_list] for sublist in _sublist)
    |                                         ^^^^^^
294 |     # RUF052: `_inner` and `_sublist` are accessed
    |
help: Remove leading underscores
290 |     # RUF052: Both `_x` and `_y` are accessed
291 | 
292 |     # Should detect in nested generator
    -     nested_gen = (sum(_inner["foo"] for _inner in sublist) for _sublist in [my_list] for sublist in _sublist)
293 +     nested_gen = (sum(inner["foo"] for inner in sublist) for _sublist in [my_list] for sublist in _sublist)
294 |     # RUF052: `_inner` and `_sublist` are accessed
295 | 
296 | # Complex Examples with Multiple Comprehension Types
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_sublist` is accessed
   --> RUF052.py:293:64
    |
292 |     # Should detect in nested generator
293 |     nested_gen = (sum(_inner["foo"] for _inner in sublist) for _sublist in [my_list] for sublist in _sublist)
    |                                                                ^^^^^^^^
294 |     # RUF052: `_inner` and `_sublist` are accessed
    |
help: Prefer using trailing underscores to avoid shadowing a variable
290 |     # RUF052: Both `_x` and `_y` are accessed
291 | 
292 |     # Should detect in nested generator
    -     nested_gen = (sum(_inner["foo"] for _inner in sublist) for _sublist in [my_list] for sublist in _sublist)
293 +     nested_gen = (sum(_inner["foo"] for _inner in sublist) for sublist_ in [my_list] for sublist in sublist_)
294 |     # RUF052: `_inner` and `_sublist` are accessed
295 | 
296 | # Complex Examples with Multiple Comprehension Types
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_val` is accessed
   --> RUF052.py:302:30
    |
300 |     # Should detect in mixed comprehensions
301 |     result = [
302 |         {_key: [_val * 2 for _val in _record["items"]] for _key in ["doubled"]}
    |                              ^^^^
303 |         for _record in data
304 |     ]
    |
help: Remove leading underscores
299 | 
300 |     # Should detect in mixed comprehensions
301 |     result = [
    -         {_key: [_val * 2 for _val in _record["items"]] for _key in ["doubled"]}
302 +         {_key: [val * 2 for val in _record["items"]] for _key in ["doubled"]}
303 |         for _record in data
304 |     ]
305 |     # RUF052: `_key`, `_val`, and `_record` are all accessed
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_key` is accessed
   --> RUF052.py:302:60
    |
300 |     # Should detect in mixed comprehensions
301 |     result = [
302 |         {_key: [_val * 2 for _val in _record["items"]] for _key in ["doubled"]}
    |                                                            ^^^^
303 |         for _record in data
304 |     ]
    |
help: Remove leading underscores
299 | 
300 |     # Should detect in mixed comprehensions
301 |     result = [
    -         {_key: [_val * 2 for _val in _record["items"]] for _key in ["doubled"]}
302 +         {key: [_val * 2 for _val in _record["items"]] for key in ["doubled"]}
303 |         for _record in data
304 |     ]
305 |     # RUF052: `_key`, `_val`, and `_record` are all accessed
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_record` is accessed
   --> RUF052.py:303:13
    |
301 |     result = [
302 |         {_key: [_val * 2 for _val in _record["items"]] for _key in ["doubled"]}
303 |         for _record in data
    |             ^^^^^^^
304 |     ]
305 |     # RUF052: `_key`, `_val`, and `_record` are all accessed
    |
help: Remove leading underscores
299 | 
300 |     # Should detect in mixed comprehensions
301 |     result = [
    -         {_key: [_val * 2 for _val in _record["items"]] for _key in ["doubled"]}
    -         for _record in data
302 +         {_key: [_val * 2 for _val in record["items"]] for _key in ["doubled"]}
303 +         for record in data
304 |     ]
305 |     # RUF052: `_key`, `_val`, and `_record` are all accessed
306 | 
note: This is an unsafe fix and may change runtime behavior

RUF052 [*] Local dummy variable `_item` is accessed
   --> RUF052.py:308:43
    |
307 |     # Should detect in generator passed to list constructor
308 |     gen_list = list(_item["items"][0] for _item in data)
    |                                           ^^^^^
309 |     # RUF052: Local dummy variable `_item` is accessed
    |
help: Remove leading underscores
305 |     # RUF052: `_key`, `_val`, and `_record` are all accessed
306 | 
307 |     # Should detect in generator passed to list constructor
    -     gen_list = list(_item["items"][0] for _item in data)
308 +     gen_list = list(item["items"][0] for item in data)
309 |     # RUF052: Local dummy variable `_item` is accessed
310 | 
311 | 
note: This is an unsafe fix and may change runtime behavior
