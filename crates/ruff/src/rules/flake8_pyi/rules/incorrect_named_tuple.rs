use rustpython_parser::ast;
use rustpython_parser::ast::Stmt;

use crate::registry::AsRule;
use ruff_diagnostics::{AlwaysAutofixableViolation, Diagnostic, Edit, Fix};
use ruff_macros::{derive_message_formats, violation};
use ruff_python_ast::prelude::Ranged;

use crate::checkers::ast::Checker;

/// ## What it does
/// Checks for an import of `collections.namedtuple`
///
/// ## Why is this bad?
/// The type generated by subclassing typing.NamedTuple is equivalent to a collections.namedtuple,
/// but with __annotations__, _field_types and _field_defaults attributes added.
///
/// For a developer, using the typing module for your namedtuples allows a more natural
/// declarative interface and more precise type inference.
///
/// ## Example
/// ```python
/// from collections import namedtuple
///
/// person = namedtuple("Person", ["name", "age"]
/// ```
///
/// Use instead:
/// ```python
/// from typing import NamedTuple
///
/// class Person(NamedTuple):
///     name: str
///     age: int
/// ```
/// ## References
///  - [StackOverflow](https://stackoverflow.com/a/50767206)
#[violation]
pub struct IncorrectNamedTuple;

impl AlwaysAutofixableViolation for IncorrectNamedTuple {
    #[derive_message_formats]
    fn message(&self) -> String {
        format!("Use `typing.NamedTuple` instead of `collections.namedtuple`")
    }

    fn autofix_title(&self) -> String {
        format!("Replace `collections.namedtuple` with `typing.NamedTuple`")
    }
}

/// PYI024
pub(crate) fn incorrect_named_tuple(checker: &mut Checker, stmt: &Stmt) {
    if let Stmt::ImportFrom(ast::StmtImportFrom { module, names, .. }) = stmt {
        let Some(module) = module else {
            return
        };
        if module.as_str() != "collections" {
            return;
        }
        for name in names {
            if name.name.as_str() == "namedtuple" {
                let mut diagnostic = Diagnostic::new(IncorrectNamedTuple, name.range());
                if checker.patch(diagnostic.kind.rule()) {
                    diagnostic.set_fix(Fix::manual(Edit::range_replacement(
                        format!("from typing import NamedTuple"),
                        stmt.range(),
                    )));
                }
                checker.diagnostics.push(diagnostic);
            }
        }
    }
}
