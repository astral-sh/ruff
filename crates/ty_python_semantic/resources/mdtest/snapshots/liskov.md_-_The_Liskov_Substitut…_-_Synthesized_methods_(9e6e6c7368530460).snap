---
source: crates/ty_test/src/lib.rs
expression: snapshot
---
---
mdtest name: liskov.md - The Liskov Substitution Principle - Synthesized methods
mdtest path: crates/ty_python_semantic/resources/mdtest/liskov.md
---

# Python source files

## mdtest_snippet.pyi

```
 1 | from dataclasses import dataclass
 2 | from typing import NamedTuple
 3 | 
 4 | @dataclass(order=True)
 5 | class Foo:
 6 |     x: int
 7 | 
 8 | class Bar(Foo):
 9 |     def __lt__(self, other: Bar) -> bool: ...  # error: [invalid-method-override]
10 | 
11 | # TODO: specifying `order=True` on the subclass means that a `__lt__` method is
12 | # generated that is incompatible with the generated `__lt__` method on the superclass.
13 | # We could consider detecting this and emitting a diagnostic, though maybe it shouldn't
14 | # be `invalid-method-override` since we'd emit it on the class definition rather than
15 | # on any method definition. Note also that no other type checker complains about this
16 | # as of 2025-11-21.
17 | @dataclass(order=True)
18 | class Bar2(Foo):
19 |     y: str
20 | 
21 | # TODO: Although this class does not override any methods of `Foo`, the design of the
22 | # `order=True` stdlib dataclasses feature itself arguably violates the Liskov Substitution
23 | # Principle! Instances of `Bar3` cannot be substituted wherever an instance of `Foo` is
24 | # expected, because the generated `__lt__` method on `Foo` raises an error unless the r.h.s.
25 | # and `l.h.s.` have exactly the same `__class__` (it does not permit instances of `Foo` to
26 | # be compared with instances of subclasses of `Foo`).
27 | #
28 | # Many users would probably like their type checkers to alert them to cases where instances
29 | # of subclasses cannot be substituted for instances of superclasses, as this violates many
30 | # assumptions a type checker will make and makes it likely that a type checker will fail to
31 | # catch type errors elsewhere in the user's code. We could therefore consider treating all
32 | # `order=True` dataclasses as implicitly `@final` in order to enforce soundness. However,
33 | # this probably shouldn't be reported with the same error code as Liskov violations, since
34 | # the error does not stem from any method signatures written by the user. The example is
35 | # only included here for completeness.
36 | #
37 | # Note that no other type checker catches this error as of 2025-11-21.
38 | class Bar3(Foo): ...
39 | 
40 | class Eggs:
41 |     def __lt__(self, other: Eggs) -> bool: ...
42 | 
43 | # TODO: the generated `Ham.__lt__` method here incompatibly overrides `Eggs.__lt__`.
44 | # We could consider emitting a diagnostic here. As of 2025-11-21, mypy reports a
45 | # diagnostic here but pyright and pyrefly do not.
46 | @dataclass(order=True)
47 | class Ham(Eggs):
48 |     x: int
49 | 
50 | class Baz(NamedTuple):
51 |     x: int
52 | 
53 | class Spam(Baz):
54 |     def _asdict(self) -> tuple[int, ...]: ...  # error: [invalid-method-override]
```

# Diagnostics

```
error[invalid-method-override]: Invalid override of method `__lt__`
  --> src/mdtest_snippet.pyi:9:9
   |
 8 | class Bar(Foo):
 9 |     def __lt__(self, other: Bar) -> bool: ...  # error: [invalid-method-override]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Definition is incompatible with `Foo.__lt__`
10 |
11 | # TODO: specifying `order=True` on the subclass means that a `__lt__` method is
   |
info: This violates the Liskov Substitution Principle
info: `Foo.__lt__` is a generated method created because `Foo` is a dataclass
 --> src/mdtest_snippet.pyi:5:7
  |
4 | @dataclass(order=True)
5 | class Foo:
  |       ^^^ Definition of `Foo`
6 |     x: int
  |
info: rule `invalid-method-override` is enabled by default

```

```
error[invalid-method-override]: Invalid override of method `_asdict`
  --> src/mdtest_snippet.pyi:54:9
   |
53 | class Spam(Baz):
54 |     def _asdict(self) -> tuple[int, ...]: ...  # error: [invalid-method-override]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Definition is incompatible with `Baz._asdict`
   |
info: This violates the Liskov Substitution Principle
info: `Baz._asdict` is a generated method created because `Baz` inherits from `typing.NamedTuple`
  --> src/mdtest_snippet.pyi:50:7
   |
48 |     x: int
49 |
50 | class Baz(NamedTuple):
   |       ^^^^^^^^^^^^^^^ Definition of `Baz`
51 |     x: int
   |
info: rule `invalid-method-override` is enabled by default

```
