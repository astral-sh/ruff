---
source: crates/ruff_python_formatter/src/lib.rs
expression: snapshot
input_file: crates/ruff_python_formatter/resources/test/fixtures/black/simple_cases/function_trailing_comma.py
---
## Input

```py
def f(a,):
    d = {'key': 'value',}
    tup = (1,)

def f2(a,b,):
    d = {'key': 'value', 'key2': 'value2',}
    tup = (1,2,)

def f(a:int=1,):
    call(arg={'explode': 'this',})
    call2(arg=[1,2,3],)
    x = {
        "a": 1,
        "b": 2,
    }["a"]
    if a == {"a": 1,"b": 2,"c": 3,"d": 4,"e": 5,"f": 6,"g": 7,"h": 8,}["a"]:
        pass

def xxxxxxxxxxxxxxxxxxxxxxxxxxxx() -> Set[
    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
]:
    json = {"k": {"k2": {"k3": [1,]}}}



# The type annotation shouldn't get a trailing comma since that would change its type.
# Relevant bug report: https://github.com/psf/black/issues/2381.
def some_function_with_a_really_long_name() -> (
    returning_a_deeply_nested_import_of_a_type_i_suppose
):
    pass


def some_method_with_a_really_long_name(very_long_parameter_so_yeah: str, another_long_parameter: int) -> (
    another_case_of_returning_a_deeply_nested_import_of_a_type_i_suppose_cause_why_not
):
    pass


def func() -> (
    also_super_long_type_annotation_that_may_cause_an_AST_related_crash_in_black(this_shouldn_t_get_a_trailing_comma_too)
):
    pass


def func() -> ((also_super_long_type_annotation_that_may_cause_an_AST_related_crash_in_black(
        this_shouldn_t_get_a_trailing_comma_too
    ))
):
    pass


# Make sure inner one-element tuple won't explode
some_module.some_function(
    argument1, (one_element_tuple,), argument4, argument5, argument6
)

# Inner trailing comma causes outer to explode
some_module.some_function(
    argument1, (one, two,), argument4, argument5, argument6
)
```

## Black Differences

```diff
--- Black
+++ Ruff
@@ -2,7 +2,7 @@
     a,
 ):
     d = {
-        "key": "value",
+        "NOT_YET_IMPLEMENTED_STRING": "NOT_YET_IMPLEMENTED_STRING",
     }
     tup = (1,)
 
@@ -12,8 +12,8 @@
     b,
 ):
     d = {
-        "key": "value",
-        "key2": "value2",
+        "NOT_YET_IMPLEMENTED_STRING": "NOT_YET_IMPLEMENTED_STRING",
+        "NOT_YET_IMPLEMENTED_STRING": "NOT_YET_IMPLEMENTED_STRING",
     }
     tup = (
         1,
@@ -24,45 +24,23 @@
 def f(
     a: int = 1,
 ):
-    call(
-        arg={
-            "explode": "this",
-        }
-    )
-    call2(
-        arg=[1, 2, 3],
-    )
+    NOT_IMPLEMENTED_call(NOT_IMPLEMENTED_arg)
+    NOT_IMPLEMENTED_call(NOT_IMPLEMENTED_arg)
     x = {
-        "a": 1,
-        "b": 2,
-    }["a"]
-    if (
-        a
-        == {
-            "a": 1,
-            "b": 2,
-            "c": 3,
-            "d": 4,
-            "e": 5,
-            "f": 6,
-            "g": 7,
-            "h": 8,
-        }["a"]
-    ):
+        "NOT_YET_IMPLEMENTED_STRING": 1,
+        "NOT_YET_IMPLEMENTED_STRING": 2,
+    }[
+        "NOT_YET_IMPLEMENTED_STRING"
+    ]
+    if NOT_IMPLEMENTED_left < NOT_IMPLEMENTED_right:
         pass
 
 
-def xxxxxxxxxxxxxxxxxxxxxxxxxxxx() -> (
-    Set["xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
-):
+def xxxxxxxxxxxxxxxxxxxxxxxxxxxx() -> Set["NOT_YET_IMPLEMENTED_STRING"]:
     json = {
-        "k": {
-            "k2": {
-                "k3": [
-                    1,
-                ]
-            }
-        }
+        "NOT_YET_IMPLEMENTED_STRING": {
+            "NOT_YET_IMPLEMENTED_STRING": {"NOT_YET_IMPLEMENTED_STRING": [1]},
+        },
     }
 
 
@@ -80,35 +58,16 @@
     pass
 
 
-def func() -> (
-    also_super_long_type_annotation_that_may_cause_an_AST_related_crash_in_black(
-        this_shouldn_t_get_a_trailing_comma_too
-    )
-):
+def func() -> NOT_IMPLEMENTED_call(NOT_IMPLEMENTED_arg):
     pass
 
 
-def func() -> (
-    also_super_long_type_annotation_that_may_cause_an_AST_related_crash_in_black(
-        this_shouldn_t_get_a_trailing_comma_too
-    )
-):
+def func() -> NOT_IMPLEMENTED_call(NOT_IMPLEMENTED_arg):
     pass
 
 
 # Make sure inner one-element tuple won't explode
-some_module.some_function(
-    argument1, (one_element_tuple,), argument4, argument5, argument6
-)
+NOT_IMPLEMENTED_call(NOT_IMPLEMENTED_arg)
 
 # Inner trailing comma causes outer to explode
-some_module.some_function(
-    argument1,
-    (
-        one,
-        two,
-    ),
-    argument4,
-    argument5,
-    argument6,
-)
+NOT_IMPLEMENTED_call(NOT_IMPLEMENTED_arg)
```

## Ruff Output

```py
def f(
    a,
):
    d = {
        "NOT_YET_IMPLEMENTED_STRING": "NOT_YET_IMPLEMENTED_STRING",
    }
    tup = (1,)


def f2(
    a,
    b,
):
    d = {
        "NOT_YET_IMPLEMENTED_STRING": "NOT_YET_IMPLEMENTED_STRING",
        "NOT_YET_IMPLEMENTED_STRING": "NOT_YET_IMPLEMENTED_STRING",
    }
    tup = (
        1,
        2,
    )


def f(
    a: int = 1,
):
    NOT_IMPLEMENTED_call(NOT_IMPLEMENTED_arg)
    NOT_IMPLEMENTED_call(NOT_IMPLEMENTED_arg)
    x = {
        "NOT_YET_IMPLEMENTED_STRING": 1,
        "NOT_YET_IMPLEMENTED_STRING": 2,
    }[
        "NOT_YET_IMPLEMENTED_STRING"
    ]
    if NOT_IMPLEMENTED_left < NOT_IMPLEMENTED_right:
        pass


def xxxxxxxxxxxxxxxxxxxxxxxxxxxx() -> Set["NOT_YET_IMPLEMENTED_STRING"]:
    json = {
        "NOT_YET_IMPLEMENTED_STRING": {
            "NOT_YET_IMPLEMENTED_STRING": {"NOT_YET_IMPLEMENTED_STRING": [1]},
        },
    }


# The type annotation shouldn't get a trailing comma since that would change its type.
# Relevant bug report: https://github.com/psf/black/issues/2381.
def some_function_with_a_really_long_name() -> (
    returning_a_deeply_nested_import_of_a_type_i_suppose
):
    pass


def some_method_with_a_really_long_name(
    very_long_parameter_so_yeah: str, another_long_parameter: int
) -> another_case_of_returning_a_deeply_nested_import_of_a_type_i_suppose_cause_why_not:
    pass


def func() -> NOT_IMPLEMENTED_call(NOT_IMPLEMENTED_arg):
    pass


def func() -> NOT_IMPLEMENTED_call(NOT_IMPLEMENTED_arg):
    pass


# Make sure inner one-element tuple won't explode
NOT_IMPLEMENTED_call(NOT_IMPLEMENTED_arg)

# Inner trailing comma causes outer to explode
NOT_IMPLEMENTED_call(NOT_IMPLEMENTED_arg)
```

## Black Output

```py
def f(
    a,
):
    d = {
        "key": "value",
    }
    tup = (1,)


def f2(
    a,
    b,
):
    d = {
        "key": "value",
        "key2": "value2",
    }
    tup = (
        1,
        2,
    )


def f(
    a: int = 1,
):
    call(
        arg={
            "explode": "this",
        }
    )
    call2(
        arg=[1, 2, 3],
    )
    x = {
        "a": 1,
        "b": 2,
    }["a"]
    if (
        a
        == {
            "a": 1,
            "b": 2,
            "c": 3,
            "d": 4,
            "e": 5,
            "f": 6,
            "g": 7,
            "h": 8,
        }["a"]
    ):
        pass


def xxxxxxxxxxxxxxxxxxxxxxxxxxxx() -> (
    Set["xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
):
    json = {
        "k": {
            "k2": {
                "k3": [
                    1,
                ]
            }
        }
    }


# The type annotation shouldn't get a trailing comma since that would change its type.
# Relevant bug report: https://github.com/psf/black/issues/2381.
def some_function_with_a_really_long_name() -> (
    returning_a_deeply_nested_import_of_a_type_i_suppose
):
    pass


def some_method_with_a_really_long_name(
    very_long_parameter_so_yeah: str, another_long_parameter: int
) -> another_case_of_returning_a_deeply_nested_import_of_a_type_i_suppose_cause_why_not:
    pass


def func() -> (
    also_super_long_type_annotation_that_may_cause_an_AST_related_crash_in_black(
        this_shouldn_t_get_a_trailing_comma_too
    )
):
    pass


def func() -> (
    also_super_long_type_annotation_that_may_cause_an_AST_related_crash_in_black(
        this_shouldn_t_get_a_trailing_comma_too
    )
):
    pass


# Make sure inner one-element tuple won't explode
some_module.some_function(
    argument1, (one_element_tuple,), argument4, argument5, argument6
)

# Inner trailing comma causes outer to explode
some_module.some_function(
    argument1,
    (
        one,
        two,
    ),
    argument4,
    argument5,
    argument6,
)
```


