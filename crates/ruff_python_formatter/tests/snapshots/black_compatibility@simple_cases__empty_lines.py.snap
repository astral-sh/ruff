---
source: crates/ruff_python_formatter/tests/fixtures.rs
input_file: crates/ruff_python_formatter/resources/test/fixtures/black/simple_cases/empty_lines.py
---
## Input

```py
"""Docstring."""


# leading comment
def f():
    NO = ''
    SPACE = ' '
    DOUBLESPACE = '  '

    t = leaf.type
    p = leaf.parent  # trailing comment
    v = leaf.value

    if t in ALWAYS_NO_SPACE:
        pass
    if t == token.COMMENT:  # another trailing comment
        return DOUBLESPACE


    assert p is not None, f"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}"


    prev = leaf.prev_sibling
    if not prev:
        prevp = preceding_leaf(p)
        if not prevp or prevp.type in OPENING_BRACKETS:


            return NO


        if prevp.type == token.EQUAL:
            if prevp.parent and prevp.parent.type in {
                syms.typedargslist,
                syms.varargslist,
                syms.parameters,
                syms.arglist,
                syms.argument,
            }:
                return NO

        elif prevp.type == token.DOUBLESTAR:
            if prevp.parent and prevp.parent.type in {
                syms.typedargslist,
                syms.varargslist,
                syms.parameters,
                syms.arglist,
                syms.dictsetmaker,
            }:
                return NO

###############################################################################
# SECTION BECAUSE SECTIONS
###############################################################################

def g():
    NO = ''
    SPACE = ' '
    DOUBLESPACE = '  '

    t = leaf.type
    p = leaf.parent
    v = leaf.value

    # Comment because comments

    if t in ALWAYS_NO_SPACE:
        pass
    if t == token.COMMENT:
        return DOUBLESPACE

    # Another comment because more comments
    assert p is not None, f'INTERNAL ERROR: hand-made leaf without parent: {leaf!r}'

    prev = leaf.prev_sibling
    if not prev:
        prevp = preceding_leaf(p)

        if not prevp or prevp.type in OPENING_BRACKETS:
            # Start of the line or a bracketed expression.
            # More than one line for the comment.
            return NO

        if prevp.type == token.EQUAL:
            if prevp.parent and prevp.parent.type in {
                syms.typedargslist,
                syms.varargslist,
                syms.parameters,
                syms.arglist,
                syms.argument,
            }:
                return NO
```

## Black Differences

```diff
--- Black
+++ Ruff
@@ -16,7 +16,7 @@
     if t == token.COMMENT:  # another trailing comment
         return DOUBLESPACE
 
-    assert p is not None, f"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}"
+    assert p is not None, f"NOT_YET_IMPLEMENTED_ExprJoinedStr"
 
     prev = leaf.prev_sibling
     if not prev:
@@ -48,7 +48,6 @@
 ###############################################################################
 # SECTION BECAUSE SECTIONS
 ###############################################################################
-
 
 def g():
     NO = ""
@@ -67,7 +66,7 @@
         return DOUBLESPACE
 
     # Another comment because more comments
-    assert p is not None, f"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}"
+    assert p is not None, f"NOT_YET_IMPLEMENTED_ExprJoinedStr"
 
     prev = leaf.prev_sibling
     if not prev:
```

## Ruff Output

```py
"""Docstring."""


# leading comment
def f():
    NO = ""
    SPACE = " "
    DOUBLESPACE = "  "

    t = leaf.type
    p = leaf.parent  # trailing comment
    v = leaf.value

    if t in ALWAYS_NO_SPACE:
        pass
    if t == token.COMMENT:  # another trailing comment
        return DOUBLESPACE

    assert p is not None, f"NOT_YET_IMPLEMENTED_ExprJoinedStr"

    prev = leaf.prev_sibling
    if not prev:
        prevp = preceding_leaf(p)
        if not prevp or prevp.type in OPENING_BRACKETS:
            return NO

        if prevp.type == token.EQUAL:
            if prevp.parent and prevp.parent.type in {
                syms.typedargslist,
                syms.varargslist,
                syms.parameters,
                syms.arglist,
                syms.argument,
            }:
                return NO

        elif prevp.type == token.DOUBLESTAR:
            if prevp.parent and prevp.parent.type in {
                syms.typedargslist,
                syms.varargslist,
                syms.parameters,
                syms.arglist,
                syms.dictsetmaker,
            }:
                return NO


###############################################################################
# SECTION BECAUSE SECTIONS
###############################################################################

def g():
    NO = ""
    SPACE = " "
    DOUBLESPACE = "  "

    t = leaf.type
    p = leaf.parent
    v = leaf.value

    # Comment because comments

    if t in ALWAYS_NO_SPACE:
        pass
    if t == token.COMMENT:
        return DOUBLESPACE

    # Another comment because more comments
    assert p is not None, f"NOT_YET_IMPLEMENTED_ExprJoinedStr"

    prev = leaf.prev_sibling
    if not prev:
        prevp = preceding_leaf(p)

        if not prevp or prevp.type in OPENING_BRACKETS:
            # Start of the line or a bracketed expression.
            # More than one line for the comment.
            return NO

        if prevp.type == token.EQUAL:
            if prevp.parent and prevp.parent.type in {
                syms.typedargslist,
                syms.varargslist,
                syms.parameters,
                syms.arglist,
                syms.argument,
            }:
                return NO
```

## Black Output

```py
"""Docstring."""


# leading comment
def f():
    NO = ""
    SPACE = " "
    DOUBLESPACE = "  "

    t = leaf.type
    p = leaf.parent  # trailing comment
    v = leaf.value

    if t in ALWAYS_NO_SPACE:
        pass
    if t == token.COMMENT:  # another trailing comment
        return DOUBLESPACE

    assert p is not None, f"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}"

    prev = leaf.prev_sibling
    if not prev:
        prevp = preceding_leaf(p)
        if not prevp or prevp.type in OPENING_BRACKETS:
            return NO

        if prevp.type == token.EQUAL:
            if prevp.parent and prevp.parent.type in {
                syms.typedargslist,
                syms.varargslist,
                syms.parameters,
                syms.arglist,
                syms.argument,
            }:
                return NO

        elif prevp.type == token.DOUBLESTAR:
            if prevp.parent and prevp.parent.type in {
                syms.typedargslist,
                syms.varargslist,
                syms.parameters,
                syms.arglist,
                syms.dictsetmaker,
            }:
                return NO


###############################################################################
# SECTION BECAUSE SECTIONS
###############################################################################


def g():
    NO = ""
    SPACE = " "
    DOUBLESPACE = "  "

    t = leaf.type
    p = leaf.parent
    v = leaf.value

    # Comment because comments

    if t in ALWAYS_NO_SPACE:
        pass
    if t == token.COMMENT:
        return DOUBLESPACE

    # Another comment because more comments
    assert p is not None, f"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}"

    prev = leaf.prev_sibling
    if not prev:
        prevp = preceding_leaf(p)

        if not prevp or prevp.type in OPENING_BRACKETS:
            # Start of the line or a bracketed expression.
            # More than one line for the comment.
            return NO

        if prevp.type == token.EQUAL:
            if prevp.parent and prevp.parent.type in {
                syms.typedargslist,
                syms.varargslist,
                syms.parameters,
                syms.arglist,
                syms.argument,
            }:
                return NO
```


