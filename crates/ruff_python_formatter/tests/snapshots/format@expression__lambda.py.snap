---
source: crates/ruff_python_formatter/tests/fixtures.rs
input_file: crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/lambda.py
---
## Input
```python
# Leading
lambda x: x  # Trailing
# Trailing

# Leading
lambda x, y: x  # Trailing
# Trailing

# Leading
lambda x, y: x, y  # Trailing
# Trailing

# Leading
lambda x, /, y: x  # Trailing
# Trailing

# Leading
lambda x: lambda y: lambda z: x  # Trailing
# Trailing

# Leading
lambda x: lambda y: lambda z: (x, y, z)  # Trailing
# Trailing

# Leading
lambda x: lambda y: lambda z: (
    x,
    y,
z)  # Trailing
# Trailing

# Leading
lambda x: lambda y: lambda z: (
    x,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
z)  # Trailing
# Trailing

a = (
    lambda  # Dangling
           : 1
)

a = (
    lambda x # Dangling
    , y: 1
)

# Regression test: lambda empty arguments ranges were too long, leading to unstable
# formatting
(lambda:(#
),)

# lambda arguments don't have parentheses, so we never add a magic trailing comma ...
def f(
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb = lambda x: y,
):
    pass

# ...but we do preserve a trailing comma after the arguments
a = lambda b,: 0

lambda a,: 0
lambda *args,: 0
lambda **kwds,: 0
lambda a, *args,: 0
lambda a, **kwds,: 0
lambda *args, b,: 0
lambda *, b,: 0
lambda *args, **kwds,: 0
lambda a, *args, b,: 0
lambda a, *, b,: 0
lambda a, *args, **kwds,: 0
lambda *args, b, **kwds,: 0
lambda *, b, **kwds,: 0
lambda a, *args, b, **kwds,: 0
lambda a, *, b, **kwds,: 0
lambda a, /: a
lambda a, /, c: a

# Dangling comments without parameters.
(
    lambda
    : # 3
     None
)

(
    lambda
    # 3
    : None
)

(
    lambda  # 1
    # 2
    : # 3
    # 4
    None # 5
)

(
    lambda
    # comment
    *x: x
)

(
    lambda
    # comment
    *x,
    **y: x
)

(
    lambda
    # comment 1
    *
    # comment 2
    x:
    # comment 3
    x
)

(
    lambda # comment 1
    * # comment 2
    x: # comment 3
    x
)

lambda *x\
    :x

(
    lambda
    # comment
    *\
        x: x
)

lambda: ( # comment
    x)

(
    lambda:  # comment
    x
)

(
    lambda:
    # comment
    x
)

(
    lambda  # comment
    :
    x
)

(
    lambda
    # comment
    :
    x
)

(
    lambda:  # comment
    (  # comment
        x
    )
)

(
    lambda  # 1
    # 2
    x  # 3
    # 4
    :  # 5
    # 6
    x
)

(
    lambda  # 1
    # 2
    x,  # 3
    # 4
    y
    :  # 5
    # 6
    x
)

(
    lambda
    x,
    # comment
    y:
    z
)


# Leading
lambda x: (
    lambda y: lambda z: x
                        + y
                        + y
                        + y
                        + y
                        + y
                        + y
                        + y
                        + y
                        + y
                        + y
                        + y
                        + y
                        + y
                        + y
                        + y
                        + y
                        + y
                        + y
                        + y
                        + y
                        + y
                        + z  # Trailing
)  # Trailing


# Leading
lambda x: lambda y: lambda z: [
    x,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    z
] # Trailing
# Trailing

lambda self, araa, kkkwargs=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs), e=1, f=2, g=2: d

# Regression tests for https://github.com/astral-sh/ruff/issues/8179
def a():
    return b(
        c,
        d,
        e,
        f=lambda self, *args, **kwargs: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(
            *args, **kwargs
        ),
    )

def a():
    return b(
        c,
        d,
        e,
        f=lambda self, araa, kkkwargs,aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
                 args,kwargs,
                 e=1, f=2, g=2: d,
        g = 10
    )

def a():
    return b(
        c,
        d,
        e,
        f=lambda self, *args, **kwargs: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(
            *args, **kwargs
        ) + 1,
    )

# Additional ecosystem cases from https://github.com/astral-sh/ruff/pull/21385
class C:
    def foo():
        mock_service.return_value.bucket.side_effect = lambda name: (
            source_bucket
            if name == source_bucket_name
            else storage.Bucket(mock_service, destination_bucket_name)
        )

class C:
	function_dict: Dict[Text, Callable[[CRFToken], Any]] = {
        CRFEntityExtractorOptions.POS2: lambda crf_token: crf_token.pos_tag[:2]
        if crf_token.pos_tag is not None
        else None,
	}

name = re.sub(r"[^\x21\x23-\x5b\x5d-\x7e]...............", lambda m: f"\\{m.group(0)}", p["name"])

def foo():
    if True:
        if True:
            return (
                lambda x: np.exp(cs(np.log(x.to(u.MeV).value))) * u.MeV * u.cm**2 / u.g
            )

class C:
    _is_recognized_dtype: Callable[[DtypeObj], bool] = lambda x: lib.is_np_dtype(
        x, "M"
    ) or isinstance(x, DatetimeTZDtype)

class C:
    def foo():
        if True:
            transaction_count = self._query_txs_for_range(
                get_count_fn=lambda from_ts, to_ts, _chain_id=chain_id: db_evmtx.count_transactions_in_range(
                    chain_id=_chain_id,
                    from_ts=from_ts,
                    to_ts=to_ts,
                ),
            )

def ddb():
    sql = (
        lambda var, table, n=N: f"""
        CREATE TABLE {table} AS
        SELECT ROW_NUMBER() OVER () AS id, {var}
        FROM (
            SELECT {var}
            FROM RANGE({n}) _ ({var})
            ORDER BY RANDOM()
        )
        """
    )
```

## Output
```python
# Leading
lambda x: x  # Trailing
# Trailing

# Leading
lambda x, y: x  # Trailing
# Trailing

# Leading
lambda x, y: x, y  # Trailing
# Trailing

# Leading
lambda x, /, y: x  # Trailing
# Trailing

# Leading
lambda x: lambda y: lambda z: x  # Trailing
# Trailing

# Leading
lambda x: lambda y: lambda z: (x, y, z)  # Trailing
# Trailing

# Leading
lambda x: lambda y: lambda z: (x, y, z)  # Trailing
# Trailing

# Leading
lambda x: lambda y: lambda z: (
    x,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    z,
)  # Trailing
# Trailing

a = (
    lambda:  # Dangling
    1
)

a = (
    lambda x,  # Dangling
    y: 1
)

# Regression test: lambda empty arguments ranges were too long, leading to unstable
# formatting
(
    lambda: (  #
    ),
)


# lambda arguments don't have parentheses, so we never add a magic trailing comma ...
def f(
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb = lambda x: y,
):
    pass


# ...but we do preserve a trailing comma after the arguments
a = lambda b,: 0

lambda a,: 0
lambda *args,: 0
lambda **kwds,: 0
lambda a, *args,: 0
lambda a, **kwds,: 0
lambda *args, b,: 0
lambda *, b,: 0
lambda *args, **kwds,: 0
lambda a, *args, b,: 0
lambda a, *, b,: 0
lambda a, *args, **kwds,: 0
lambda *args, b, **kwds,: 0
lambda *, b, **kwds,: 0
lambda a, *args, b, **kwds,: 0
lambda a, *, b, **kwds,: 0
lambda a, /: a
lambda a, /, c: a

# Dangling comments without parameters.
(
    lambda:  # 3
    None
)

(
    lambda:
    # 3
    None
)

(
    lambda:  # 1
    # 2
    # 3
    # 4
    None  # 5
)

(
    lambda
    # comment
    *x: x
)

(
    lambda
    # comment
    *x, **y: x
)

(
    lambda
    # comment 1
    # comment 2
    *x:
    # comment 3
    x
)

(
    lambda  # comment 1
    # comment 2
    *x:  # comment 3
    x
)

lambda *x: x

(
    lambda
    # comment
    *x: x
)

lambda: (  # comment
    x
)

(
    lambda:  # comment
    x
)

(
    lambda:
    # comment
    x
)

(
    lambda:  # comment
    x
)

(
    lambda:
    # comment
    x
)

(
    lambda:  # comment
    (  # comment
        x
    )
)

(
    lambda  # 1
    # 2
    x:  # 3
    # 4
    # 5
    # 6
    x
)

(
    lambda  # 1
    # 2
    x,  # 3
    # 4
    y:  # 5
    # 6
    x
)

(
    lambda x,
    # comment
    y: z
)


# Leading
lambda x: (
    lambda y: lambda z: x
    + y
    + y
    + y
    + y
    + y
    + y
    + y
    + y
    + y
    + y
    + y
    + y
    + y
    + y
    + y
    + y
    + y
    + y
    + y
    + y
    + y
    + z  # Trailing
)  # Trailing


# Leading
lambda x: lambda y: lambda z: [
    x,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    y,
    z,
]  # Trailing
# Trailing

lambda self, araa, kkkwargs=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(
    *args, **kwargs
), e=1, f=2, g=2: d


# Regression tests for https://github.com/astral-sh/ruff/issues/8179
def a():
    return b(
        c,
        d,
        e,
        f=lambda self,
        *args,
        **kwargs: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs),
    )


def a():
    return b(
        c,
        d,
        e,
        f=lambda self,
        araa,
        kkkwargs,
        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
        args,
        kwargs,
        e=1,
        f=2,
        g=2: d,
        g=10,
    )


def a():
    return b(
        c,
        d,
        e,
        f=lambda self,
        *args,
        **kwargs: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs) + 1,
    )


# Additional ecosystem cases from https://github.com/astral-sh/ruff/pull/21385
class C:
    def foo():
        mock_service.return_value.bucket.side_effect = lambda name: (
            source_bucket
            if name == source_bucket_name
            else storage.Bucket(mock_service, destination_bucket_name)
        )


class C:
    function_dict: Dict[Text, Callable[[CRFToken], Any]] = {
        CRFEntityExtractorOptions.POS2: lambda crf_token: crf_token.pos_tag[:2]
        if crf_token.pos_tag is not None
        else None,
    }


name = re.sub(
    r"[^\x21\x23-\x5b\x5d-\x7e]...............", lambda m: f"\\{m.group(0)}", p["name"]
)


def foo():
    if True:
        if True:
            return (
                lambda x: np.exp(cs(np.log(x.to(u.MeV).value))) * u.MeV * u.cm**2 / u.g
            )


class C:
    _is_recognized_dtype: Callable[[DtypeObj], bool] = lambda x: lib.is_np_dtype(
        x, "M"
    ) or isinstance(x, DatetimeTZDtype)


class C:
    def foo():
        if True:
            transaction_count = self._query_txs_for_range(
                get_count_fn=lambda from_ts,
                to_ts,
                _chain_id=chain_id: db_evmtx.count_transactions_in_range(
                    chain_id=_chain_id,
                    from_ts=from_ts,
                    to_ts=to_ts,
                ),
            )


def ddb():
    sql = (
        lambda var, table, n=N: f"""
        CREATE TABLE {table} AS
        SELECT ROW_NUMBER() OVER () AS id, {var}
        FROM (
            SELECT {var}
            FROM RANGE({n}) _ ({var})
            ORDER BY RANDOM()
        )
        """
    )
```


## Preview changes
```diff
--- Stable
+++ Preview
@@ -27,30 +27,10 @@
 # Trailing
 
 # Leading
-lambda x: lambda y: lambda z: (
-    x,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    z,
+lambda x: (
+    lambda y: (
+        lambda z: (x, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, z)
+    )
 )  # Trailing
 # Trailing
 
@@ -74,7 +54,9 @@
 
 # lambda arguments don't have parentheses, so we never add a magic trailing comma ...
 def f(
-    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb = lambda x: y,
+    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb = lambda x: (
+        y
+    ),
 ):
     pass
 
@@ -218,71 +200,79 @@
 
 # Leading
 lambda x: (
-    lambda y: lambda z: x
-    + y
-    + y
-    + y
-    + y
-    + y
-    + y
-    + y
-    + y
-    + y
-    + y
-    + y
-    + y
-    + y
-    + y
-    + y
-    + y
-    + y
-    + y
-    + y
-    + y
-    + y
-    + z  # Trailing
+    lambda y: (
+        lambda z: (
+            x
+            + y
+            + y
+            + y
+            + y
+            + y
+            + y
+            + y
+            + y
+            + y
+            + y
+            + y
+            + y
+            + y
+            + y
+            + y
+            + y
+            + y
+            + y
+            + y
+            + y
+            + y
+            + z
+        )
+    )  # Trailing
 )  # Trailing
 
 
 # Leading
-lambda x: lambda y: lambda z: [
-    x,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    y,
-    z,
-]  # Trailing
+lambda x: (
+    lambda y: (
+        lambda z: [
+            x,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            y,
+            z,
+        ]
+    )
+)  # Trailing
 # Trailing
 
-lambda self, araa, kkkwargs=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(
-    *args, **kwargs
-), e=1, f=2, g=2: d
+lambda self, araa, kkkwargs=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs), e=1, f=2, g=2: (
+    d
+)
 
 
 # Regression tests for https://github.com/astral-sh/ruff/issues/8179
@@ -291,9 +281,9 @@
         c,
         d,
         e,
-        f=lambda self,
-        *args,
-        **kwargs: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs),
+        f=lambda self, *args, **kwargs: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(
+            *args, **kwargs
+        ),
     )
 
 
@@ -302,15 +292,9 @@
         c,
         d,
         e,
-        f=lambda self,
-        araa,
-        kkkwargs,
-        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
-        args,
-        kwargs,
-        e=1,
-        f=2,
-        g=2: d,
+        f=lambda self, araa, kkkwargs, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, args, kwargs, e=1, f=2, g=2: (
+            d
+        ),
         g=10,
     )
 
@@ -320,9 +304,9 @@
         c,
         d,
         e,
-        f=lambda self,
-        *args,
-        **kwargs: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs) + 1,
+        f=lambda self, *args, **kwargs: (
+            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs) + 1
+        ),
     )
 
 
@@ -338,9 +322,9 @@
 
 class C:
     function_dict: Dict[Text, Callable[[CRFToken], Any]] = {
-        CRFEntityExtractorOptions.POS2: lambda crf_token: crf_token.pos_tag[:2]
-        if crf_token.pos_tag is not None
-        else None,
+        CRFEntityExtractorOptions.POS2: lambda crf_token: (
+            crf_token.pos_tag[:2] if crf_token.pos_tag is not None else None
+        ),
     }
 
 
@@ -352,24 +336,22 @@
 def foo():
     if True:
         if True:
-            return (
-                lambda x: np.exp(cs(np.log(x.to(u.MeV).value))) * u.MeV * u.cm**2 / u.g
+            return lambda x: (
+                np.exp(cs(np.log(x.to(u.MeV).value))) * u.MeV * u.cm**2 / u.g
             )
 
 
 class C:
-    _is_recognized_dtype: Callable[[DtypeObj], bool] = lambda x: lib.is_np_dtype(
-        x, "M"
-    ) or isinstance(x, DatetimeTZDtype)
+    _is_recognized_dtype: Callable[[DtypeObj], bool] = lambda x: (
+        lib.is_np_dtype(x, "M") or isinstance(x, DatetimeTZDtype)
+    )
 
 
 class C:
     def foo():
         if True:
             transaction_count = self._query_txs_for_range(
-                get_count_fn=lambda from_ts,
-                to_ts,
-                _chain_id=chain_id: db_evmtx.count_transactions_in_range(
+                get_count_fn=lambda from_ts, to_ts, _chain_id=chain_id: db_evmtx.count_transactions_in_range(
                     chain_id=_chain_id,
                     from_ts=from_ts,
                     to_ts=to_ts,
@@ -378,8 +360,8 @@
 
 
 def ddb():
-    sql = (
-        lambda var, table, n=N: f"""
+    sql = lambda var, table, n=N: (
+        f"""
         CREATE TABLE {table} AS
         SELECT ROW_NUMBER() OVER () AS id, {var}
         FROM (
```
