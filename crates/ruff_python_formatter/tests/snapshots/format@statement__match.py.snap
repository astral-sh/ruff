---
source: crates/ruff_python_formatter/tests/fixtures.rs
input_file: crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/match.py
---
## Input
```py
# leading match comment
match foo:  # dangling match comment
    case "bar":
        pass


# leading match comment
match (  # leading expr comment
    # another leading expr comment
    foo  # trailing expr comment
    # another trailing expr comment
):  # dangling match comment
    case "bar":
        pass


# leading match comment
match (  # hello
    foo  # trailing expr comment
    ,  # another
):  # dangling match comment
    case "bar":
        pass


match [  # comment
    first,
    second,
    third
]:  # another comment
    case ["a", "b", "c"]:
        pass

match (  # comment
    "a b c"
).split():  # another comment
    case ["a", "b", "c"]:
        pass


match (  # comment
    # let's go
    yield foo
):  # another comment
    case ["a", "b", "c"]:
        pass


match aaaaaaaaahhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh:  # comment
    case "sshhhhhhhh":
        pass


def foo():
    match inside_func:  # comment
        case "bar":
            pass


match newlines:

    # case 1 leading comment


    case "top level case comment with newlines":  # case dangling comment
        # pass leading comment
        pass
        # pass trailing comment


    # case 2 leading comment



    case "case comment with newlines" if foo == 2:  # second
        pass

    case "one", "newline" if (foo := 1):  # third
        pass


    case "two newlines":
        pass



    case "three newlines":
        pass
    case _:
        pass


match long_lines:
    case "this is a long line for if condition" if aaaaaaaaahhhhhhhh == 1 and bbbbbbaaaaaaaaaaa == 2:  # comment
        pass

    case "this is a long line for if condition with parentheses" if (aaaaaaaaahhhhhhhh == 1 and bbbbbbaaaaaaaaaaa == 2):  # comment
        pass

    case "named expressions aren't special" if foo := 1:
        pass

    case "named expressions aren't that special" if (foo := 1):
        pass

    case "but with already broken long lines" if (
        aaaaaaahhhhhhhhhhh == 1 and
        bbbbbbbbaaaaaahhhh == 2
    ):  # another comment
        pass


match pattern_comments:
    case (
    only_trailing  # trailing 1
    # trailing 2
# trailing 3
    ):
        pass


match pattern_comments:
    case (  # leading
    only_leading
    ):
        pass


match pattern_comments:
    case (
    # leading
    leading_and_trailing  # trailing 1
    # trailing 2
# trailing 3
    ):
        pass


match pattern_comments:
    case (
    no_comments
    ):
        pass
```

## Output
```py
# leading match comment
match foo:  # dangling match comment
    case "NOT_YET_IMPLEMENTED_PatternMatchValue":
        pass


# leading match comment
match (  # leading expr comment
    # another leading expr comment
    foo  # trailing expr comment
    # another trailing expr comment
):  # dangling match comment
    case "NOT_YET_IMPLEMENTED_PatternMatchValue":
        pass


# leading match comment
match (  # hello
    foo,  # trailing expr comment  # another
):  # dangling match comment
    case "NOT_YET_IMPLEMENTED_PatternMatchValue":
        pass


match [  # comment
    first,
    second,
    third,
]:  # another comment
    case [NOT_YET_IMPLEMENTED_PatternMatchSequence, 2]:
        pass

match (  # comment
    "a b c"
).split():  # another comment
    case [NOT_YET_IMPLEMENTED_PatternMatchSequence, 2]:
        pass


match (  # comment
    # let's go
    yield foo
):  # another comment
    case [NOT_YET_IMPLEMENTED_PatternMatchSequence, 2]:
        pass


match aaaaaaaaahhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh:  # comment
    case "NOT_YET_IMPLEMENTED_PatternMatchValue":
        pass


def foo():
    match inside_func:  # comment
        case "NOT_YET_IMPLEMENTED_PatternMatchValue":
            pass


match newlines:
    # case 1 leading comment

    case "NOT_YET_IMPLEMENTED_PatternMatchValue":  # case dangling comment
        # pass leading comment
        pass
        # pass trailing comment

    # case 2 leading comment

    case "NOT_YET_IMPLEMENTED_PatternMatchValue" if foo == 2:  # second
        pass

    case [NOT_YET_IMPLEMENTED_PatternMatchSequence, 2] if (foo := 1):  # third
        pass

    case "NOT_YET_IMPLEMENTED_PatternMatchValue":
        pass

    case "NOT_YET_IMPLEMENTED_PatternMatchValue":
        pass
    case x as NOT_YET_IMPLEMENTED_PatternMatchAs:
        pass


match long_lines:
    case "NOT_YET_IMPLEMENTED_PatternMatchValue" if aaaaaaaaahhhhhhhh == 1 and bbbbbbaaaaaaaaaaa == 2:  # comment
        pass

    case "NOT_YET_IMPLEMENTED_PatternMatchValue" if (
        aaaaaaaaahhhhhhhh == 1 and bbbbbbaaaaaaaaaaa == 2
    ):  # comment
        pass

    case "NOT_YET_IMPLEMENTED_PatternMatchValue" if foo := 1:
        pass

    case "NOT_YET_IMPLEMENTED_PatternMatchValue" if (foo := 1):
        pass

    case "NOT_YET_IMPLEMENTED_PatternMatchValue" if (
        aaaaaaahhhhhhhhhhh == 1 and bbbbbbbbaaaaaahhhh == 2
    ):  # another comment
        pass


match pattern_comments:
    case (
        x as NOT_YET_IMPLEMENTED_PatternMatchAs  # trailing 1
        # trailing 2
        # trailing 3
    ):
        pass


match pattern_comments:
    case (
        # leading
        x as NOT_YET_IMPLEMENTED_PatternMatchAs
    ):
        pass


match pattern_comments:
    case (
        # leading
        x as NOT_YET_IMPLEMENTED_PatternMatchAs  # trailing 1
        # trailing 2
        # trailing 3
    ):
        pass


match pattern_comments:
    case (x as NOT_YET_IMPLEMENTED_PatternMatchAs):
        pass
```



