# This file is used by generate.py to autogenerate our Python AST data model.
#
# We have defined a Rust struct for each syntax node in `src/nodes.rs`.  Many of
# these nodes belong to groups. For instance, there is a `Stmt` group
# consisting of all of the syntax nodes that represent valid Python statements.
#
# There is a special group named `ungrouped` that contains syntax nodes that do
# not belong to any group.
#
# Each group is defined by two sections below. The `[GROUP]` section defines
# options that control the auto-generation for that group. The `[GROUP.nodes]`
# section defines which syntax nodes belong to that group. The name of each
# entry in the nodes section must match the name of the corresponding Rust
# struct. The value of each entry defines options that control the
# auto-generation for that syntax node.
#
# The following group options are available:
#
# add_suffix_to_is_methods: [true/false]
#   Controls the name of the is_foo methods of the group's enums.  If false (the
#   default), these methods will use the variant name in snake_case.  If true,
#   then the group prefix will be moved to the end before snake_casing.  (That
#   is, `StmtIf` will become `if_stmt`.)
#
# anynode_is_label: foo_bar
#   Controls the name of the AnyNodeRef::is_foo_bar method.  The default is the
#   group name in snake_case.
#
# rustdoc:
#   A rustdoc comment that is added to the group's enums.
#
# The following syntax node options are available:
#
# variant:
#   The name of the enum variant for this syntax node.  Defaults to the node
#   name with the group prefix removed.  (That is, `StmtIf` becomes `If`.)

[Mod]
anynode_is_label = "module"
rustdoc = "/// See also [mod](https://docs.python.org/3/library/ast.html#ast.mod)"

[Mod.nodes]
ModModule = {}
ModExpression = {}

[Stmt]
add_suffix_to_is_methods = true
anynode_is_label = "statement"
rustdoc = "/// See also [stmt](https://docs.python.org/3/library/ast.html#ast.stmt)"

[Stmt.nodes]
StmtFunctionDef = {}
StmtClassDef = {}
StmtReturn = {}
StmtDelete = {}
StmtTypeAlias = {}
StmtAssign = {}
StmtAugAssign = {}
StmtAnnAssign = {}
StmtFor = {}
StmtWhile = {}
StmtIf = {}
StmtWith = {}
StmtMatch = {}
StmtRaise = {}
StmtTry = {}
StmtAssert = {}
StmtImport = {}
StmtImportFrom = {}
StmtGlobal = {}
StmtNonlocal = {}
StmtExpr = {}
StmtPass = {}
StmtBreak = {}
StmtContinue = {}
StmtIpyEscapeCommand = {}

[Expr]
add_suffix_to_is_methods = true
anynode_is_label = "expression"
rustdoc = "/// See also [expr](https://docs.python.org/3/library/ast.html#ast.expr)"

[Expr.nodes]
ExprBoolOp = { fields = [
    { name = "op", type = "BoolOp" },
    { name = "values", type = "Expr", seq = true }
]}
ExprNamed = { fields = [
    { name = "target", type = "Expr" },
    { name = "value", type = "Expr" }
]}
ExprBinOp = { fields = [
    { name = "left", type = "Expr" },
    { name = "op", type = "Operator" },
    { name = "right", type = "Expr" }
]}
ExprUnaryOp = { fields = [
    { name = "op", type = "UnaryOp" },
    { name = "operand", type = "Expr" }
]}
ExprLambda = { fields = [
    { name = "parameters", type = "Box<crate::Parameters>", optional = true },
    { name = "body", type = "Expr" }
]}
ExprIf = { fields = [
    { name = "test", type = "Expr" },
    { name = "body", type = "Expr" },
    { name = "orelse", type = "Expr" }
]}
ExprDict = { fields = [
    { name = "items", type = "DictItem", seq = true },
]}
ExprSet = { fields = [
    { name = "elts", type = "Expr", seq = true }
]}
ExprListComp = { fields = [
    { name = "elt", type = "Expr" },
    { name = "generators", type = "Comprehension", seq = true }
]}
ExprSetComp = { fields = [
    { name = "elt", type = "Expr" },
    { name = "generators", type = "Comprehension", seq = true }
]}
ExprDictComp = { fields = [
    { name = "key", type = "Expr" },
    { name = "value", type = "Expr" },
    { name = "generators", type = "Comprehension", seq = true }
]}
ExprGenerator = { fields = [
    { name = "elt", type = "Expr" },
    { name = "generators", type = "Comprehension", seq = true },
    { name = "parenthesized", type = "bool" }
]}
ExprAwait = { fields = [
    { name = "value", type = "Expr" }
]}
ExprYield = { fields = [
    { name = "value", type = "Expr", optional = true }
]}
ExprYieldFrom = { fields = [
    { name = "value", type = "Expr" }
]}
ExprCompare = { fields = [
    { name = "left", type = "Expr" },
    # We don't want this field to be a vec hence the seq is not enabled.
    { name = "ops", type = "Box<[crate::CmpOp]>"},
    { name = "comparators", type = "Box<[Expr]>"}
]}
ExprCall = { fields = [
    { name = "func", type = "Expr" },
    { name = "arguments", type = "Arguments"}
]}
ExprFString = { fields = [
    { name = "value", type = "FStringValue" }
]}
ExprStringLiteral = { fields = [
    { name = "value", type = "StringLiteralValue" }
]}
ExprBytesLiteral = { fields = [
    { name = "value", type = "BytesLiteralValue" }
]}
ExprNumberLiteral = { fields = [
    { name = "value", type = "Number" }
]}
ExprBooleanLiteral = { fields = [
    { name = "value", type = "bool" }
], derives = ["Default"]}
ExprNoneLiteral = { fields = [], derives = ["Default"]}
ExprEllipsisLiteral = { fields = [], derives = ["Default"]}
ExprAttribute = { fields = [
    { name = "value", type = "Expr" },
    { name = "attr", type = "Identifier" },
    { name = "ctx", type = "ExprContext" }
]}
ExprSubscript = { fields = [
    { name = "value", type = "Expr" },
    { name = "slice", type = "Expr" },
    { name = "ctx", type = "ExprContext" }
]}
ExprStarred = { fields = [
    { name = "value", type = "Expr" },
    { name = "ctx", type = "ExprContext" }
]}
ExprName = { fields = [
    { name = "id", type = "name::Name" },
    { name = "ctx", type = "ExprContext" }
]}
ExprList = { fields = [
    { name = "elts", type = "Expr", seq = true },
    { name = "ctx", type = "ExprContext" }
]}
ExprTuple = { fields = [
    { name = "elts", type = "Expr", seq = true },
    { name = "ctx", type = "ExprContext" },
    { name = "parenthesized", type = "bool" }
]}
ExprSlice = { fields = [
    { name = "lower", type = "Expr", optional = true },
    { name = "upper", type = "Expr", optional = true },
    { name = "step", type = "Expr", optional = true }
]}
ExprIpyEscapeCommand = { fields = [
    { name = "kind", type = "IpyEscapeKind" },
    { name = "value", type = "Box<str>" }

]}

[ExceptHandler]
rustdoc = "/// See also [excepthandler](https://docs.python.org/3/library/ast.html#ast.excepthandler)"

[ExceptHandler.nodes]
ExceptHandlerExceptHandler = {}

[FStringElement.nodes]
FStringExpressionElement = {variant = "Expression"}
FStringLiteralElement = {variant = "Literal"}

[Pattern]
rustdoc = "/// See also [pattern](https://docs.python.org/3/library/ast.html#ast.pattern)"

[Pattern.nodes]
PatternMatchValue = {}
PatternMatchSingleton = {}
PatternMatchSequence = {}
PatternMatchMapping = {}
PatternMatchClass = {}
PatternMatchStar = {}
PatternMatchAs = {}
PatternMatchOr = {}

[TypeParam]
rustdoc = "/// See also [type_param](https://docs.python.org/3/library/ast.html#ast.type_param)"

[TypeParam.nodes]
TypeParamTypeVar = {}
TypeParamTypeVarTuple = {}
TypeParamParamSpec = {}

[ungrouped.nodes]
FStringFormatSpec = {}
PatternArguments = {}
PatternKeyword = {}
Comprehension = {}
Arguments = {}
Parameters = {}
Parameter = {}
ParameterWithDefault = {}
Keyword = {}
Alias = {}
WithItem = {}
MatchCase = {}
Decorator = {}
ElifElseClause = {}
TypeParams = {}
FString = {}
StringLiteral = {}
BytesLiteral = {}
Identifier = {}
