// File automatically generated by ast/asdl_rs.py.

#[allow(unused_variables, non_snake_case)]
pub trait Visitor<U = ()> {
    fn visit_stmt(&mut self, node: Stmt) {
        self.generic_visit_stmt(node)
    }
    fn generic_visit_stmt(&mut self, node: Stmt) {
        match node.node {
            StmtKind::FunctionDef(data) => self.visit_stmt_FunctionDef(data),
            StmtKind::AsyncFunctionDef(data) => self.visit_stmt_AsyncFunctionDef(data),
            StmtKind::ClassDef(data) => self.visit_stmt_ClassDef(data),
            StmtKind::Return(data) => self.visit_stmt_Return(data),
            StmtKind::Delete(data) => self.visit_stmt_Delete(data),
            StmtKind::Assign(data) => self.visit_stmt_Assign(data),
            StmtKind::AugAssign(data) => self.visit_stmt_AugAssign(data),
            StmtKind::AnnAssign(data) => self.visit_stmt_AnnAssign(data),
            StmtKind::For(data) => self.visit_stmt_For(data),
            StmtKind::AsyncFor(data) => self.visit_stmt_AsyncFor(data),
            StmtKind::While(data) => self.visit_stmt_While(data),
            StmtKind::If(data) => self.visit_stmt_If(data),
            StmtKind::With(data) => self.visit_stmt_With(data),
            StmtKind::AsyncWith(data) => self.visit_stmt_AsyncWith(data),
            StmtKind::Match(data) => self.visit_stmt_Match(data),
            StmtKind::Raise(data) => self.visit_stmt_Raise(data),
            StmtKind::Try(data) => self.visit_stmt_Try(data),
            StmtKind::TryStar(data) => self.visit_stmt_TryStar(data),
            StmtKind::Assert(data) => self.visit_stmt_Assert(data),
            StmtKind::Import(data) => self.visit_stmt_Import(data),
            StmtKind::ImportFrom(data) => self.visit_stmt_ImportFrom(data),
            StmtKind::Global(data) => self.visit_stmt_Global(data),
            StmtKind::Nonlocal(data) => self.visit_stmt_Nonlocal(data),
            StmtKind::Expr(data) => self.visit_stmt_Expr(data),
            StmtKind::Pass => self.visit_stmt_Pass(()),
            StmtKind::Break => self.visit_stmt_Break(()),
            StmtKind::Continue => self.visit_stmt_Continue(()),
        }
    }
    fn visit_stmt_FunctionDef(&mut self, node: StmtFunctionDef) {
        self.generic_visit_stmt_FunctionDef(node)
    }
    fn generic_visit_stmt_FunctionDef(&mut self, node: StmtFunctionDef) {
        {
            let value = node.args;
            self.visit_arguments(*value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.decorator_list {
            self.visit_expr(value);
        }
        if let Some(value) = node.returns {
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_AsyncFunctionDef(&mut self, node: StmtAsyncFunctionDef) {
        self.generic_visit_stmt_AsyncFunctionDef(node)
    }
    fn generic_visit_stmt_AsyncFunctionDef(&mut self, node: StmtAsyncFunctionDef) {
        {
            let value = node.args;
            self.visit_arguments(*value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.decorator_list {
            self.visit_expr(value);
        }
        if let Some(value) = node.returns {
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_ClassDef(&mut self, node: StmtClassDef) {
        self.generic_visit_stmt_ClassDef(node)
    }
    fn generic_visit_stmt_ClassDef(&mut self, node: StmtClassDef) {
        for value in node.bases {
            self.visit_expr(value);
        }
        for value in node.keywords {
            self.visit_keyword(value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.decorator_list {
            self.visit_expr(value);
        }
    }
    fn visit_stmt_Return(&mut self, node: StmtReturn) {
        self.generic_visit_stmt_Return(node)
    }
    fn generic_visit_stmt_Return(&mut self, node: StmtReturn) {
        if let Some(value) = node.value {
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_Delete(&mut self, node: StmtDelete) {
        self.generic_visit_stmt_Delete(node)
    }
    fn generic_visit_stmt_Delete(&mut self, node: StmtDelete) {
        for value in node.targets {
            self.visit_expr(value);
        }
    }
    fn visit_stmt_Assign(&mut self, node: StmtAssign) {
        self.generic_visit_stmt_Assign(node)
    }
    fn generic_visit_stmt_Assign(&mut self, node: StmtAssign) {
        for value in node.targets {
            self.visit_expr(value);
        }
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_AugAssign(&mut self, node: StmtAugAssign) {
        self.generic_visit_stmt_AugAssign(node)
    }
    fn generic_visit_stmt_AugAssign(&mut self, node: StmtAugAssign) {
        {
            let value = node.target;
            self.visit_expr(*value);
        }
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_AnnAssign(&mut self, node: StmtAnnAssign) {
        self.generic_visit_stmt_AnnAssign(node)
    }
    fn generic_visit_stmt_AnnAssign(&mut self, node: StmtAnnAssign) {
        {
            let value = node.target;
            self.visit_expr(*value);
        }
        {
            let value = node.annotation;
            self.visit_expr(*value);
        }
        if let Some(value) = node.value {
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_For(&mut self, node: StmtFor) {
        self.generic_visit_stmt_For(node)
    }
    fn generic_visit_stmt_For(&mut self, node: StmtFor) {
        {
            let value = node.target;
            self.visit_expr(*value);
        }
        {
            let value = node.iter;
            self.visit_expr(*value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.orelse {
            self.visit_stmt(value);
        }
    }
    fn visit_stmt_AsyncFor(&mut self, node: StmtAsyncFor) {
        self.generic_visit_stmt_AsyncFor(node)
    }
    fn generic_visit_stmt_AsyncFor(&mut self, node: StmtAsyncFor) {
        {
            let value = node.target;
            self.visit_expr(*value);
        }
        {
            let value = node.iter;
            self.visit_expr(*value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.orelse {
            self.visit_stmt(value);
        }
    }
    fn visit_stmt_While(&mut self, node: StmtWhile) {
        self.generic_visit_stmt_While(node)
    }
    fn generic_visit_stmt_While(&mut self, node: StmtWhile) {
        {
            let value = node.test;
            self.visit_expr(*value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.orelse {
            self.visit_stmt(value);
        }
    }
    fn visit_stmt_If(&mut self, node: StmtIf) {
        self.generic_visit_stmt_If(node)
    }
    fn generic_visit_stmt_If(&mut self, node: StmtIf) {
        {
            let value = node.test;
            self.visit_expr(*value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.orelse {
            self.visit_stmt(value);
        }
    }
    fn visit_stmt_With(&mut self, node: StmtWith) {
        self.generic_visit_stmt_With(node)
    }
    fn generic_visit_stmt_With(&mut self, node: StmtWith) {
        for value in node.items {
            self.visit_withitem(value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
    }
    fn visit_stmt_AsyncWith(&mut self, node: StmtAsyncWith) {
        self.generic_visit_stmt_AsyncWith(node)
    }
    fn generic_visit_stmt_AsyncWith(&mut self, node: StmtAsyncWith) {
        for value in node.items {
            self.visit_withitem(value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
    }
    fn visit_stmt_Match(&mut self, node: StmtMatch) {
        self.generic_visit_stmt_Match(node)
    }
    fn generic_visit_stmt_Match(&mut self, node: StmtMatch) {
        {
            let value = node.subject;
            self.visit_expr(*value);
        }
        for value in node.cases {
            self.visit_match_case(value);
        }
    }
    fn visit_stmt_Raise(&mut self, node: StmtRaise) {
        self.generic_visit_stmt_Raise(node)
    }
    fn generic_visit_stmt_Raise(&mut self, node: StmtRaise) {
        if let Some(value) = node.exc {
            self.visit_expr(*value);
        }
        if let Some(value) = node.cause {
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_Try(&mut self, node: StmtTry) {
        self.generic_visit_stmt_Try(node)
    }
    fn generic_visit_stmt_Try(&mut self, node: StmtTry) {
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.handlers {
            self.visit_excepthandler(value);
        }
        for value in node.orelse {
            self.visit_stmt(value);
        }
        for value in node.finalbody {
            self.visit_stmt(value);
        }
    }
    fn visit_stmt_TryStar(&mut self, node: StmtTryStar) {
        self.generic_visit_stmt_TryStar(node)
    }
    fn generic_visit_stmt_TryStar(&mut self, node: StmtTryStar) {
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.handlers {
            self.visit_excepthandler(value);
        }
        for value in node.orelse {
            self.visit_stmt(value);
        }
        for value in node.finalbody {
            self.visit_stmt(value);
        }
    }
    fn visit_stmt_Assert(&mut self, node: StmtAssert) {
        self.generic_visit_stmt_Assert(node)
    }
    fn generic_visit_stmt_Assert(&mut self, node: StmtAssert) {
        {
            let value = node.test;
            self.visit_expr(*value);
        }
        if let Some(value) = node.msg {
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_Import(&mut self, node: StmtImport) {
        self.generic_visit_stmt_Import(node)
    }
    fn generic_visit_stmt_Import(&mut self, node: StmtImport) {
        for value in node.names {
            self.visit_alias(value);
        }
    }
    fn visit_stmt_ImportFrom(&mut self, node: StmtImportFrom) {
        self.generic_visit_stmt_ImportFrom(node)
    }
    fn generic_visit_stmt_ImportFrom(&mut self, node: StmtImportFrom) {
        for value in node.names {
            self.visit_alias(value);
        }
    }
    fn visit_stmt_Global(&mut self, node: StmtGlobal) {
        self.generic_visit_stmt_Global(node)
    }
    fn generic_visit_stmt_Global(&mut self, node: StmtGlobal) {}
    fn visit_stmt_Nonlocal(&mut self, node: StmtNonlocal) {
        self.generic_visit_stmt_Nonlocal(node)
    }
    fn generic_visit_stmt_Nonlocal(&mut self, node: StmtNonlocal) {}
    fn visit_stmt_Expr(&mut self, node: StmtExpr) {
        self.generic_visit_stmt_Expr(node)
    }
    fn generic_visit_stmt_Expr(&mut self, node: StmtExpr) {
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_Pass(&mut self, node: ()) {
        self.generic_visit_stmt_Pass(())
    }
    fn generic_visit_stmt_Pass(&mut self, node: ()) {}
    fn visit_stmt_Break(&mut self, node: ()) {
        self.generic_visit_stmt_Break(())
    }
    fn generic_visit_stmt_Break(&mut self, node: ()) {}
    fn visit_stmt_Continue(&mut self, node: ()) {
        self.generic_visit_stmt_Continue(())
    }
    fn generic_visit_stmt_Continue(&mut self, node: ()) {}
    fn visit_expr(&mut self, node: Expr) {
        self.generic_visit_expr(node)
    }
    fn generic_visit_expr(&mut self, node: Expr) {
        match node.node {
            ExprKind::BoolOp(data) => self.visit_expr_BoolOp(data),
            ExprKind::NamedExpr(data) => self.visit_expr_NamedExpr(data),
            ExprKind::BinOp(data) => self.visit_expr_BinOp(data),
            ExprKind::UnaryOp(data) => self.visit_expr_UnaryOp(data),
            ExprKind::Lambda(data) => self.visit_expr_Lambda(data),
            ExprKind::IfExp(data) => self.visit_expr_IfExp(data),
            ExprKind::Dict(data) => self.visit_expr_Dict(data),
            ExprKind::Set(data) => self.visit_expr_Set(data),
            ExprKind::ListComp(data) => self.visit_expr_ListComp(data),
            ExprKind::SetComp(data) => self.visit_expr_SetComp(data),
            ExprKind::DictComp(data) => self.visit_expr_DictComp(data),
            ExprKind::GeneratorExp(data) => self.visit_expr_GeneratorExp(data),
            ExprKind::Await(data) => self.visit_expr_Await(data),
            ExprKind::Yield(data) => self.visit_expr_Yield(data),
            ExprKind::YieldFrom(data) => self.visit_expr_YieldFrom(data),
            ExprKind::Compare(data) => self.visit_expr_Compare(data),
            ExprKind::Call(data) => self.visit_expr_Call(data),
            ExprKind::FormattedValue(data) => self.visit_expr_FormattedValue(data),
            ExprKind::JoinedStr(data) => self.visit_expr_JoinedStr(data),
            ExprKind::Constant(data) => self.visit_expr_Constant(data),
            ExprKind::Attribute(data) => self.visit_expr_Attribute(data),
            ExprKind::Subscript(data) => self.visit_expr_Subscript(data),
            ExprKind::Starred(data) => self.visit_expr_Starred(data),
            ExprKind::Name(data) => self.visit_expr_Name(data),
            ExprKind::List(data) => self.visit_expr_List(data),
            ExprKind::Tuple(data) => self.visit_expr_Tuple(data),
            ExprKind::Slice(data) => self.visit_expr_Slice(data),
        }
    }
    fn visit_expr_BoolOp(&mut self, node: ExprBoolOp) {
        self.generic_visit_expr_BoolOp(node)
    }
    fn generic_visit_expr_BoolOp(&mut self, node: ExprBoolOp) {
        for value in node.values {
            self.visit_expr(value);
        }
    }
    fn visit_expr_NamedExpr(&mut self, node: ExprNamedExpr) {
        self.generic_visit_expr_NamedExpr(node)
    }
    fn generic_visit_expr_NamedExpr(&mut self, node: ExprNamedExpr) {
        {
            let value = node.target;
            self.visit_expr(*value);
        }
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_BinOp(&mut self, node: ExprBinOp) {
        self.generic_visit_expr_BinOp(node)
    }
    fn generic_visit_expr_BinOp(&mut self, node: ExprBinOp) {
        {
            let value = node.left;
            self.visit_expr(*value);
        }
        {
            let value = node.right;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_UnaryOp(&mut self, node: ExprUnaryOp) {
        self.generic_visit_expr_UnaryOp(node)
    }
    fn generic_visit_expr_UnaryOp(&mut self, node: ExprUnaryOp) {
        {
            let value = node.operand;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_Lambda(&mut self, node: ExprLambda) {
        self.generic_visit_expr_Lambda(node)
    }
    fn generic_visit_expr_Lambda(&mut self, node: ExprLambda) {
        {
            let value = node.args;
            self.visit_arguments(*value);
        }
        {
            let value = node.body;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_IfExp(&mut self, node: ExprIfExp) {
        self.generic_visit_expr_IfExp(node)
    }
    fn generic_visit_expr_IfExp(&mut self, node: ExprIfExp) {
        {
            let value = node.test;
            self.visit_expr(*value);
        }
        {
            let value = node.body;
            self.visit_expr(*value);
        }
        {
            let value = node.orelse;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_Dict(&mut self, node: ExprDict) {
        self.generic_visit_expr_Dict(node)
    }
    fn generic_visit_expr_Dict(&mut self, node: ExprDict) {
        for value in node.keys.into_iter().flatten() {
            self.visit_expr(value);
        }
        for value in node.values {
            self.visit_expr(value);
        }
    }
    fn visit_expr_Set(&mut self, node: ExprSet) {
        self.generic_visit_expr_Set(node)
    }
    fn generic_visit_expr_Set(&mut self, node: ExprSet) {
        for value in node.elts {
            self.visit_expr(value);
        }
    }
    fn visit_expr_ListComp(&mut self, node: ExprListComp) {
        self.generic_visit_expr_ListComp(node)
    }
    fn generic_visit_expr_ListComp(&mut self, node: ExprListComp) {
        {
            let value = node.elt;
            self.visit_expr(*value);
        }
        for value in node.generators {
            self.visit_comprehension(value);
        }
    }
    fn visit_expr_SetComp(&mut self, node: ExprSetComp) {
        self.generic_visit_expr_SetComp(node)
    }
    fn generic_visit_expr_SetComp(&mut self, node: ExprSetComp) {
        {
            let value = node.elt;
            self.visit_expr(*value);
        }
        for value in node.generators {
            self.visit_comprehension(value);
        }
    }
    fn visit_expr_DictComp(&mut self, node: ExprDictComp) {
        self.generic_visit_expr_DictComp(node)
    }
    fn generic_visit_expr_DictComp(&mut self, node: ExprDictComp) {
        {
            let value = node.key;
            self.visit_expr(*value);
        }
        {
            let value = node.value;
            self.visit_expr(*value);
        }
        for value in node.generators {
            self.visit_comprehension(value);
        }
    }
    fn visit_expr_GeneratorExp(&mut self, node: ExprGeneratorExp) {
        self.generic_visit_expr_GeneratorExp(node)
    }
    fn generic_visit_expr_GeneratorExp(&mut self, node: ExprGeneratorExp) {
        {
            let value = node.elt;
            self.visit_expr(*value);
        }
        for value in node.generators {
            self.visit_comprehension(value);
        }
    }
    fn visit_expr_Await(&mut self, node: ExprAwait) {
        self.generic_visit_expr_Await(node)
    }
    fn generic_visit_expr_Await(&mut self, node: ExprAwait) {
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_Yield(&mut self, node: ExprYield) {
        self.generic_visit_expr_Yield(node)
    }
    fn generic_visit_expr_Yield(&mut self, node: ExprYield) {
        if let Some(value) = node.value {
            self.visit_expr(*value);
        }
    }
    fn visit_expr_YieldFrom(&mut self, node: ExprYieldFrom) {
        self.generic_visit_expr_YieldFrom(node)
    }
    fn generic_visit_expr_YieldFrom(&mut self, node: ExprYieldFrom) {
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_Compare(&mut self, node: ExprCompare) {
        self.generic_visit_expr_Compare(node)
    }
    fn generic_visit_expr_Compare(&mut self, node: ExprCompare) {
        {
            let value = node.left;
            self.visit_expr(*value);
        }
        for value in node.comparators {
            self.visit_expr(value);
        }
    }
    fn visit_expr_Call(&mut self, node: ExprCall) {
        self.generic_visit_expr_Call(node)
    }
    fn generic_visit_expr_Call(&mut self, node: ExprCall) {
        {
            let value = node.func;
            self.visit_expr(*value);
        }
        for value in node.args {
            self.visit_expr(value);
        }
        for value in node.keywords {
            self.visit_keyword(value);
        }
    }
    fn visit_expr_FormattedValue(&mut self, node: ExprFormattedValue) {
        self.generic_visit_expr_FormattedValue(node)
    }
    fn generic_visit_expr_FormattedValue(&mut self, node: ExprFormattedValue) {
        {
            let value = node.value;
            self.visit_expr(*value);
        }
        if let Some(value) = node.format_spec {
            self.visit_expr(*value);
        }
    }
    fn visit_expr_JoinedStr(&mut self, node: ExprJoinedStr) {
        self.generic_visit_expr_JoinedStr(node)
    }
    fn generic_visit_expr_JoinedStr(&mut self, node: ExprJoinedStr) {
        for value in node.values {
            self.visit_expr(value);
        }
    }
    fn visit_expr_Constant(&mut self, node: ExprConstant) {
        self.generic_visit_expr_Constant(node)
    }
    fn generic_visit_expr_Constant(&mut self, node: ExprConstant) {}
    fn visit_expr_Attribute(&mut self, node: ExprAttribute) {
        self.generic_visit_expr_Attribute(node)
    }
    fn generic_visit_expr_Attribute(&mut self, node: ExprAttribute) {
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_Subscript(&mut self, node: ExprSubscript) {
        self.generic_visit_expr_Subscript(node)
    }
    fn generic_visit_expr_Subscript(&mut self, node: ExprSubscript) {
        {
            let value = node.value;
            self.visit_expr(*value);
        }
        {
            let value = node.slice;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_Starred(&mut self, node: ExprStarred) {
        self.generic_visit_expr_Starred(node)
    }
    fn generic_visit_expr_Starred(&mut self, node: ExprStarred) {
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_Name(&mut self, node: ExprName) {
        self.generic_visit_expr_Name(node)
    }
    fn generic_visit_expr_Name(&mut self, node: ExprName) {}
    fn visit_expr_List(&mut self, node: ExprList) {
        self.generic_visit_expr_List(node)
    }
    fn generic_visit_expr_List(&mut self, node: ExprList) {
        for value in node.elts {
            self.visit_expr(value);
        }
    }
    fn visit_expr_Tuple(&mut self, node: ExprTuple) {
        self.generic_visit_expr_Tuple(node)
    }
    fn generic_visit_expr_Tuple(&mut self, node: ExprTuple) {
        for value in node.elts {
            self.visit_expr(value);
        }
    }
    fn visit_expr_Slice(&mut self, node: ExprSlice) {
        self.generic_visit_expr_Slice(node)
    }
    fn generic_visit_expr_Slice(&mut self, node: ExprSlice) {
        if let Some(value) = node.lower {
            self.visit_expr(*value);
        }
        if let Some(value) = node.upper {
            self.visit_expr(*value);
        }
        if let Some(value) = node.step {
            self.visit_expr(*value);
        }
    }
    fn visit_expr_context(&mut self, node: ExprContext) {
        self.generic_visit_expr_context(node)
    }
    fn generic_visit_expr_context(&mut self, node: ExprContext) {}
    fn visit_boolop(&mut self, node: Boolop) {
        self.generic_visit_boolop(node)
    }
    fn generic_visit_boolop(&mut self, node: Boolop) {}
    fn visit_operator(&mut self, node: Operator) {
        self.generic_visit_operator(node)
    }
    fn generic_visit_operator(&mut self, node: Operator) {}
    fn visit_unaryop(&mut self, node: Unaryop) {
        self.generic_visit_unaryop(node)
    }
    fn generic_visit_unaryop(&mut self, node: Unaryop) {}
    fn visit_cmpop(&mut self, node: Cmpop) {
        self.generic_visit_cmpop(node)
    }
    fn generic_visit_cmpop(&mut self, node: Cmpop) {}
    fn visit_comprehension(&mut self, node: Comprehension) {
        self.generic_visit_comprehension(node)
    }
    fn generic_visit_comprehension(&mut self, node: Comprehension) {}
    fn visit_excepthandler(&mut self, node: Excepthandler) {
        self.generic_visit_excepthandler(node)
    }
    fn generic_visit_excepthandler(&mut self, node: Excepthandler) {
        match node.node {
            ExcepthandlerKind::ExceptHandler(data) => self.visit_excepthandler_ExceptHandler(data),
        }
    }
    fn visit_excepthandler_ExceptHandler(&mut self, node: ExcepthandlerExceptHandler) {
        self.generic_visit_excepthandler_ExceptHandler(node)
    }
    fn generic_visit_excepthandler_ExceptHandler(&mut self, node: ExcepthandlerExceptHandler) {
        if let Some(value) = node.type_ {
            self.visit_expr(*value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
    }
    fn visit_arguments(&mut self, node: Arguments) {
        self.generic_visit_arguments(node)
    }
    fn generic_visit_arguments(&mut self, node: Arguments) {}
    fn visit_arg(&mut self, node: Arg) {
        self.generic_visit_arg(node)
    }
    fn generic_visit_arg(&mut self, node: Arg) {}
    fn visit_keyword(&mut self, node: Keyword) {
        self.generic_visit_keyword(node)
    }
    fn generic_visit_keyword(&mut self, node: Keyword) {}
    fn visit_alias(&mut self, node: Alias) {
        self.generic_visit_alias(node)
    }
    fn generic_visit_alias(&mut self, node: Alias) {}
    fn visit_withitem(&mut self, node: Withitem) {
        self.generic_visit_withitem(node)
    }
    fn generic_visit_withitem(&mut self, node: Withitem) {}
    fn visit_match_case(&mut self, node: MatchCase) {
        self.generic_visit_match_case(node)
    }
    fn generic_visit_match_case(&mut self, node: MatchCase) {}
    fn visit_pattern(&mut self, node: Pattern) {
        self.generic_visit_pattern(node)
    }
    fn generic_visit_pattern(&mut self, node: Pattern) {
        match node.node {
            PatternKind::MatchValue(data) => self.visit_pattern_MatchValue(data),
            PatternKind::MatchSingleton(data) => self.visit_pattern_MatchSingleton(data),
            PatternKind::MatchSequence(data) => self.visit_pattern_MatchSequence(data),
            PatternKind::MatchMapping(data) => self.visit_pattern_MatchMapping(data),
            PatternKind::MatchClass(data) => self.visit_pattern_MatchClass(data),
            PatternKind::MatchStar(data) => self.visit_pattern_MatchStar(data),
            PatternKind::MatchAs(data) => self.visit_pattern_MatchAs(data),
            PatternKind::MatchOr(data) => self.visit_pattern_MatchOr(data),
        }
    }
    fn visit_pattern_MatchValue(&mut self, node: PatternMatchValue) {
        self.generic_visit_pattern_MatchValue(node)
    }
    fn generic_visit_pattern_MatchValue(&mut self, node: PatternMatchValue) {
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_pattern_MatchSingleton(&mut self, node: PatternMatchSingleton) {
        self.generic_visit_pattern_MatchSingleton(node)
    }
    fn generic_visit_pattern_MatchSingleton(&mut self, node: PatternMatchSingleton) {}
    fn visit_pattern_MatchSequence(&mut self, node: PatternMatchSequence) {
        self.generic_visit_pattern_MatchSequence(node)
    }
    fn generic_visit_pattern_MatchSequence(&mut self, node: PatternMatchSequence) {
        for value in node.patterns {
            self.visit_pattern(value);
        }
    }
    fn visit_pattern_MatchMapping(&mut self, node: PatternMatchMapping) {
        self.generic_visit_pattern_MatchMapping(node)
    }
    fn generic_visit_pattern_MatchMapping(&mut self, node: PatternMatchMapping) {
        for value in node.keys {
            self.visit_expr(value);
        }
        for value in node.patterns {
            self.visit_pattern(value);
        }
    }
    fn visit_pattern_MatchClass(&mut self, node: PatternMatchClass) {
        self.generic_visit_pattern_MatchClass(node)
    }
    fn generic_visit_pattern_MatchClass(&mut self, node: PatternMatchClass) {
        {
            let value = node.cls;
            self.visit_expr(*value);
        }
        for value in node.patterns {
            self.visit_pattern(value);
        }
        for value in node.kwd_patterns {
            self.visit_pattern(value);
        }
    }
    fn visit_pattern_MatchStar(&mut self, node: PatternMatchStar) {
        self.generic_visit_pattern_MatchStar(node)
    }
    fn generic_visit_pattern_MatchStar(&mut self, node: PatternMatchStar) {}
    fn visit_pattern_MatchAs(&mut self, node: PatternMatchAs) {
        self.generic_visit_pattern_MatchAs(node)
    }
    fn generic_visit_pattern_MatchAs(&mut self, node: PatternMatchAs) {
        if let Some(value) = node.pattern {
            self.visit_pattern(*value);
        }
    }
    fn visit_pattern_MatchOr(&mut self, node: PatternMatchOr) {
        self.generic_visit_pattern_MatchOr(node)
    }
    fn generic_visit_pattern_MatchOr(&mut self, node: PatternMatchOr) {
        for value in node.patterns {
            self.visit_pattern(value);
        }
    }
}
