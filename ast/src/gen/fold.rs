// File automatically generated by ast/asdl_rs.py.

pub trait Fold<U> {
    type TargetU;
    type Error;
    type UserContext;

    fn will_map_user(&mut self, user: &U) -> Self::UserContext;
    #[cfg(feature = "all-nodes-with-ranges")]
    fn will_map_user_cfg(&mut self, user: &U) -> Self::UserContext {
        self.will_map_user(user)
    }
    #[cfg(not(feature = "all-nodes-with-ranges"))]
    fn will_map_user_cfg(
        &mut self,
        _user: &crate::EmptyRange<U>,
    ) -> crate::EmptyRange<Self::TargetU> {
        crate::EmptyRange::default()
    }
    fn map_user(
        &mut self,
        user: U,
        context: Self::UserContext,
    ) -> Result<Self::TargetU, Self::Error>;
    #[cfg(feature = "all-nodes-with-ranges")]
    fn map_user_cfg(
        &mut self,
        user: U,
        context: Self::UserContext,
    ) -> Result<Self::TargetU, Self::Error> {
        self.map_user(user, context)
    }
    #[cfg(not(feature = "all-nodes-with-ranges"))]
    fn map_user_cfg(
        &mut self,
        _user: crate::EmptyRange<U>,
        _context: crate::EmptyRange<Self::TargetU>,
    ) -> Result<crate::EmptyRange<Self::TargetU>, Self::Error> {
        Ok(crate::EmptyRange::default())
    }

    fn fold<X: Foldable<U, Self::TargetU>>(&mut self, node: X) -> Result<X::Mapped, Self::Error> {
        node.fold(self)
    }
    fn fold_mod(&mut self, node: Mod<U>) -> Result<Mod<Self::TargetU>, Self::Error> {
        fold_mod(self, node)
    }
    fn fold_mod_module(
        &mut self,
        node: ModModule<U>,
    ) -> Result<ModModule<Self::TargetU>, Self::Error> {
        fold_mod_module(self, node)
    }
    fn fold_mod_interactive(
        &mut self,
        node: ModInteractive<U>,
    ) -> Result<ModInteractive<Self::TargetU>, Self::Error> {
        fold_mod_interactive(self, node)
    }
    fn fold_mod_expression(
        &mut self,
        node: ModExpression<U>,
    ) -> Result<ModExpression<Self::TargetU>, Self::Error> {
        fold_mod_expression(self, node)
    }
    fn fold_mod_function_type(
        &mut self,
        node: ModFunctionType<U>,
    ) -> Result<ModFunctionType<Self::TargetU>, Self::Error> {
        fold_mod_function_type(self, node)
    }
    fn fold_stmt(&mut self, node: Stmt<U>) -> Result<Stmt<Self::TargetU>, Self::Error> {
        fold_stmt(self, node)
    }
    fn fold_stmt_function_def(
        &mut self,
        node: StmtFunctionDef<U>,
    ) -> Result<StmtFunctionDef<Self::TargetU>, Self::Error> {
        fold_stmt_function_def(self, node)
    }
    fn fold_stmt_async_function_def(
        &mut self,
        node: StmtAsyncFunctionDef<U>,
    ) -> Result<StmtAsyncFunctionDef<Self::TargetU>, Self::Error> {
        fold_stmt_async_function_def(self, node)
    }
    fn fold_stmt_class_def(
        &mut self,
        node: StmtClassDef<U>,
    ) -> Result<StmtClassDef<Self::TargetU>, Self::Error> {
        fold_stmt_class_def(self, node)
    }
    fn fold_stmt_return(
        &mut self,
        node: StmtReturn<U>,
    ) -> Result<StmtReturn<Self::TargetU>, Self::Error> {
        fold_stmt_return(self, node)
    }
    fn fold_stmt_delete(
        &mut self,
        node: StmtDelete<U>,
    ) -> Result<StmtDelete<Self::TargetU>, Self::Error> {
        fold_stmt_delete(self, node)
    }
    fn fold_stmt_assign(
        &mut self,
        node: StmtAssign<U>,
    ) -> Result<StmtAssign<Self::TargetU>, Self::Error> {
        fold_stmt_assign(self, node)
    }
    fn fold_stmt_aug_assign(
        &mut self,
        node: StmtAugAssign<U>,
    ) -> Result<StmtAugAssign<Self::TargetU>, Self::Error> {
        fold_stmt_aug_assign(self, node)
    }
    fn fold_stmt_ann_assign(
        &mut self,
        node: StmtAnnAssign<U>,
    ) -> Result<StmtAnnAssign<Self::TargetU>, Self::Error> {
        fold_stmt_ann_assign(self, node)
    }
    fn fold_stmt_for(&mut self, node: StmtFor<U>) -> Result<StmtFor<Self::TargetU>, Self::Error> {
        fold_stmt_for(self, node)
    }
    fn fold_stmt_async_for(
        &mut self,
        node: StmtAsyncFor<U>,
    ) -> Result<StmtAsyncFor<Self::TargetU>, Self::Error> {
        fold_stmt_async_for(self, node)
    }
    fn fold_stmt_while(
        &mut self,
        node: StmtWhile<U>,
    ) -> Result<StmtWhile<Self::TargetU>, Self::Error> {
        fold_stmt_while(self, node)
    }
    fn fold_stmt_if(&mut self, node: StmtIf<U>) -> Result<StmtIf<Self::TargetU>, Self::Error> {
        fold_stmt_if(self, node)
    }
    fn fold_stmt_with(
        &mut self,
        node: StmtWith<U>,
    ) -> Result<StmtWith<Self::TargetU>, Self::Error> {
        fold_stmt_with(self, node)
    }
    fn fold_stmt_async_with(
        &mut self,
        node: StmtAsyncWith<U>,
    ) -> Result<StmtAsyncWith<Self::TargetU>, Self::Error> {
        fold_stmt_async_with(self, node)
    }
    fn fold_stmt_match(
        &mut self,
        node: StmtMatch<U>,
    ) -> Result<StmtMatch<Self::TargetU>, Self::Error> {
        fold_stmt_match(self, node)
    }
    fn fold_stmt_raise(
        &mut self,
        node: StmtRaise<U>,
    ) -> Result<StmtRaise<Self::TargetU>, Self::Error> {
        fold_stmt_raise(self, node)
    }
    fn fold_stmt_try(&mut self, node: StmtTry<U>) -> Result<StmtTry<Self::TargetU>, Self::Error> {
        fold_stmt_try(self, node)
    }
    fn fold_stmt_try_star(
        &mut self,
        node: StmtTryStar<U>,
    ) -> Result<StmtTryStar<Self::TargetU>, Self::Error> {
        fold_stmt_try_star(self, node)
    }
    fn fold_stmt_assert(
        &mut self,
        node: StmtAssert<U>,
    ) -> Result<StmtAssert<Self::TargetU>, Self::Error> {
        fold_stmt_assert(self, node)
    }
    fn fold_stmt_import(
        &mut self,
        node: StmtImport<U>,
    ) -> Result<StmtImport<Self::TargetU>, Self::Error> {
        fold_stmt_import(self, node)
    }
    fn fold_stmt_import_from(
        &mut self,
        node: StmtImportFrom<U>,
    ) -> Result<StmtImportFrom<Self::TargetU>, Self::Error> {
        fold_stmt_import_from(self, node)
    }
    fn fold_stmt_global(
        &mut self,
        node: StmtGlobal<U>,
    ) -> Result<StmtGlobal<Self::TargetU>, Self::Error> {
        fold_stmt_global(self, node)
    }
    fn fold_stmt_nonlocal(
        &mut self,
        node: StmtNonlocal<U>,
    ) -> Result<StmtNonlocal<Self::TargetU>, Self::Error> {
        fold_stmt_nonlocal(self, node)
    }
    fn fold_stmt_expr(
        &mut self,
        node: StmtExpr<U>,
    ) -> Result<StmtExpr<Self::TargetU>, Self::Error> {
        fold_stmt_expr(self, node)
    }
    fn fold_stmt_pass(
        &mut self,
        node: StmtPass<U>,
    ) -> Result<StmtPass<Self::TargetU>, Self::Error> {
        fold_stmt_pass(self, node)
    }
    fn fold_stmt_break(
        &mut self,
        node: StmtBreak<U>,
    ) -> Result<StmtBreak<Self::TargetU>, Self::Error> {
        fold_stmt_break(self, node)
    }
    fn fold_stmt_continue(
        &mut self,
        node: StmtContinue<U>,
    ) -> Result<StmtContinue<Self::TargetU>, Self::Error> {
        fold_stmt_continue(self, node)
    }
    fn fold_expr(&mut self, node: Expr<U>) -> Result<Expr<Self::TargetU>, Self::Error> {
        fold_expr(self, node)
    }
    fn fold_expr_bool_op(
        &mut self,
        node: ExprBoolOp<U>,
    ) -> Result<ExprBoolOp<Self::TargetU>, Self::Error> {
        fold_expr_bool_op(self, node)
    }
    fn fold_expr_named_expr(
        &mut self,
        node: ExprNamedExpr<U>,
    ) -> Result<ExprNamedExpr<Self::TargetU>, Self::Error> {
        fold_expr_named_expr(self, node)
    }
    fn fold_expr_bin_op(
        &mut self,
        node: ExprBinOp<U>,
    ) -> Result<ExprBinOp<Self::TargetU>, Self::Error> {
        fold_expr_bin_op(self, node)
    }
    fn fold_expr_unary_op(
        &mut self,
        node: ExprUnaryOp<U>,
    ) -> Result<ExprUnaryOp<Self::TargetU>, Self::Error> {
        fold_expr_unary_op(self, node)
    }
    fn fold_expr_lambda(
        &mut self,
        node: ExprLambda<U>,
    ) -> Result<ExprLambda<Self::TargetU>, Self::Error> {
        fold_expr_lambda(self, node)
    }
    fn fold_expr_if_exp(
        &mut self,
        node: ExprIfExp<U>,
    ) -> Result<ExprIfExp<Self::TargetU>, Self::Error> {
        fold_expr_if_exp(self, node)
    }
    fn fold_expr_dict(
        &mut self,
        node: ExprDict<U>,
    ) -> Result<ExprDict<Self::TargetU>, Self::Error> {
        fold_expr_dict(self, node)
    }
    fn fold_expr_set(&mut self, node: ExprSet<U>) -> Result<ExprSet<Self::TargetU>, Self::Error> {
        fold_expr_set(self, node)
    }
    fn fold_expr_list_comp(
        &mut self,
        node: ExprListComp<U>,
    ) -> Result<ExprListComp<Self::TargetU>, Self::Error> {
        fold_expr_list_comp(self, node)
    }
    fn fold_expr_set_comp(
        &mut self,
        node: ExprSetComp<U>,
    ) -> Result<ExprSetComp<Self::TargetU>, Self::Error> {
        fold_expr_set_comp(self, node)
    }
    fn fold_expr_dict_comp(
        &mut self,
        node: ExprDictComp<U>,
    ) -> Result<ExprDictComp<Self::TargetU>, Self::Error> {
        fold_expr_dict_comp(self, node)
    }
    fn fold_expr_generator_exp(
        &mut self,
        node: ExprGeneratorExp<U>,
    ) -> Result<ExprGeneratorExp<Self::TargetU>, Self::Error> {
        fold_expr_generator_exp(self, node)
    }
    fn fold_expr_await(
        &mut self,
        node: ExprAwait<U>,
    ) -> Result<ExprAwait<Self::TargetU>, Self::Error> {
        fold_expr_await(self, node)
    }
    fn fold_expr_yield(
        &mut self,
        node: ExprYield<U>,
    ) -> Result<ExprYield<Self::TargetU>, Self::Error> {
        fold_expr_yield(self, node)
    }
    fn fold_expr_yield_from(
        &mut self,
        node: ExprYieldFrom<U>,
    ) -> Result<ExprYieldFrom<Self::TargetU>, Self::Error> {
        fold_expr_yield_from(self, node)
    }
    fn fold_expr_compare(
        &mut self,
        node: ExprCompare<U>,
    ) -> Result<ExprCompare<Self::TargetU>, Self::Error> {
        fold_expr_compare(self, node)
    }
    fn fold_expr_call(
        &mut self,
        node: ExprCall<U>,
    ) -> Result<ExprCall<Self::TargetU>, Self::Error> {
        fold_expr_call(self, node)
    }
    fn fold_expr_formatted_value(
        &mut self,
        node: ExprFormattedValue<U>,
    ) -> Result<ExprFormattedValue<Self::TargetU>, Self::Error> {
        fold_expr_formatted_value(self, node)
    }
    fn fold_expr_joined_str(
        &mut self,
        node: ExprJoinedStr<U>,
    ) -> Result<ExprJoinedStr<Self::TargetU>, Self::Error> {
        fold_expr_joined_str(self, node)
    }
    fn fold_expr_constant(
        &mut self,
        node: ExprConstant<U>,
    ) -> Result<ExprConstant<Self::TargetU>, Self::Error> {
        fold_expr_constant(self, node)
    }
    fn fold_expr_attribute(
        &mut self,
        node: ExprAttribute<U>,
    ) -> Result<ExprAttribute<Self::TargetU>, Self::Error> {
        fold_expr_attribute(self, node)
    }
    fn fold_expr_subscript(
        &mut self,
        node: ExprSubscript<U>,
    ) -> Result<ExprSubscript<Self::TargetU>, Self::Error> {
        fold_expr_subscript(self, node)
    }
    fn fold_expr_starred(
        &mut self,
        node: ExprStarred<U>,
    ) -> Result<ExprStarred<Self::TargetU>, Self::Error> {
        fold_expr_starred(self, node)
    }
    fn fold_expr_name(
        &mut self,
        node: ExprName<U>,
    ) -> Result<ExprName<Self::TargetU>, Self::Error> {
        fold_expr_name(self, node)
    }
    fn fold_expr_list(
        &mut self,
        node: ExprList<U>,
    ) -> Result<ExprList<Self::TargetU>, Self::Error> {
        fold_expr_list(self, node)
    }
    fn fold_expr_tuple(
        &mut self,
        node: ExprTuple<U>,
    ) -> Result<ExprTuple<Self::TargetU>, Self::Error> {
        fold_expr_tuple(self, node)
    }
    fn fold_expr_slice(
        &mut self,
        node: ExprSlice<U>,
    ) -> Result<ExprSlice<Self::TargetU>, Self::Error> {
        fold_expr_slice(self, node)
    }
    fn fold_expr_context(&mut self, node: ExprContext) -> Result<ExprContext, Self::Error> {
        fold_expr_context(self, node)
    }
    fn fold_boolop(&mut self, node: BoolOp) -> Result<BoolOp, Self::Error> {
        fold_boolop(self, node)
    }
    fn fold_operator(&mut self, node: Operator) -> Result<Operator, Self::Error> {
        fold_operator(self, node)
    }
    fn fold_unaryop(&mut self, node: UnaryOp) -> Result<UnaryOp, Self::Error> {
        fold_unaryop(self, node)
    }
    fn fold_cmpop(&mut self, node: CmpOp) -> Result<CmpOp, Self::Error> {
        fold_cmpop(self, node)
    }
    fn fold_comprehension(
        &mut self,
        node: Comprehension<U>,
    ) -> Result<Comprehension<Self::TargetU>, Self::Error> {
        fold_comprehension(self, node)
    }
    fn fold_excepthandler(
        &mut self,
        node: ExceptHandler<U>,
    ) -> Result<ExceptHandler<Self::TargetU>, Self::Error> {
        fold_excepthandler(self, node)
    }
    fn fold_excepthandler_except_handler(
        &mut self,
        node: ExceptHandlerExceptHandler<U>,
    ) -> Result<ExceptHandlerExceptHandler<Self::TargetU>, Self::Error> {
        fold_excepthandler_except_handler(self, node)
    }
    fn fold_arguments(
        &mut self,
        node: Arguments<U>,
    ) -> Result<Arguments<Self::TargetU>, Self::Error> {
        fold_arguments(self, node)
    }
    fn fold_arg(&mut self, node: Arg<U>) -> Result<Arg<Self::TargetU>, Self::Error> {
        fold_arg(self, node)
    }
    fn fold_keyword(&mut self, node: Keyword<U>) -> Result<Keyword<Self::TargetU>, Self::Error> {
        fold_keyword(self, node)
    }
    fn fold_alias(&mut self, node: Alias<U>) -> Result<Alias<Self::TargetU>, Self::Error> {
        fold_alias(self, node)
    }
    fn fold_withitem(&mut self, node: WithItem<U>) -> Result<WithItem<Self::TargetU>, Self::Error> {
        fold_withitem(self, node)
    }
    fn fold_match_case(
        &mut self,
        node: MatchCase<U>,
    ) -> Result<MatchCase<Self::TargetU>, Self::Error> {
        fold_match_case(self, node)
    }
    fn fold_pattern(&mut self, node: Pattern<U>) -> Result<Pattern<Self::TargetU>, Self::Error> {
        fold_pattern(self, node)
    }
    fn fold_pattern_match_value(
        &mut self,
        node: PatternMatchValue<U>,
    ) -> Result<PatternMatchValue<Self::TargetU>, Self::Error> {
        fold_pattern_match_value(self, node)
    }
    fn fold_pattern_match_singleton(
        &mut self,
        node: PatternMatchSingleton<U>,
    ) -> Result<PatternMatchSingleton<Self::TargetU>, Self::Error> {
        fold_pattern_match_singleton(self, node)
    }
    fn fold_pattern_match_sequence(
        &mut self,
        node: PatternMatchSequence<U>,
    ) -> Result<PatternMatchSequence<Self::TargetU>, Self::Error> {
        fold_pattern_match_sequence(self, node)
    }
    fn fold_pattern_match_mapping(
        &mut self,
        node: PatternMatchMapping<U>,
    ) -> Result<PatternMatchMapping<Self::TargetU>, Self::Error> {
        fold_pattern_match_mapping(self, node)
    }
    fn fold_pattern_match_class(
        &mut self,
        node: PatternMatchClass<U>,
    ) -> Result<PatternMatchClass<Self::TargetU>, Self::Error> {
        fold_pattern_match_class(self, node)
    }
    fn fold_pattern_match_star(
        &mut self,
        node: PatternMatchStar<U>,
    ) -> Result<PatternMatchStar<Self::TargetU>, Self::Error> {
        fold_pattern_match_star(self, node)
    }
    fn fold_pattern_match_as(
        &mut self,
        node: PatternMatchAs<U>,
    ) -> Result<PatternMatchAs<Self::TargetU>, Self::Error> {
        fold_pattern_match_as(self, node)
    }
    fn fold_pattern_match_or(
        &mut self,
        node: PatternMatchOr<U>,
    ) -> Result<PatternMatchOr<Self::TargetU>, Self::Error> {
        fold_pattern_match_or(self, node)
    }
    fn fold_type_ignore(
        &mut self,
        node: TypeIgnore<U>,
    ) -> Result<TypeIgnore<Self::TargetU>, Self::Error> {
        fold_type_ignore(self, node)
    }
    fn fold_type_ignore_type_ignore(
        &mut self,
        node: TypeIgnoreTypeIgnore<U>,
    ) -> Result<TypeIgnoreTypeIgnore<Self::TargetU>, Self::Error> {
        fold_type_ignore_type_ignore(self, node)
    }
    fn fold_decorator(
        &mut self,
        node: Decorator<U>,
    ) -> Result<Decorator<Self::TargetU>, Self::Error> {
        fold_decorator(self, node)
    }
    fn fold_arg_with_default(
        &mut self,
        node: ArgWithDefault<U>,
    ) -> Result<ArgWithDefault<Self::TargetU>, Self::Error> {
        fold_arg_with_default(self, node)
    }
}
impl<T, U> Foldable<T, U> for Mod<T> {
    type Mapped = Mod<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_mod(self)
    }
}
pub fn fold_mod<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Mod<U>,
) -> Result<Mod<F::TargetU>, F::Error> {
    let folded = match node {
        Mod::Module(cons) => Mod::Module(Foldable::fold(cons, folder)?),
        Mod::Interactive(cons) => Mod::Interactive(Foldable::fold(cons, folder)?),
        Mod::Expression(cons) => Mod::Expression(Foldable::fold(cons, folder)?),
        Mod::FunctionType(cons) => Mod::FunctionType(Foldable::fold(cons, folder)?),
    };
    Ok(folded)
}
impl<T, U> Foldable<T, U> for ModModule<T> {
    type Mapped = ModModule<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_mod_module(self)
    }
}
pub fn fold_mod_module<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ModModule<U>,
) -> Result<ModModule<F::TargetU>, F::Error> {
    let ModModule {
        body,
        type_ignores,
        range,
    } = node;
    let context = folder.will_map_user_cfg(&range);

    let body = Foldable::fold(body, folder)?;
    let type_ignores = Foldable::fold(type_ignores, folder)?;
    let range = folder.map_user_cfg(range, context)?;
    Ok(ModModule {
        body,
        type_ignores,
        range,
    })
}
impl<T, U> Foldable<T, U> for ModInteractive<T> {
    type Mapped = ModInteractive<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_mod_interactive(self)
    }
}
pub fn fold_mod_interactive<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ModInteractive<U>,
) -> Result<ModInteractive<F::TargetU>, F::Error> {
    let ModInteractive { body, range } = node;
    let context = folder.will_map_user_cfg(&range);

    let body = Foldable::fold(body, folder)?;
    let range = folder.map_user_cfg(range, context)?;
    Ok(ModInteractive { body, range })
}
impl<T, U> Foldable<T, U> for ModExpression<T> {
    type Mapped = ModExpression<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_mod_expression(self)
    }
}
pub fn fold_mod_expression<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ModExpression<U>,
) -> Result<ModExpression<F::TargetU>, F::Error> {
    let ModExpression { body, range } = node;
    let context = folder.will_map_user_cfg(&range);

    let body = Foldable::fold(body, folder)?;
    let range = folder.map_user_cfg(range, context)?;
    Ok(ModExpression { body, range })
}
impl<T, U> Foldable<T, U> for ModFunctionType<T> {
    type Mapped = ModFunctionType<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_mod_function_type(self)
    }
}
pub fn fold_mod_function_type<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ModFunctionType<U>,
) -> Result<ModFunctionType<F::TargetU>, F::Error> {
    let ModFunctionType {
        argtypes,
        returns,
        range,
    } = node;
    let context = folder.will_map_user_cfg(&range);

    let argtypes = Foldable::fold(argtypes, folder)?;
    let returns = Foldable::fold(returns, folder)?;
    let range = folder.map_user_cfg(range, context)?;
    Ok(ModFunctionType {
        argtypes,
        returns,
        range,
    })
}
impl<T, U> Foldable<T, U> for Stmt<T> {
    type Mapped = Stmt<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt(self)
    }
}
pub fn fold_stmt<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Stmt<U>,
) -> Result<Stmt<F::TargetU>, F::Error> {
    let folded = match node {
        Stmt::FunctionDef(cons) => Stmt::FunctionDef(Foldable::fold(cons, folder)?),
        Stmt::AsyncFunctionDef(cons) => Stmt::AsyncFunctionDef(Foldable::fold(cons, folder)?),
        Stmt::ClassDef(cons) => Stmt::ClassDef(Foldable::fold(cons, folder)?),
        Stmt::Return(cons) => Stmt::Return(Foldable::fold(cons, folder)?),
        Stmt::Delete(cons) => Stmt::Delete(Foldable::fold(cons, folder)?),
        Stmt::Assign(cons) => Stmt::Assign(Foldable::fold(cons, folder)?),
        Stmt::AugAssign(cons) => Stmt::AugAssign(Foldable::fold(cons, folder)?),
        Stmt::AnnAssign(cons) => Stmt::AnnAssign(Foldable::fold(cons, folder)?),
        Stmt::For(cons) => Stmt::For(Foldable::fold(cons, folder)?),
        Stmt::AsyncFor(cons) => Stmt::AsyncFor(Foldable::fold(cons, folder)?),
        Stmt::While(cons) => Stmt::While(Foldable::fold(cons, folder)?),
        Stmt::If(cons) => Stmt::If(Foldable::fold(cons, folder)?),
        Stmt::With(cons) => Stmt::With(Foldable::fold(cons, folder)?),
        Stmt::AsyncWith(cons) => Stmt::AsyncWith(Foldable::fold(cons, folder)?),
        Stmt::Match(cons) => Stmt::Match(Foldable::fold(cons, folder)?),
        Stmt::Raise(cons) => Stmt::Raise(Foldable::fold(cons, folder)?),
        Stmt::Try(cons) => Stmt::Try(Foldable::fold(cons, folder)?),
        Stmt::TryStar(cons) => Stmt::TryStar(Foldable::fold(cons, folder)?),
        Stmt::Assert(cons) => Stmt::Assert(Foldable::fold(cons, folder)?),
        Stmt::Import(cons) => Stmt::Import(Foldable::fold(cons, folder)?),
        Stmt::ImportFrom(cons) => Stmt::ImportFrom(Foldable::fold(cons, folder)?),
        Stmt::Global(cons) => Stmt::Global(Foldable::fold(cons, folder)?),
        Stmt::Nonlocal(cons) => Stmt::Nonlocal(Foldable::fold(cons, folder)?),
        Stmt::Expr(cons) => Stmt::Expr(Foldable::fold(cons, folder)?),
        Stmt::Pass(cons) => Stmt::Pass(Foldable::fold(cons, folder)?),
        Stmt::Break(cons) => Stmt::Break(Foldable::fold(cons, folder)?),
        Stmt::Continue(cons) => Stmt::Continue(Foldable::fold(cons, folder)?),
    };
    Ok(folded)
}
impl<T, U> Foldable<T, U> for StmtFunctionDef<T> {
    type Mapped = StmtFunctionDef<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_function_def(self)
    }
}
pub fn fold_stmt_function_def<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtFunctionDef<U>,
) -> Result<StmtFunctionDef<F::TargetU>, F::Error> {
    let StmtFunctionDef {
        name,
        args,
        body,
        decorator_list,
        returns,
        type_comment,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let name = Foldable::fold(name, folder)?;
    let args = Foldable::fold(args, folder)?;
    let body = Foldable::fold(body, folder)?;
    let decorator_list = Foldable::fold(decorator_list, folder)?;
    let returns = Foldable::fold(returns, folder)?;
    let type_comment = Foldable::fold(type_comment, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtFunctionDef {
        name,
        args,
        body,
        decorator_list,
        returns,
        type_comment,
        range,
    })
}
impl<T, U> Foldable<T, U> for StmtAsyncFunctionDef<T> {
    type Mapped = StmtAsyncFunctionDef<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_async_function_def(self)
    }
}
pub fn fold_stmt_async_function_def<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtAsyncFunctionDef<U>,
) -> Result<StmtAsyncFunctionDef<F::TargetU>, F::Error> {
    let StmtAsyncFunctionDef {
        name,
        args,
        body,
        decorator_list,
        returns,
        type_comment,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let name = Foldable::fold(name, folder)?;
    let args = Foldable::fold(args, folder)?;
    let body = Foldable::fold(body, folder)?;
    let decorator_list = Foldable::fold(decorator_list, folder)?;
    let returns = Foldable::fold(returns, folder)?;
    let type_comment = Foldable::fold(type_comment, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtAsyncFunctionDef {
        name,
        args,
        body,
        decorator_list,
        returns,
        type_comment,
        range,
    })
}
impl<T, U> Foldable<T, U> for StmtClassDef<T> {
    type Mapped = StmtClassDef<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_class_def(self)
    }
}
pub fn fold_stmt_class_def<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtClassDef<U>,
) -> Result<StmtClassDef<F::TargetU>, F::Error> {
    let StmtClassDef {
        name,
        bases,
        keywords,
        body,
        decorator_list,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let name = Foldable::fold(name, folder)?;
    let bases = Foldable::fold(bases, folder)?;
    let keywords = Foldable::fold(keywords, folder)?;
    let body = Foldable::fold(body, folder)?;
    let decorator_list = Foldable::fold(decorator_list, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtClassDef {
        name,
        bases,
        keywords,
        body,
        decorator_list,
        range,
    })
}
impl<T, U> Foldable<T, U> for StmtReturn<T> {
    type Mapped = StmtReturn<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_return(self)
    }
}
pub fn fold_stmt_return<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtReturn<U>,
) -> Result<StmtReturn<F::TargetU>, F::Error> {
    let StmtReturn { value, range } = node;
    let context = folder.will_map_user(&range);

    let value = Foldable::fold(value, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtReturn { value, range })
}
impl<T, U> Foldable<T, U> for StmtDelete<T> {
    type Mapped = StmtDelete<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_delete(self)
    }
}
pub fn fold_stmt_delete<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtDelete<U>,
) -> Result<StmtDelete<F::TargetU>, F::Error> {
    let StmtDelete { targets, range } = node;
    let context = folder.will_map_user(&range);

    let targets = Foldable::fold(targets, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtDelete { targets, range })
}
impl<T, U> Foldable<T, U> for StmtAssign<T> {
    type Mapped = StmtAssign<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_assign(self)
    }
}
pub fn fold_stmt_assign<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtAssign<U>,
) -> Result<StmtAssign<F::TargetU>, F::Error> {
    let StmtAssign {
        targets,
        value,
        type_comment,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let targets = Foldable::fold(targets, folder)?;
    let value = Foldable::fold(value, folder)?;
    let type_comment = Foldable::fold(type_comment, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtAssign {
        targets,
        value,
        type_comment,
        range,
    })
}
impl<T, U> Foldable<T, U> for StmtAugAssign<T> {
    type Mapped = StmtAugAssign<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_aug_assign(self)
    }
}
pub fn fold_stmt_aug_assign<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtAugAssign<U>,
) -> Result<StmtAugAssign<F::TargetU>, F::Error> {
    let StmtAugAssign {
        target,
        op,
        value,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let target = Foldable::fold(target, folder)?;
    let op = Foldable::fold(op, folder)?;
    let value = Foldable::fold(value, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtAugAssign {
        target,
        op,
        value,
        range,
    })
}
impl<T, U> Foldable<T, U> for StmtAnnAssign<T> {
    type Mapped = StmtAnnAssign<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_ann_assign(self)
    }
}
pub fn fold_stmt_ann_assign<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtAnnAssign<U>,
) -> Result<StmtAnnAssign<F::TargetU>, F::Error> {
    let StmtAnnAssign {
        target,
        annotation,
        value,
        simple,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let target = Foldable::fold(target, folder)?;
    let annotation = Foldable::fold(annotation, folder)?;
    let value = Foldable::fold(value, folder)?;
    let simple = Foldable::fold(simple, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtAnnAssign {
        target,
        annotation,
        value,
        simple,
        range,
    })
}
impl<T, U> Foldable<T, U> for StmtFor<T> {
    type Mapped = StmtFor<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_for(self)
    }
}
pub fn fold_stmt_for<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtFor<U>,
) -> Result<StmtFor<F::TargetU>, F::Error> {
    let StmtFor {
        target,
        iter,
        body,
        orelse,
        type_comment,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let target = Foldable::fold(target, folder)?;
    let iter = Foldable::fold(iter, folder)?;
    let body = Foldable::fold(body, folder)?;
    let orelse = Foldable::fold(orelse, folder)?;
    let type_comment = Foldable::fold(type_comment, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtFor {
        target,
        iter,
        body,
        orelse,
        type_comment,
        range,
    })
}
impl<T, U> Foldable<T, U> for StmtAsyncFor<T> {
    type Mapped = StmtAsyncFor<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_async_for(self)
    }
}
pub fn fold_stmt_async_for<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtAsyncFor<U>,
) -> Result<StmtAsyncFor<F::TargetU>, F::Error> {
    let StmtAsyncFor {
        target,
        iter,
        body,
        orelse,
        type_comment,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let target = Foldable::fold(target, folder)?;
    let iter = Foldable::fold(iter, folder)?;
    let body = Foldable::fold(body, folder)?;
    let orelse = Foldable::fold(orelse, folder)?;
    let type_comment = Foldable::fold(type_comment, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtAsyncFor {
        target,
        iter,
        body,
        orelse,
        type_comment,
        range,
    })
}
impl<T, U> Foldable<T, U> for StmtWhile<T> {
    type Mapped = StmtWhile<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_while(self)
    }
}
pub fn fold_stmt_while<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtWhile<U>,
) -> Result<StmtWhile<F::TargetU>, F::Error> {
    let StmtWhile {
        test,
        body,
        orelse,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let test = Foldable::fold(test, folder)?;
    let body = Foldable::fold(body, folder)?;
    let orelse = Foldable::fold(orelse, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtWhile {
        test,
        body,
        orelse,
        range,
    })
}
impl<T, U> Foldable<T, U> for StmtIf<T> {
    type Mapped = StmtIf<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_if(self)
    }
}
pub fn fold_stmt_if<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtIf<U>,
) -> Result<StmtIf<F::TargetU>, F::Error> {
    let StmtIf {
        test,
        body,
        orelse,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let test = Foldable::fold(test, folder)?;
    let body = Foldable::fold(body, folder)?;
    let orelse = Foldable::fold(orelse, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtIf {
        test,
        body,
        orelse,
        range,
    })
}
impl<T, U> Foldable<T, U> for StmtWith<T> {
    type Mapped = StmtWith<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_with(self)
    }
}
pub fn fold_stmt_with<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtWith<U>,
) -> Result<StmtWith<F::TargetU>, F::Error> {
    let StmtWith {
        items,
        body,
        type_comment,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let items = Foldable::fold(items, folder)?;
    let body = Foldable::fold(body, folder)?;
    let type_comment = Foldable::fold(type_comment, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtWith {
        items,
        body,
        type_comment,
        range,
    })
}
impl<T, U> Foldable<T, U> for StmtAsyncWith<T> {
    type Mapped = StmtAsyncWith<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_async_with(self)
    }
}
pub fn fold_stmt_async_with<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtAsyncWith<U>,
) -> Result<StmtAsyncWith<F::TargetU>, F::Error> {
    let StmtAsyncWith {
        items,
        body,
        type_comment,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let items = Foldable::fold(items, folder)?;
    let body = Foldable::fold(body, folder)?;
    let type_comment = Foldable::fold(type_comment, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtAsyncWith {
        items,
        body,
        type_comment,
        range,
    })
}
impl<T, U> Foldable<T, U> for StmtMatch<T> {
    type Mapped = StmtMatch<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_match(self)
    }
}
pub fn fold_stmt_match<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtMatch<U>,
) -> Result<StmtMatch<F::TargetU>, F::Error> {
    let StmtMatch {
        subject,
        cases,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let subject = Foldable::fold(subject, folder)?;
    let cases = Foldable::fold(cases, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtMatch {
        subject,
        cases,
        range,
    })
}
impl<T, U> Foldable<T, U> for StmtRaise<T> {
    type Mapped = StmtRaise<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_raise(self)
    }
}
pub fn fold_stmt_raise<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtRaise<U>,
) -> Result<StmtRaise<F::TargetU>, F::Error> {
    let StmtRaise { exc, cause, range } = node;
    let context = folder.will_map_user(&range);

    let exc = Foldable::fold(exc, folder)?;
    let cause = Foldable::fold(cause, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtRaise { exc, cause, range })
}
impl<T, U> Foldable<T, U> for StmtTry<T> {
    type Mapped = StmtTry<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_try(self)
    }
}
pub fn fold_stmt_try<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtTry<U>,
) -> Result<StmtTry<F::TargetU>, F::Error> {
    let StmtTry {
        body,
        handlers,
        orelse,
        finalbody,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let body = Foldable::fold(body, folder)?;
    let handlers = Foldable::fold(handlers, folder)?;
    let orelse = Foldable::fold(orelse, folder)?;
    let finalbody = Foldable::fold(finalbody, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtTry {
        body,
        handlers,
        orelse,
        finalbody,
        range,
    })
}
impl<T, U> Foldable<T, U> for StmtTryStar<T> {
    type Mapped = StmtTryStar<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_try_star(self)
    }
}
pub fn fold_stmt_try_star<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtTryStar<U>,
) -> Result<StmtTryStar<F::TargetU>, F::Error> {
    let StmtTryStar {
        body,
        handlers,
        orelse,
        finalbody,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let body = Foldable::fold(body, folder)?;
    let handlers = Foldable::fold(handlers, folder)?;
    let orelse = Foldable::fold(orelse, folder)?;
    let finalbody = Foldable::fold(finalbody, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtTryStar {
        body,
        handlers,
        orelse,
        finalbody,
        range,
    })
}
impl<T, U> Foldable<T, U> for StmtAssert<T> {
    type Mapped = StmtAssert<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_assert(self)
    }
}
pub fn fold_stmt_assert<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtAssert<U>,
) -> Result<StmtAssert<F::TargetU>, F::Error> {
    let StmtAssert { test, msg, range } = node;
    let context = folder.will_map_user(&range);

    let test = Foldable::fold(test, folder)?;
    let msg = Foldable::fold(msg, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtAssert { test, msg, range })
}
impl<T, U> Foldable<T, U> for StmtImport<T> {
    type Mapped = StmtImport<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_import(self)
    }
}
pub fn fold_stmt_import<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtImport<U>,
) -> Result<StmtImport<F::TargetU>, F::Error> {
    let StmtImport { names, range } = node;
    let context = folder.will_map_user(&range);

    let names = Foldable::fold(names, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtImport { names, range })
}
impl<T, U> Foldable<T, U> for StmtImportFrom<T> {
    type Mapped = StmtImportFrom<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_import_from(self)
    }
}
pub fn fold_stmt_import_from<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtImportFrom<U>,
) -> Result<StmtImportFrom<F::TargetU>, F::Error> {
    let StmtImportFrom {
        module,
        names,
        level,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let module = Foldable::fold(module, folder)?;
    let names = Foldable::fold(names, folder)?;
    let level = Foldable::fold(level, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtImportFrom {
        module,
        names,
        level,
        range,
    })
}
impl<T, U> Foldable<T, U> for StmtGlobal<T> {
    type Mapped = StmtGlobal<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_global(self)
    }
}
pub fn fold_stmt_global<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtGlobal<U>,
) -> Result<StmtGlobal<F::TargetU>, F::Error> {
    let StmtGlobal { names, range } = node;
    let context = folder.will_map_user(&range);

    let names = Foldable::fold(names, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtGlobal { names, range })
}
impl<T, U> Foldable<T, U> for StmtNonlocal<T> {
    type Mapped = StmtNonlocal<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_nonlocal(self)
    }
}
pub fn fold_stmt_nonlocal<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtNonlocal<U>,
) -> Result<StmtNonlocal<F::TargetU>, F::Error> {
    let StmtNonlocal { names, range } = node;
    let context = folder.will_map_user(&range);

    let names = Foldable::fold(names, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtNonlocal { names, range })
}
impl<T, U> Foldable<T, U> for StmtExpr<T> {
    type Mapped = StmtExpr<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_expr(self)
    }
}
pub fn fold_stmt_expr<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtExpr<U>,
) -> Result<StmtExpr<F::TargetU>, F::Error> {
    let StmtExpr { value, range } = node;
    let context = folder.will_map_user(&range);

    let value = Foldable::fold(value, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(StmtExpr { value, range })
}
impl<T, U> Foldable<T, U> for StmtPass<T> {
    type Mapped = StmtPass<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_pass(self)
    }
}
pub fn fold_stmt_pass<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtPass<U>,
) -> Result<StmtPass<F::TargetU>, F::Error> {
    let StmtPass { range } = node;
    let context = folder.will_map_user(&range);

    let range = folder.map_user(range, context)?;
    Ok(StmtPass { range })
}
impl<T, U> Foldable<T, U> for StmtBreak<T> {
    type Mapped = StmtBreak<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_break(self)
    }
}
pub fn fold_stmt_break<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtBreak<U>,
) -> Result<StmtBreak<F::TargetU>, F::Error> {
    let StmtBreak { range } = node;
    let context = folder.will_map_user(&range);

    let range = folder.map_user(range, context)?;
    Ok(StmtBreak { range })
}
impl<T, U> Foldable<T, U> for StmtContinue<T> {
    type Mapped = StmtContinue<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt_continue(self)
    }
}
pub fn fold_stmt_continue<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: StmtContinue<U>,
) -> Result<StmtContinue<F::TargetU>, F::Error> {
    let StmtContinue { range } = node;
    let context = folder.will_map_user(&range);

    let range = folder.map_user(range, context)?;
    Ok(StmtContinue { range })
}
impl<T, U> Foldable<T, U> for Expr<T> {
    type Mapped = Expr<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr(self)
    }
}
pub fn fold_expr<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Expr<U>,
) -> Result<Expr<F::TargetU>, F::Error> {
    let folded = match node {
        Expr::BoolOp(cons) => Expr::BoolOp(Foldable::fold(cons, folder)?),
        Expr::NamedExpr(cons) => Expr::NamedExpr(Foldable::fold(cons, folder)?),
        Expr::BinOp(cons) => Expr::BinOp(Foldable::fold(cons, folder)?),
        Expr::UnaryOp(cons) => Expr::UnaryOp(Foldable::fold(cons, folder)?),
        Expr::Lambda(cons) => Expr::Lambda(Foldable::fold(cons, folder)?),
        Expr::IfExp(cons) => Expr::IfExp(Foldable::fold(cons, folder)?),
        Expr::Dict(cons) => Expr::Dict(Foldable::fold(cons, folder)?),
        Expr::Set(cons) => Expr::Set(Foldable::fold(cons, folder)?),
        Expr::ListComp(cons) => Expr::ListComp(Foldable::fold(cons, folder)?),
        Expr::SetComp(cons) => Expr::SetComp(Foldable::fold(cons, folder)?),
        Expr::DictComp(cons) => Expr::DictComp(Foldable::fold(cons, folder)?),
        Expr::GeneratorExp(cons) => Expr::GeneratorExp(Foldable::fold(cons, folder)?),
        Expr::Await(cons) => Expr::Await(Foldable::fold(cons, folder)?),
        Expr::Yield(cons) => Expr::Yield(Foldable::fold(cons, folder)?),
        Expr::YieldFrom(cons) => Expr::YieldFrom(Foldable::fold(cons, folder)?),
        Expr::Compare(cons) => Expr::Compare(Foldable::fold(cons, folder)?),
        Expr::Call(cons) => Expr::Call(Foldable::fold(cons, folder)?),
        Expr::FormattedValue(cons) => Expr::FormattedValue(Foldable::fold(cons, folder)?),
        Expr::JoinedStr(cons) => Expr::JoinedStr(Foldable::fold(cons, folder)?),
        Expr::Constant(cons) => Expr::Constant(Foldable::fold(cons, folder)?),
        Expr::Attribute(cons) => Expr::Attribute(Foldable::fold(cons, folder)?),
        Expr::Subscript(cons) => Expr::Subscript(Foldable::fold(cons, folder)?),
        Expr::Starred(cons) => Expr::Starred(Foldable::fold(cons, folder)?),
        Expr::Name(cons) => Expr::Name(Foldable::fold(cons, folder)?),
        Expr::List(cons) => Expr::List(Foldable::fold(cons, folder)?),
        Expr::Tuple(cons) => Expr::Tuple(Foldable::fold(cons, folder)?),
        Expr::Slice(cons) => Expr::Slice(Foldable::fold(cons, folder)?),
    };
    Ok(folded)
}
impl<T, U> Foldable<T, U> for ExprBoolOp<T> {
    type Mapped = ExprBoolOp<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_bool_op(self)
    }
}
pub fn fold_expr_bool_op<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprBoolOp<U>,
) -> Result<ExprBoolOp<F::TargetU>, F::Error> {
    let ExprBoolOp { op, values, range } = node;
    let context = folder.will_map_user(&range);

    let op = Foldable::fold(op, folder)?;
    let values = Foldable::fold(values, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprBoolOp { op, values, range })
}
impl<T, U> Foldable<T, U> for ExprNamedExpr<T> {
    type Mapped = ExprNamedExpr<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_named_expr(self)
    }
}
pub fn fold_expr_named_expr<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprNamedExpr<U>,
) -> Result<ExprNamedExpr<F::TargetU>, F::Error> {
    let ExprNamedExpr {
        target,
        value,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let target = Foldable::fold(target, folder)?;
    let value = Foldable::fold(value, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprNamedExpr {
        target,
        value,
        range,
    })
}
impl<T, U> Foldable<T, U> for ExprBinOp<T> {
    type Mapped = ExprBinOp<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_bin_op(self)
    }
}
pub fn fold_expr_bin_op<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprBinOp<U>,
) -> Result<ExprBinOp<F::TargetU>, F::Error> {
    let ExprBinOp {
        left,
        op,
        right,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let left = Foldable::fold(left, folder)?;
    let op = Foldable::fold(op, folder)?;
    let right = Foldable::fold(right, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprBinOp {
        left,
        op,
        right,
        range,
    })
}
impl<T, U> Foldable<T, U> for ExprUnaryOp<T> {
    type Mapped = ExprUnaryOp<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_unary_op(self)
    }
}
pub fn fold_expr_unary_op<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprUnaryOp<U>,
) -> Result<ExprUnaryOp<F::TargetU>, F::Error> {
    let ExprUnaryOp { op, operand, range } = node;
    let context = folder.will_map_user(&range);

    let op = Foldable::fold(op, folder)?;
    let operand = Foldable::fold(operand, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprUnaryOp { op, operand, range })
}
impl<T, U> Foldable<T, U> for ExprLambda<T> {
    type Mapped = ExprLambda<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_lambda(self)
    }
}
pub fn fold_expr_lambda<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprLambda<U>,
) -> Result<ExprLambda<F::TargetU>, F::Error> {
    let ExprLambda { args, body, range } = node;
    let context = folder.will_map_user(&range);

    let args = Foldable::fold(args, folder)?;
    let body = Foldable::fold(body, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprLambda { args, body, range })
}
impl<T, U> Foldable<T, U> for ExprIfExp<T> {
    type Mapped = ExprIfExp<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_if_exp(self)
    }
}
pub fn fold_expr_if_exp<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprIfExp<U>,
) -> Result<ExprIfExp<F::TargetU>, F::Error> {
    let ExprIfExp {
        test,
        body,
        orelse,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let test = Foldable::fold(test, folder)?;
    let body = Foldable::fold(body, folder)?;
    let orelse = Foldable::fold(orelse, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprIfExp {
        test,
        body,
        orelse,
        range,
    })
}
impl<T, U> Foldable<T, U> for ExprDict<T> {
    type Mapped = ExprDict<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_dict(self)
    }
}
pub fn fold_expr_dict<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprDict<U>,
) -> Result<ExprDict<F::TargetU>, F::Error> {
    let ExprDict {
        keys,
        values,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let keys = Foldable::fold(keys, folder)?;
    let values = Foldable::fold(values, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprDict {
        keys,
        values,
        range,
    })
}
impl<T, U> Foldable<T, U> for ExprSet<T> {
    type Mapped = ExprSet<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_set(self)
    }
}
pub fn fold_expr_set<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprSet<U>,
) -> Result<ExprSet<F::TargetU>, F::Error> {
    let ExprSet { elts, range } = node;
    let context = folder.will_map_user(&range);

    let elts = Foldable::fold(elts, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprSet { elts, range })
}
impl<T, U> Foldable<T, U> for ExprListComp<T> {
    type Mapped = ExprListComp<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_list_comp(self)
    }
}
pub fn fold_expr_list_comp<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprListComp<U>,
) -> Result<ExprListComp<F::TargetU>, F::Error> {
    let ExprListComp {
        elt,
        generators,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let elt = Foldable::fold(elt, folder)?;
    let generators = Foldable::fold(generators, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprListComp {
        elt,
        generators,
        range,
    })
}
impl<T, U> Foldable<T, U> for ExprSetComp<T> {
    type Mapped = ExprSetComp<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_set_comp(self)
    }
}
pub fn fold_expr_set_comp<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprSetComp<U>,
) -> Result<ExprSetComp<F::TargetU>, F::Error> {
    let ExprSetComp {
        elt,
        generators,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let elt = Foldable::fold(elt, folder)?;
    let generators = Foldable::fold(generators, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprSetComp {
        elt,
        generators,
        range,
    })
}
impl<T, U> Foldable<T, U> for ExprDictComp<T> {
    type Mapped = ExprDictComp<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_dict_comp(self)
    }
}
pub fn fold_expr_dict_comp<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprDictComp<U>,
) -> Result<ExprDictComp<F::TargetU>, F::Error> {
    let ExprDictComp {
        key,
        value,
        generators,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let key = Foldable::fold(key, folder)?;
    let value = Foldable::fold(value, folder)?;
    let generators = Foldable::fold(generators, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprDictComp {
        key,
        value,
        generators,
        range,
    })
}
impl<T, U> Foldable<T, U> for ExprGeneratorExp<T> {
    type Mapped = ExprGeneratorExp<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_generator_exp(self)
    }
}
pub fn fold_expr_generator_exp<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprGeneratorExp<U>,
) -> Result<ExprGeneratorExp<F::TargetU>, F::Error> {
    let ExprGeneratorExp {
        elt,
        generators,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let elt = Foldable::fold(elt, folder)?;
    let generators = Foldable::fold(generators, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprGeneratorExp {
        elt,
        generators,
        range,
    })
}
impl<T, U> Foldable<T, U> for ExprAwait<T> {
    type Mapped = ExprAwait<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_await(self)
    }
}
pub fn fold_expr_await<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprAwait<U>,
) -> Result<ExprAwait<F::TargetU>, F::Error> {
    let ExprAwait { value, range } = node;
    let context = folder.will_map_user(&range);

    let value = Foldable::fold(value, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprAwait { value, range })
}
impl<T, U> Foldable<T, U> for ExprYield<T> {
    type Mapped = ExprYield<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_yield(self)
    }
}
pub fn fold_expr_yield<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprYield<U>,
) -> Result<ExprYield<F::TargetU>, F::Error> {
    let ExprYield { value, range } = node;
    let context = folder.will_map_user(&range);

    let value = Foldable::fold(value, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprYield { value, range })
}
impl<T, U> Foldable<T, U> for ExprYieldFrom<T> {
    type Mapped = ExprYieldFrom<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_yield_from(self)
    }
}
pub fn fold_expr_yield_from<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprYieldFrom<U>,
) -> Result<ExprYieldFrom<F::TargetU>, F::Error> {
    let ExprYieldFrom { value, range } = node;
    let context = folder.will_map_user(&range);

    let value = Foldable::fold(value, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprYieldFrom { value, range })
}
impl<T, U> Foldable<T, U> for ExprCompare<T> {
    type Mapped = ExprCompare<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_compare(self)
    }
}
pub fn fold_expr_compare<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprCompare<U>,
) -> Result<ExprCompare<F::TargetU>, F::Error> {
    let ExprCompare {
        left,
        ops,
        comparators,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let left = Foldable::fold(left, folder)?;
    let ops = Foldable::fold(ops, folder)?;
    let comparators = Foldable::fold(comparators, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprCompare {
        left,
        ops,
        comparators,
        range,
    })
}
impl<T, U> Foldable<T, U> for ExprCall<T> {
    type Mapped = ExprCall<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_call(self)
    }
}
pub fn fold_expr_call<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprCall<U>,
) -> Result<ExprCall<F::TargetU>, F::Error> {
    let ExprCall {
        func,
        args,
        keywords,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let func = Foldable::fold(func, folder)?;
    let args = Foldable::fold(args, folder)?;
    let keywords = Foldable::fold(keywords, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprCall {
        func,
        args,
        keywords,
        range,
    })
}
impl<T, U> Foldable<T, U> for ExprFormattedValue<T> {
    type Mapped = ExprFormattedValue<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_formatted_value(self)
    }
}
pub fn fold_expr_formatted_value<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprFormattedValue<U>,
) -> Result<ExprFormattedValue<F::TargetU>, F::Error> {
    let ExprFormattedValue {
        value,
        conversion,
        format_spec,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let value = Foldable::fold(value, folder)?;
    let conversion = Foldable::fold(conversion, folder)?;
    let format_spec = Foldable::fold(format_spec, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprFormattedValue {
        value,
        conversion,
        format_spec,
        range,
    })
}
impl<T, U> Foldable<T, U> for ExprJoinedStr<T> {
    type Mapped = ExprJoinedStr<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_joined_str(self)
    }
}
pub fn fold_expr_joined_str<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprJoinedStr<U>,
) -> Result<ExprJoinedStr<F::TargetU>, F::Error> {
    let ExprJoinedStr { values, range } = node;
    let context = folder.will_map_user(&range);

    let values = Foldable::fold(values, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprJoinedStr { values, range })
}
impl<T, U> Foldable<T, U> for ExprConstant<T> {
    type Mapped = ExprConstant<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_constant(self)
    }
}
pub fn fold_expr_constant<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprConstant<U>,
) -> Result<ExprConstant<F::TargetU>, F::Error> {
    let ExprConstant { value, kind, range } = node;
    let context = folder.will_map_user(&range);

    let value = Foldable::fold(value, folder)?;
    let kind = Foldable::fold(kind, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprConstant { value, kind, range })
}
impl<T, U> Foldable<T, U> for ExprAttribute<T> {
    type Mapped = ExprAttribute<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_attribute(self)
    }
}
pub fn fold_expr_attribute<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprAttribute<U>,
) -> Result<ExprAttribute<F::TargetU>, F::Error> {
    let ExprAttribute {
        value,
        attr,
        ctx,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let value = Foldable::fold(value, folder)?;
    let attr = Foldable::fold(attr, folder)?;
    let ctx = Foldable::fold(ctx, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprAttribute {
        value,
        attr,
        ctx,
        range,
    })
}
impl<T, U> Foldable<T, U> for ExprSubscript<T> {
    type Mapped = ExprSubscript<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_subscript(self)
    }
}
pub fn fold_expr_subscript<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprSubscript<U>,
) -> Result<ExprSubscript<F::TargetU>, F::Error> {
    let ExprSubscript {
        value,
        slice,
        ctx,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let value = Foldable::fold(value, folder)?;
    let slice = Foldable::fold(slice, folder)?;
    let ctx = Foldable::fold(ctx, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprSubscript {
        value,
        slice,
        ctx,
        range,
    })
}
impl<T, U> Foldable<T, U> for ExprStarred<T> {
    type Mapped = ExprStarred<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_starred(self)
    }
}
pub fn fold_expr_starred<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprStarred<U>,
) -> Result<ExprStarred<F::TargetU>, F::Error> {
    let ExprStarred { value, ctx, range } = node;
    let context = folder.will_map_user(&range);

    let value = Foldable::fold(value, folder)?;
    let ctx = Foldable::fold(ctx, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprStarred { value, ctx, range })
}
impl<T, U> Foldable<T, U> for ExprName<T> {
    type Mapped = ExprName<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_name(self)
    }
}
pub fn fold_expr_name<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprName<U>,
) -> Result<ExprName<F::TargetU>, F::Error> {
    let ExprName { id, ctx, range } = node;
    let context = folder.will_map_user(&range);

    let id = Foldable::fold(id, folder)?;
    let ctx = Foldable::fold(ctx, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprName { id, ctx, range })
}
impl<T, U> Foldable<T, U> for ExprList<T> {
    type Mapped = ExprList<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_list(self)
    }
}
pub fn fold_expr_list<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprList<U>,
) -> Result<ExprList<F::TargetU>, F::Error> {
    let ExprList { elts, ctx, range } = node;
    let context = folder.will_map_user(&range);

    let elts = Foldable::fold(elts, folder)?;
    let ctx = Foldable::fold(ctx, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprList { elts, ctx, range })
}
impl<T, U> Foldable<T, U> for ExprTuple<T> {
    type Mapped = ExprTuple<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_tuple(self)
    }
}
pub fn fold_expr_tuple<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprTuple<U>,
) -> Result<ExprTuple<F::TargetU>, F::Error> {
    let ExprTuple { elts, ctx, range } = node;
    let context = folder.will_map_user(&range);

    let elts = Foldable::fold(elts, folder)?;
    let ctx = Foldable::fold(ctx, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprTuple { elts, ctx, range })
}
impl<T, U> Foldable<T, U> for ExprSlice<T> {
    type Mapped = ExprSlice<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_slice(self)
    }
}
pub fn fold_expr_slice<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprSlice<U>,
) -> Result<ExprSlice<F::TargetU>, F::Error> {
    let ExprSlice {
        lower,
        upper,
        step,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let lower = Foldable::fold(lower, folder)?;
    let upper = Foldable::fold(upper, folder)?;
    let step = Foldable::fold(step, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExprSlice {
        lower,
        upper,
        step,
        range,
    })
}
impl<T, U> Foldable<T, U> for ExprContext {
    type Mapped = ExprContext;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_context(self)
    }
}
pub fn fold_expr_context<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprContext,
) -> Result<ExprContext, F::Error> {
    Ok(node)
}
impl<T, U> Foldable<T, U> for BoolOp {
    type Mapped = BoolOp;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_boolop(self)
    }
}
pub fn fold_boolop<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: BoolOp,
) -> Result<BoolOp, F::Error> {
    Ok(node)
}
impl<T, U> Foldable<T, U> for Operator {
    type Mapped = Operator;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_operator(self)
    }
}
pub fn fold_operator<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Operator,
) -> Result<Operator, F::Error> {
    Ok(node)
}
impl<T, U> Foldable<T, U> for UnaryOp {
    type Mapped = UnaryOp;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_unaryop(self)
    }
}
pub fn fold_unaryop<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: UnaryOp,
) -> Result<UnaryOp, F::Error> {
    Ok(node)
}
impl<T, U> Foldable<T, U> for CmpOp {
    type Mapped = CmpOp;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_cmpop(self)
    }
}
pub fn fold_cmpop<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: CmpOp,
) -> Result<CmpOp, F::Error> {
    Ok(node)
}
impl<T, U> Foldable<T, U> for Comprehension<T> {
    type Mapped = Comprehension<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_comprehension(self)
    }
}
pub fn fold_comprehension<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Comprehension<U>,
) -> Result<Comprehension<F::TargetU>, F::Error> {
    let Comprehension {
        target,
        iter,
        ifs,
        is_async,
        range,
    } = node;
    let context = folder.will_map_user_cfg(&range);
    let target = Foldable::fold(target, folder)?;
    let iter = Foldable::fold(iter, folder)?;
    let ifs = Foldable::fold(ifs, folder)?;
    let is_async = Foldable::fold(is_async, folder)?;
    let range = folder.map_user_cfg(range, context)?;
    Ok(Comprehension {
        target,
        iter,
        ifs,
        is_async,
        range,
    })
}
impl<T, U> Foldable<T, U> for ExceptHandler<T> {
    type Mapped = ExceptHandler<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_excepthandler(self)
    }
}
pub fn fold_excepthandler<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExceptHandler<U>,
) -> Result<ExceptHandler<F::TargetU>, F::Error> {
    let folded = match node {
        ExceptHandler::ExceptHandler(cons) => {
            ExceptHandler::ExceptHandler(Foldable::fold(cons, folder)?)
        }
    };
    Ok(folded)
}
impl<T, U> Foldable<T, U> for ExceptHandlerExceptHandler<T> {
    type Mapped = ExceptHandlerExceptHandler<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_excepthandler_except_handler(self)
    }
}
pub fn fold_excepthandler_except_handler<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExceptHandlerExceptHandler<U>,
) -> Result<ExceptHandlerExceptHandler<F::TargetU>, F::Error> {
    let ExceptHandlerExceptHandler {
        type_,
        name,
        body,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let type_ = Foldable::fold(type_, folder)?;
    let name = Foldable::fold(name, folder)?;
    let body = Foldable::fold(body, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(ExceptHandlerExceptHandler {
        type_,
        name,
        body,
        range,
    })
}
impl<T, U> Foldable<T, U> for Arguments<T> {
    type Mapped = Arguments<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_arguments(self)
    }
}
pub fn fold_arguments<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Arguments<U>,
) -> Result<Arguments<F::TargetU>, F::Error> {
    let Arguments {
        posonlyargs,
        args,
        vararg,
        kwonlyargs,
        kwarg,
        range,
    } = node;
    let context = folder.will_map_user_cfg(&range);
    let posonlyargs = Foldable::fold(posonlyargs, folder)?;
    let args = Foldable::fold(args, folder)?;
    let vararg = Foldable::fold(vararg, folder)?;
    let kwonlyargs = Foldable::fold(kwonlyargs, folder)?;
    let kwarg = Foldable::fold(kwarg, folder)?;
    let range = folder.map_user_cfg(range, context)?;
    Ok(Arguments {
        posonlyargs,
        args,
        vararg,
        kwonlyargs,
        kwarg,
        range,
    })
}
impl<T, U> Foldable<T, U> for Arg<T> {
    type Mapped = Arg<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_arg(self)
    }
}
pub fn fold_arg<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Arg<U>,
) -> Result<Arg<F::TargetU>, F::Error> {
    let Arg {
        arg,
        annotation,
        type_comment,
        range,
    } = node;
    let context = folder.will_map_user(&range);
    let arg = Foldable::fold(arg, folder)?;
    let annotation = Foldable::fold(annotation, folder)?;
    let type_comment = Foldable::fold(type_comment, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(Arg {
        arg,
        annotation,
        type_comment,
        range,
    })
}
impl<T, U> Foldable<T, U> for Keyword<T> {
    type Mapped = Keyword<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_keyword(self)
    }
}
pub fn fold_keyword<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Keyword<U>,
) -> Result<Keyword<F::TargetU>, F::Error> {
    let Keyword { arg, value, range } = node;
    let context = folder.will_map_user(&range);
    let arg = Foldable::fold(arg, folder)?;
    let value = Foldable::fold(value, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(Keyword { arg, value, range })
}
impl<T, U> Foldable<T, U> for Alias<T> {
    type Mapped = Alias<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_alias(self)
    }
}
pub fn fold_alias<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Alias<U>,
) -> Result<Alias<F::TargetU>, F::Error> {
    let Alias {
        name,
        asname,
        range,
    } = node;
    let context = folder.will_map_user(&range);
    let name = Foldable::fold(name, folder)?;
    let asname = Foldable::fold(asname, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(Alias {
        name,
        asname,
        range,
    })
}
impl<T, U> Foldable<T, U> for WithItem<T> {
    type Mapped = WithItem<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_withitem(self)
    }
}
pub fn fold_withitem<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: WithItem<U>,
) -> Result<WithItem<F::TargetU>, F::Error> {
    let WithItem {
        context_expr,
        optional_vars,
        range,
    } = node;
    let context = folder.will_map_user_cfg(&range);
    let context_expr = Foldable::fold(context_expr, folder)?;
    let optional_vars = Foldable::fold(optional_vars, folder)?;
    let range = folder.map_user_cfg(range, context)?;
    Ok(WithItem {
        context_expr,
        optional_vars,
        range,
    })
}
impl<T, U> Foldable<T, U> for MatchCase<T> {
    type Mapped = MatchCase<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_match_case(self)
    }
}
pub fn fold_match_case<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: MatchCase<U>,
) -> Result<MatchCase<F::TargetU>, F::Error> {
    let MatchCase {
        pattern,
        guard,
        body,
        range,
    } = node;
    let context = folder.will_map_user_cfg(&range);
    let pattern = Foldable::fold(pattern, folder)?;
    let guard = Foldable::fold(guard, folder)?;
    let body = Foldable::fold(body, folder)?;
    let range = folder.map_user_cfg(range, context)?;
    Ok(MatchCase {
        pattern,
        guard,
        body,
        range,
    })
}
impl<T, U> Foldable<T, U> for Pattern<T> {
    type Mapped = Pattern<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_pattern(self)
    }
}
pub fn fold_pattern<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Pattern<U>,
) -> Result<Pattern<F::TargetU>, F::Error> {
    let folded = match node {
        Pattern::MatchValue(cons) => Pattern::MatchValue(Foldable::fold(cons, folder)?),
        Pattern::MatchSingleton(cons) => Pattern::MatchSingleton(Foldable::fold(cons, folder)?),
        Pattern::MatchSequence(cons) => Pattern::MatchSequence(Foldable::fold(cons, folder)?),
        Pattern::MatchMapping(cons) => Pattern::MatchMapping(Foldable::fold(cons, folder)?),
        Pattern::MatchClass(cons) => Pattern::MatchClass(Foldable::fold(cons, folder)?),
        Pattern::MatchStar(cons) => Pattern::MatchStar(Foldable::fold(cons, folder)?),
        Pattern::MatchAs(cons) => Pattern::MatchAs(Foldable::fold(cons, folder)?),
        Pattern::MatchOr(cons) => Pattern::MatchOr(Foldable::fold(cons, folder)?),
    };
    Ok(folded)
}
impl<T, U> Foldable<T, U> for PatternMatchValue<T> {
    type Mapped = PatternMatchValue<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_pattern_match_value(self)
    }
}
pub fn fold_pattern_match_value<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: PatternMatchValue<U>,
) -> Result<PatternMatchValue<F::TargetU>, F::Error> {
    let PatternMatchValue { value, range } = node;
    let context = folder.will_map_user(&range);

    let value = Foldable::fold(value, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(PatternMatchValue { value, range })
}
impl<T, U> Foldable<T, U> for PatternMatchSingleton<T> {
    type Mapped = PatternMatchSingleton<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_pattern_match_singleton(self)
    }
}
pub fn fold_pattern_match_singleton<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: PatternMatchSingleton<U>,
) -> Result<PatternMatchSingleton<F::TargetU>, F::Error> {
    let PatternMatchSingleton { value, range } = node;
    let context = folder.will_map_user(&range);

    let value = Foldable::fold(value, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(PatternMatchSingleton { value, range })
}
impl<T, U> Foldable<T, U> for PatternMatchSequence<T> {
    type Mapped = PatternMatchSequence<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_pattern_match_sequence(self)
    }
}
pub fn fold_pattern_match_sequence<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: PatternMatchSequence<U>,
) -> Result<PatternMatchSequence<F::TargetU>, F::Error> {
    let PatternMatchSequence { patterns, range } = node;
    let context = folder.will_map_user(&range);

    let patterns = Foldable::fold(patterns, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(PatternMatchSequence { patterns, range })
}
impl<T, U> Foldable<T, U> for PatternMatchMapping<T> {
    type Mapped = PatternMatchMapping<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_pattern_match_mapping(self)
    }
}
pub fn fold_pattern_match_mapping<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: PatternMatchMapping<U>,
) -> Result<PatternMatchMapping<F::TargetU>, F::Error> {
    let PatternMatchMapping {
        keys,
        patterns,
        rest,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let keys = Foldable::fold(keys, folder)?;
    let patterns = Foldable::fold(patterns, folder)?;
    let rest = Foldable::fold(rest, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(PatternMatchMapping {
        keys,
        patterns,
        rest,
        range,
    })
}
impl<T, U> Foldable<T, U> for PatternMatchClass<T> {
    type Mapped = PatternMatchClass<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_pattern_match_class(self)
    }
}
pub fn fold_pattern_match_class<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: PatternMatchClass<U>,
) -> Result<PatternMatchClass<F::TargetU>, F::Error> {
    let PatternMatchClass {
        cls,
        patterns,
        kwd_attrs,
        kwd_patterns,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let cls = Foldable::fold(cls, folder)?;
    let patterns = Foldable::fold(patterns, folder)?;
    let kwd_attrs = Foldable::fold(kwd_attrs, folder)?;
    let kwd_patterns = Foldable::fold(kwd_patterns, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(PatternMatchClass {
        cls,
        patterns,
        kwd_attrs,
        kwd_patterns,
        range,
    })
}
impl<T, U> Foldable<T, U> for PatternMatchStar<T> {
    type Mapped = PatternMatchStar<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_pattern_match_star(self)
    }
}
pub fn fold_pattern_match_star<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: PatternMatchStar<U>,
) -> Result<PatternMatchStar<F::TargetU>, F::Error> {
    let PatternMatchStar { name, range } = node;
    let context = folder.will_map_user(&range);

    let name = Foldable::fold(name, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(PatternMatchStar { name, range })
}
impl<T, U> Foldable<T, U> for PatternMatchAs<T> {
    type Mapped = PatternMatchAs<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_pattern_match_as(self)
    }
}
pub fn fold_pattern_match_as<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: PatternMatchAs<U>,
) -> Result<PatternMatchAs<F::TargetU>, F::Error> {
    let PatternMatchAs {
        pattern,
        name,
        range,
    } = node;
    let context = folder.will_map_user(&range);

    let pattern = Foldable::fold(pattern, folder)?;
    let name = Foldable::fold(name, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(PatternMatchAs {
        pattern,
        name,
        range,
    })
}
impl<T, U> Foldable<T, U> for PatternMatchOr<T> {
    type Mapped = PatternMatchOr<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_pattern_match_or(self)
    }
}
pub fn fold_pattern_match_or<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: PatternMatchOr<U>,
) -> Result<PatternMatchOr<F::TargetU>, F::Error> {
    let PatternMatchOr { patterns, range } = node;
    let context = folder.will_map_user(&range);

    let patterns = Foldable::fold(patterns, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(PatternMatchOr { patterns, range })
}
impl<T, U> Foldable<T, U> for TypeIgnore<T> {
    type Mapped = TypeIgnore<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_type_ignore(self)
    }
}
pub fn fold_type_ignore<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: TypeIgnore<U>,
) -> Result<TypeIgnore<F::TargetU>, F::Error> {
    let folded = match node {
        TypeIgnore::TypeIgnore(cons) => TypeIgnore::TypeIgnore(Foldable::fold(cons, folder)?),
    };
    Ok(folded)
}
impl<T, U> Foldable<T, U> for TypeIgnoreTypeIgnore<T> {
    type Mapped = TypeIgnoreTypeIgnore<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_type_ignore_type_ignore(self)
    }
}
pub fn fold_type_ignore_type_ignore<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: TypeIgnoreTypeIgnore<U>,
) -> Result<TypeIgnoreTypeIgnore<F::TargetU>, F::Error> {
    let TypeIgnoreTypeIgnore { lineno, tag, range } = node;
    let context = folder.will_map_user_cfg(&range);

    let lineno = Foldable::fold(lineno, folder)?;
    let tag = Foldable::fold(tag, folder)?;
    let range = folder.map_user_cfg(range, context)?;
    Ok(TypeIgnoreTypeIgnore { lineno, tag, range })
}
impl<T, U> Foldable<T, U> for Decorator<T> {
    type Mapped = Decorator<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_decorator(self)
    }
}
pub fn fold_decorator<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Decorator<U>,
) -> Result<Decorator<F::TargetU>, F::Error> {
    let Decorator { expression, range } = node;
    let context = folder.will_map_user_cfg(&range);
    let expression = Foldable::fold(expression, folder)?;
    let range = folder.map_user_cfg(range, context)?;
    Ok(Decorator { expression, range })
}
impl<T, U> Foldable<T, U> for ArgWithDefault<T> {
    type Mapped = ArgWithDefault<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_arg_with_default(self)
    }
}
pub fn fold_arg_with_default<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ArgWithDefault<U>,
) -> Result<ArgWithDefault<F::TargetU>, F::Error> {
    let ArgWithDefault {
        def,
        default,
        range,
    } = node;
    let context = folder.will_map_user_cfg(&range);
    let def = Foldable::fold(def, folder)?;
    let default = Foldable::fold(default, folder)?;
    let range = folder.map_user_cfg(range, context)?;
    Ok(ArgWithDefault {
        def,
        default,
        range,
    })
}
